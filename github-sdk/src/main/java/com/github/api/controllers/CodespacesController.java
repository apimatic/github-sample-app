/*
 * GitHubAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.github.api.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.github.api.ApiHelper;
import com.github.api.Server;
import com.github.api.exceptions.ApiException;
import com.github.api.exceptions.OrgsCodespaces401ErrorException;
import com.github.api.exceptions.OrgsCodespaces403ErrorException;
import com.github.api.exceptions.OrgsCodespaces404ErrorException;
import com.github.api.exceptions.OrgsCodespaces500ErrorException;
import com.github.api.exceptions.OrgsCodespacesBilling404ErrorException;
import com.github.api.exceptions.OrgsCodespacesBilling422ErrorException;
import com.github.api.exceptions.OrgsCodespacesBilling500ErrorException;
import com.github.api.exceptions.OrgsCodespacesSecrets404ErrorException;
import com.github.api.exceptions.OrgsCodespacesSecrets422ErrorException;
import com.github.api.exceptions.OrgsCodespacesSecretsRepositories404ErrorException;
import com.github.api.exceptions.OrgsCodespacesSecretsRepositoriesRepositoryId404ErrorException;
import com.github.api.exceptions.OrgsCodespacesSecretsRepositoriesRepositoryId422ErrorException;
import com.github.api.exceptions.OrgsMembersCodespaces401ErrorException;
import com.github.api.exceptions.OrgsMembersCodespaces403ErrorException;
import com.github.api.exceptions.OrgsMembersCodespaces404ErrorException;
import com.github.api.exceptions.OrgsMembersCodespaces500ErrorException;
import com.github.api.exceptions.OrgsMembersCodespacesCodespaceName401ErrorException;
import com.github.api.exceptions.OrgsMembersCodespacesCodespaceName403ErrorException;
import com.github.api.exceptions.OrgsMembersCodespacesCodespaceName404ErrorException;
import com.github.api.exceptions.OrgsMembersCodespacesCodespaceName500ErrorException;
import com.github.api.exceptions.OrgsMembersCodespacesCodespaceNameStop401ErrorException;
import com.github.api.exceptions.OrgsMembersCodespacesCodespaceNameStop403ErrorException;
import com.github.api.exceptions.OrgsMembersCodespacesCodespaceNameStop404ErrorException;
import com.github.api.exceptions.OrgsMembersCodespacesCodespaceNameStop500ErrorException;
import com.github.api.exceptions.ReposCodespaces400ErrorException;
import com.github.api.exceptions.ReposCodespaces401ErrorException;
import com.github.api.exceptions.ReposCodespaces403ErrorException;
import com.github.api.exceptions.ReposCodespaces404ErrorException;
import com.github.api.exceptions.ReposCodespaces500ErrorException;
import com.github.api.exceptions.ReposCodespacesDevcontainers400ErrorException;
import com.github.api.exceptions.ReposCodespacesDevcontainers401ErrorException;
import com.github.api.exceptions.ReposCodespacesDevcontainers403ErrorException;
import com.github.api.exceptions.ReposCodespacesDevcontainers404ErrorException;
import com.github.api.exceptions.ReposCodespacesDevcontainers500ErrorException;
import com.github.api.exceptions.ReposCodespacesMachines401ErrorException;
import com.github.api.exceptions.ReposCodespacesMachines403ErrorException;
import com.github.api.exceptions.ReposCodespacesMachines404ErrorException;
import com.github.api.exceptions.ReposCodespacesMachines500ErrorException;
import com.github.api.exceptions.ReposCodespacesNew401ErrorException;
import com.github.api.exceptions.ReposCodespacesNew403ErrorException;
import com.github.api.exceptions.ReposCodespacesNew404ErrorException;
import com.github.api.exceptions.ReposPullsPullNumberCodespaces401ErrorException;
import com.github.api.exceptions.ReposPullsPullNumberCodespaces403ErrorException;
import com.github.api.exceptions.ReposPullsPullNumberCodespaces404ErrorException;
import com.github.api.exceptions.ServiceUnavailable1Exception;
import com.github.api.exceptions.UserCodespaces401ErrorException;
import com.github.api.exceptions.UserCodespaces403ErrorException;
import com.github.api.exceptions.UserCodespaces404ErrorException;
import com.github.api.exceptions.UserCodespaces500ErrorException;
import com.github.api.exceptions.UserCodespacesExports401ErrorException;
import com.github.api.exceptions.UserCodespacesExports403ErrorException;
import com.github.api.exceptions.UserCodespacesExports404ErrorException;
import com.github.api.exceptions.UserCodespacesExports422ErrorException;
import com.github.api.exceptions.UserCodespacesExports500ErrorException;
import com.github.api.exceptions.UserCodespacesMachines401ErrorException;
import com.github.api.exceptions.UserCodespacesMachines403ErrorException;
import com.github.api.exceptions.UserCodespacesMachines404ErrorException;
import com.github.api.exceptions.UserCodespacesMachines500ErrorException;
import com.github.api.exceptions.UserCodespacesPublish401ErrorException;
import com.github.api.exceptions.UserCodespacesPublish403ErrorException;
import com.github.api.exceptions.UserCodespacesPublish404ErrorException;
import com.github.api.exceptions.UserCodespacesPublish422ErrorException;
import com.github.api.exceptions.UserCodespacesSecrets404ErrorException;
import com.github.api.exceptions.UserCodespacesSecrets422ErrorException;
import com.github.api.exceptions.UserCodespacesSecretsRepositories401ErrorException;
import com.github.api.exceptions.UserCodespacesSecretsRepositories403ErrorException;
import com.github.api.exceptions.UserCodespacesSecretsRepositories404ErrorException;
import com.github.api.exceptions.UserCodespacesSecretsRepositories500ErrorException;
import com.github.api.exceptions.UserCodespacesStart400ErrorException;
import com.github.api.exceptions.UserCodespacesStart401ErrorException;
import com.github.api.exceptions.UserCodespacesStart402ErrorException;
import com.github.api.exceptions.UserCodespacesStart403ErrorException;
import com.github.api.exceptions.UserCodespacesStart404ErrorException;
import com.github.api.exceptions.UserCodespacesStart409ErrorException;
import com.github.api.exceptions.UserCodespacesStart500ErrorException;
import com.github.api.exceptions.UserCodespacesStop401ErrorException;
import com.github.api.exceptions.UserCodespacesStop403ErrorException;
import com.github.api.exceptions.UserCodespacesStop404ErrorException;
import com.github.api.exceptions.UserCodespacesStop500ErrorException;
import com.github.api.http.request.HttpMethod;
import com.github.api.models.OrgsActionsSecretsRepositoriesResponse;
import com.github.api.models.OrgsCodespacesBillingRequest;
import com.github.api.models.OrgsCodespacesResponse;
import com.github.api.models.OrgsCodespacesSecretsPublicKeyResponse;
import com.github.api.models.OrgsCodespacesSecretsRepositoriesRequest;
import com.github.api.models.OrgsCodespacesSecretsRequest;
import com.github.api.models.OrgsCodespacesSecretsResponse;
import com.github.api.models.OrgsCodespacesSecretsResponse2;
import com.github.api.models.OrgsMembersCodespacesCodespaceNameStopResponse;
import com.github.api.models.OrgsMembersCodespacesResponse;
import com.github.api.models.ReposCodespacesDevcontainersResponse;
import com.github.api.models.ReposCodespacesMachinesResponse;
import com.github.api.models.ReposCodespacesNewResponse;
import com.github.api.models.ReposCodespacesResponse;
import com.github.api.models.ReposCodespacesResponse1;
import com.github.api.models.ReposCodespacesSecretsPublicKeyResponse;
import com.github.api.models.ReposCodespacesSecretsResponse;
import com.github.api.models.ReposCodespacesSecretsSecretNameRequest;
import com.github.api.models.ReposCodespacesSecretsSecretNameResponse;
import com.github.api.models.ReposPullsPullNumberCodespacesResponse;
import com.github.api.models.UserCodespacesExportsResponse;
import com.github.api.models.UserCodespacesMachinesResponse;
import com.github.api.models.UserCodespacesPublishRequest;
import com.github.api.models.UserCodespacesPublishResponse;
import com.github.api.models.UserCodespacesRequest2;
import com.github.api.models.UserCodespacesResponse;
import com.github.api.models.UserCodespacesResponse1;
import com.github.api.models.UserCodespacesSecretsPublicKeyResponse;
import com.github.api.models.UserCodespacesSecretsRepositoriesRequest;
import com.github.api.models.UserCodespacesSecretsRequest;
import com.github.api.models.UserCodespacesSecretsResponse;
import com.github.api.models.UserCodespacesSecretsResponse1;
import com.github.api.models.UserCodespacesStartResponse;
import com.github.api.models.UserCodespacesStopResponse;
import com.github.api.models.containers.CodespacesCreateForAuthenticatedUserBody;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class CodespacesController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public CodespacesController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Lists the codespaces associated to a specified organization. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsCodespacesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsCodespacesResponse codespacesListInOrganization(
            final String org,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareCodespacesListInOrganizationRequest(org, perPage, page).execute();
    }

    /**
     * Lists the codespaces associated to a specified organization. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsCodespacesResponse response from the API call
     */
    public CompletableFuture<OrgsCodespacesResponse> codespacesListInOrganizationAsync(
            final String org,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareCodespacesListInOrganizationRequest(org, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesListInOrganization.
     */
    private ApiCall<OrgsCodespacesResponse, ApiException> prepareCodespacesListInOrganizationRequest(
            final String org,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<OrgsCodespacesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/codespaces")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsCodespacesResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new OrgsCodespaces401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new OrgsCodespaces403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsCodespaces404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new OrgsCodespaces500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sets which users can access codespaces in an organization. This is synonymous with granting
     * or revoking codespaces billing permissions for users according to the visibility. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void codespacesSetCodespacesBilling(
            final String org,
            final OrgsCodespacesBillingRequest body) throws ApiException, IOException {
        prepareCodespacesSetCodespacesBillingRequest(org, body).execute();
    }

    /**
     * Sets which users can access codespaces in an organization. This is synonymous with granting
     * or revoking codespaces billing permissions for users according to the visibility. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> codespacesSetCodespacesBillingAsync(
            final String org,
            final OrgsCodespacesBillingRequest body) {
        try { 
            return prepareCodespacesSetCodespacesBillingRequest(org, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesSetCodespacesBilling.
     */
    private ApiCall<Void, ApiException> prepareCodespacesSetCodespacesBillingRequest(
            final String org,
            final OrgsCodespacesBillingRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/codespaces/billing")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Users are neither members nor collaborators of this organization.",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsCodespacesBilling404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new OrgsCodespacesBilling422ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new OrgsCodespacesBilling500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all Codespaces secrets available at the organization-level without revealing their
     * encrypted values. You must authenticate using an access token with the `admin:org` scope to
     * use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsCodespacesSecretsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsCodespacesSecretsResponse codespacesListOrgSecrets(
            final String org,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareCodespacesListOrgSecretsRequest(org, perPage, page).execute();
    }

    /**
     * Lists all Codespaces secrets available at the organization-level without revealing their
     * encrypted values. You must authenticate using an access token with the `admin:org` scope to
     * use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsCodespacesSecretsResponse response from the API call
     */
    public CompletableFuture<OrgsCodespacesSecretsResponse> codespacesListOrgSecretsAsync(
            final String org,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareCodespacesListOrgSecretsRequest(org, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesListOrgSecrets.
     */
    private ApiCall<OrgsCodespacesSecretsResponse, ApiException> prepareCodespacesListOrgSecretsRequest(
            final String org,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<OrgsCodespacesSecretsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/codespaces/secrets")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsCodespacesSecretsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a public key for an organization, which is required in order to encrypt secrets. You
     * need to encrypt the value of a secret before you can create or update secrets. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the OrgsCodespacesSecretsPublicKeyResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsCodespacesSecretsPublicKeyResponse codespacesGetOrgPublicKey(
            final String org) throws ApiException, IOException {
        return prepareCodespacesGetOrgPublicKeyRequest(org).execute();
    }

    /**
     * Gets a public key for an organization, which is required in order to encrypt secrets. You
     * need to encrypt the value of a secret before you can create or update secrets. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the OrgsCodespacesSecretsPublicKeyResponse response from the API call
     */
    public CompletableFuture<OrgsCodespacesSecretsPublicKeyResponse> codespacesGetOrgPublicKeyAsync(
            final String org) {
        try { 
            return prepareCodespacesGetOrgPublicKeyRequest(org).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesGetOrgPublicKey.
     */
    private ApiCall<OrgsCodespacesSecretsPublicKeyResponse, ApiException> prepareCodespacesGetOrgPublicKeyRequest(
            final String org) throws IOException {
        return new ApiCall.Builder<OrgsCodespacesSecretsPublicKeyResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/codespaces/secrets/public-key")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsCodespacesSecretsPublicKeyResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets an organization secret without revealing its encrypted value. You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the OrgsCodespacesSecretsResponse2 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsCodespacesSecretsResponse2 codespacesGetOrgSecret(
            final String org,
            final String secretName) throws ApiException, IOException {
        return prepareCodespacesGetOrgSecretRequest(org, secretName).execute();
    }

    /**
     * Gets an organization secret without revealing its encrypted value. You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the OrgsCodespacesSecretsResponse2 response from the API call
     */
    public CompletableFuture<OrgsCodespacesSecretsResponse2> codespacesGetOrgSecretAsync(
            final String org,
            final String secretName) {
        try { 
            return prepareCodespacesGetOrgSecretRequest(org, secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesGetOrgSecret.
     */
    private ApiCall<OrgsCodespacesSecretsResponse2, ApiException> prepareCodespacesGetOrgSecretRequest(
            final String org,
            final String secretName) throws IOException {
        return new ApiCall.Builder<OrgsCodespacesSecretsResponse2, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/codespaces/secrets/{secret_name}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsCodespacesSecretsResponse2.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates or updates an organization secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint. ####
     * Example encrypting a secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example encrypting a secret using Python Encrypt your secret
     * using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with
     * Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example encrypting a
     * secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object codespacesCreateOrUpdateOrgSecret(
            final String org,
            final String secretName,
            final OrgsCodespacesSecretsRequest body) throws ApiException, IOException {
        return prepareCodespacesCreateOrUpdateOrgSecretRequest(org, secretName, body).execute();
    }

    /**
     * Creates or updates an organization secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint. ####
     * Example encrypting a secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example encrypting a secret using Python Encrypt your secret
     * using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with
     * Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example encrypting a
     * secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> codespacesCreateOrUpdateOrgSecretAsync(
            final String org,
            final String secretName,
            final OrgsCodespacesSecretsRequest body) {
        try { 
            return prepareCodespacesCreateOrUpdateOrgSecretRequest(org, secretName, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesCreateOrUpdateOrgSecret.
     */
    private ApiCall<Object, ApiException> prepareCodespacesCreateOrUpdateOrgSecretRequest(
            final String org,
            final String secretName,
            final OrgsCodespacesSecretsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/codespaces/secrets/{secret_name}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsCodespacesSecrets404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new OrgsCodespacesSecrets422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes an organization secret using the secret name. You must authenticate using an access
     * token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void codespacesDeleteOrgSecret(
            final String org,
            final String secretName) throws ApiException, IOException {
        prepareCodespacesDeleteOrgSecretRequest(org, secretName).execute();
    }

    /**
     * Deletes an organization secret using the secret name. You must authenticate using an access
     * token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> codespacesDeleteOrgSecretAsync(
            final String org,
            final String secretName) {
        try { 
            return prepareCodespacesDeleteOrgSecretRequest(org, secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesDeleteOrgSecret.
     */
    private ApiCall<Void, ApiException> prepareCodespacesDeleteOrgSecretRequest(
            final String org,
            final String secretName) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/codespaces/secrets/{secret_name}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsCodespacesSecrets404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all repositories that have been selected when the `visibility` for repository access to
     * a secret is set to `selected`. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the OrgsActionsSecretsRepositoriesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsSecretsRepositoriesResponse codespacesListSelectedReposForOrgSecret(
            final String org,
            final String secretName,
            final Integer page,
            final Integer perPage) throws ApiException, IOException {
        return prepareCodespacesListSelectedReposForOrgSecretRequest(org, secretName, page,
                perPage).execute();
    }

    /**
     * Lists all repositories that have been selected when the `visibility` for repository access to
     * a secret is set to `selected`. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the OrgsActionsSecretsRepositoriesResponse response from the API call
     */
    public CompletableFuture<OrgsActionsSecretsRepositoriesResponse> codespacesListSelectedReposForOrgSecretAsync(
            final String org,
            final String secretName,
            final Integer page,
            final Integer perPage) {
        try { 
            return prepareCodespacesListSelectedReposForOrgSecretRequest(org, secretName, page,
            perPage).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesListSelectedReposForOrgSecret.
     */
    private ApiCall<OrgsActionsSecretsRepositoriesResponse, ApiException> prepareCodespacesListSelectedReposForOrgSecretRequest(
            final String org,
            final String secretName,
            final Integer page,
            final Integer perPage) throws IOException {
        return new ApiCall.Builder<OrgsActionsSecretsRepositoriesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/codespaces/secrets/{secret_name}/repositories")
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsSecretsRepositoriesResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsCodespacesSecretsRepositories404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Replaces all repositories for an organization secret when the `visibility` for repository
     * access is set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void codespacesSetSelectedReposForOrgSecret(
            final String org,
            final String secretName,
            final OrgsCodespacesSecretsRepositoriesRequest body) throws ApiException, IOException {
        prepareCodespacesSetSelectedReposForOrgSecretRequest(org, secretName, body).execute();
    }

    /**
     * Replaces all repositories for an organization secret when the `visibility` for repository
     * access is set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> codespacesSetSelectedReposForOrgSecretAsync(
            final String org,
            final String secretName,
            final OrgsCodespacesSecretsRepositoriesRequest body) {
        try { 
            return prepareCodespacesSetSelectedReposForOrgSecretRequest(org, secretName,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesSetSelectedReposForOrgSecret.
     */
    private ApiCall<Void, ApiException> prepareCodespacesSetSelectedReposForOrgSecretRequest(
            final String org,
            final String secretName,
            final OrgsCodespacesSecretsRepositoriesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/codespaces/secrets/{secret_name}/repositories")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsCodespacesSecretsRepositories404ErrorException(reason, context)))
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict when visibility type not set to selected",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Adds a repository to an organization secret when the `visibility` for repository access is
     * set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void codespacesAddSelectedRepoToOrgSecret(
            final String org,
            final String secretName,
            final int repositoryId) throws ApiException, IOException {
        prepareCodespacesAddSelectedRepoToOrgSecretRequest(org, secretName, repositoryId).execute();
    }

    /**
     * Adds a repository to an organization secret when the `visibility` for repository access is
     * set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> codespacesAddSelectedRepoToOrgSecretAsync(
            final String org,
            final String secretName,
            final int repositoryId) {
        try { 
            return prepareCodespacesAddSelectedRepoToOrgSecretRequest(org, secretName,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesAddSelectedRepoToOrgSecret.
     */
    private ApiCall<Void, ApiException> prepareCodespacesAddSelectedRepoToOrgSecretRequest(
            final String org,
            final String secretName,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsCodespacesSecretsRepositoriesRepositoryId404ErrorException(reason, context)))
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict when visibility type is not set to selected",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new OrgsCodespacesSecretsRepositoriesRepositoryId422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes a repository from an organization secret when the `visibility` for repository access
     * is set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void codespacesRemoveSelectedRepoFromOrgSecret(
            final String org,
            final String secretName,
            final int repositoryId) throws ApiException, IOException {
        prepareCodespacesRemoveSelectedRepoFromOrgSecretRequest(org, secretName,
                repositoryId).execute();
    }

    /**
     * Removes a repository from an organization secret when the `visibility` for repository access
     * is set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/codespaces#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> codespacesRemoveSelectedRepoFromOrgSecretAsync(
            final String org,
            final String secretName,
            final int repositoryId) {
        try { 
            return prepareCodespacesRemoveSelectedRepoFromOrgSecretRequest(org, secretName,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesRemoveSelectedRepoFromOrgSecret.
     */
    private ApiCall<Void, ApiException> prepareCodespacesRemoveSelectedRepoFromOrgSecretRequest(
            final String org,
            final String secretName,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsCodespacesSecretsRepositoriesRepositoryId404ErrorException(reason, context)))
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict when visibility type not set to selected",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new OrgsCodespacesSecretsRepositoriesRepositoryId422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the codespaces that a member of an organization has for repositories in that
     * organization. You must authenticate using an access token with the `admin:org` scope to use
     * this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsMembersCodespacesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsMembersCodespacesResponse codespacesGetCodespacesForUserInOrg(
            final String org,
            final String username,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareCodespacesGetCodespacesForUserInOrgRequest(org, username, perPage,
                page).execute();
    }

    /**
     * Lists the codespaces that a member of an organization has for repositories in that
     * organization. You must authenticate using an access token with the `admin:org` scope to use
     * this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsMembersCodespacesResponse response from the API call
     */
    public CompletableFuture<OrgsMembersCodespacesResponse> codespacesGetCodespacesForUserInOrgAsync(
            final String org,
            final String username,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareCodespacesGetCodespacesForUserInOrgRequest(org, username, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesGetCodespacesForUserInOrg.
     */
    private ApiCall<OrgsMembersCodespacesResponse, ApiException> prepareCodespacesGetCodespacesForUserInOrgRequest(
            final String org,
            final String username,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<OrgsMembersCodespacesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/members/{username}/codespaces")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsMembersCodespacesResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new OrgsMembersCodespaces401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new OrgsMembersCodespaces403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsMembersCodespaces404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new OrgsMembersCodespaces500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a user's codespace. You must authenticate using an access token with the `admin:org`
     * scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object codespacesDeleteFromOrganization(
            final String org,
            final String username,
            final String codespaceName) throws ApiException, IOException {
        return prepareCodespacesDeleteFromOrganizationRequest(org, username,
                codespaceName).execute();
    }

    /**
     * Deletes a user's codespace. You must authenticate using an access token with the `admin:org`
     * scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> codespacesDeleteFromOrganizationAsync(
            final String org,
            final String username,
            final String codespaceName) {
        try { 
            return prepareCodespacesDeleteFromOrganizationRequest(org, username,
            codespaceName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesDeleteFromOrganization.
     */
    private ApiCall<Object, ApiException> prepareCodespacesDeleteFromOrganizationRequest(
            final String org,
            final String username,
            final String codespaceName) throws IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/members/{username}/codespaces/{codespace_name}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("codespace_name").value(codespaceName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new OrgsMembersCodespacesCodespaceName401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new OrgsMembersCodespacesCodespaceName403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsMembersCodespacesCodespaceName404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new OrgsMembersCodespacesCodespaceName500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Stops a user's codespace. You must authenticate using an access token with the `admin:org`
     * scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the OrgsMembersCodespacesCodespaceNameStopResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsMembersCodespacesCodespaceNameStopResponse codespacesStopInOrganization(
            final String org,
            final String username,
            final String codespaceName) throws ApiException, IOException {
        return prepareCodespacesStopInOrganizationRequest(org, username, codespaceName).execute();
    }

    /**
     * Stops a user's codespace. You must authenticate using an access token with the `admin:org`
     * scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the OrgsMembersCodespacesCodespaceNameStopResponse response from the API call
     */
    public CompletableFuture<OrgsMembersCodespacesCodespaceNameStopResponse> codespacesStopInOrganizationAsync(
            final String org,
            final String username,
            final String codespaceName) {
        try { 
            return prepareCodespacesStopInOrganizationRequest(org, username, codespaceName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesStopInOrganization.
     */
    private ApiCall<OrgsMembersCodespacesCodespaceNameStopResponse, ApiException> prepareCodespacesStopInOrganizationRequest(
            final String org,
            final String username,
            final String codespaceName) throws IOException {
        return new ApiCall.Builder<OrgsMembersCodespacesCodespaceNameStopResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/members/{username}/codespaces/{codespace_name}/stop")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("codespace_name").value(codespaceName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsMembersCodespacesCodespaceNameStopResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new OrgsMembersCodespacesCodespaceNameStop401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new OrgsMembersCodespacesCodespaceNameStop403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsMembersCodespacesCodespaceNameStop404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new OrgsMembersCodespacesCodespaceNameStop500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the codespaces associated to a specified repository and the authenticated user. You
     * must authenticate using an access token with the `codespace` scope to use this endpoint.
     * GitHub Apps must have read access to the `codespaces` repository permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposCodespacesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCodespacesResponse codespacesListInRepositoryForAuthenticatedUser(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareCodespacesListInRepositoryForAuthenticatedUserRequest(owner, repo, perPage,
                page).execute();
    }

    /**
     * Lists the codespaces associated to a specified repository and the authenticated user. You
     * must authenticate using an access token with the `codespace` scope to use this endpoint.
     * GitHub Apps must have read access to the `codespaces` repository permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposCodespacesResponse response from the API call
     */
    public CompletableFuture<ReposCodespacesResponse> codespacesListInRepositoryForAuthenticatedUserAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareCodespacesListInRepositoryForAuthenticatedUserRequest(owner, repo, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesListInRepositoryForAuthenticatedUser.
     */
    private ApiCall<ReposCodespacesResponse, ApiException> prepareCodespacesListInRepositoryForAuthenticatedUserRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposCodespacesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/codespaces")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCodespacesResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new ReposCodespaces401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposCodespaces403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposCodespaces404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new ReposCodespaces500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates a codespace owned by the authenticated user in the specified repository. You must
     * authenticate using an access token with the `codespace` scope to use this endpoint. GitHub
     * Apps must have write access to the `codespaces` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposCodespacesResponse1 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCodespacesResponse1 codespacesCreateWithRepoForAuthenticatedUser(
            final String owner,
            final String repo,
            final Object body) throws ApiException, IOException {
        return prepareCodespacesCreateWithRepoForAuthenticatedUserRequest(owner, repo,
                body).execute();
    }

    /**
     * Creates a codespace owned by the authenticated user in the specified repository. You must
     * authenticate using an access token with the `codespace` scope to use this endpoint. GitHub
     * Apps must have write access to the `codespaces` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposCodespacesResponse1 response from the API call
     */
    public CompletableFuture<ReposCodespacesResponse1> codespacesCreateWithRepoForAuthenticatedUserAsync(
            final String owner,
            final String repo,
            final Object body) {
        try { 
            return prepareCodespacesCreateWithRepoForAuthenticatedUserRequest(owner, repo,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesCreateWithRepoForAuthenticatedUser.
     */
    private ApiCall<ReposCodespacesResponse1, ApiException> prepareCodespacesCreateWithRepoForAuthenticatedUserRequest(
            final String owner,
            final String repo,
            final Object body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposCodespacesResponse1, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/codespaces")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCodespacesResponse1.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new ReposCodespaces400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new ReposCodespaces401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposCodespaces403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposCodespaces404ErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.create("Service unavailable",
                                (reason, context) -> new ServiceUnavailable1Exception(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the devcontainer.json files associated with a specified repository and the
     * authenticated user. These files specify launchpoint configurations for codespaces created
     * within the repository. You must authenticate using an access token with the `codespace` scope
     * to use this endpoint. GitHub Apps must have read access to the `codespaces_metadata`
     * repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposCodespacesDevcontainersResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCodespacesDevcontainersResponse codespacesListDevcontainersInRepositoryForAuthenticatedUser(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareCodespacesListDevcontainersInRepositoryForAuthenticatedUserRequest(owner,
                repo, perPage, page).execute();
    }

    /**
     * Lists the devcontainer.json files associated with a specified repository and the
     * authenticated user. These files specify launchpoint configurations for codespaces created
     * within the repository. You must authenticate using an access token with the `codespace` scope
     * to use this endpoint. GitHub Apps must have read access to the `codespaces_metadata`
     * repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposCodespacesDevcontainersResponse response from the API call
     */
    public CompletableFuture<ReposCodespacesDevcontainersResponse> codespacesListDevcontainersInRepositoryForAuthenticatedUserAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareCodespacesListDevcontainersInRepositoryForAuthenticatedUserRequest(owner, repo,
            perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesListDevcontainersInRepositoryForAuthenticatedUser.
     */
    private ApiCall<ReposCodespacesDevcontainersResponse, ApiException> prepareCodespacesListDevcontainersInRepositoryForAuthenticatedUserRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposCodespacesDevcontainersResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/codespaces/devcontainers")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCodespacesDevcontainersResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new ReposCodespacesDevcontainers400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new ReposCodespacesDevcontainers401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposCodespacesDevcontainers403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposCodespacesDevcontainers404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new ReposCodespacesDevcontainers500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List the machine types available for a given repository based on its configuration. You must
     * authenticate using an access token with the `codespace` scope to use this endpoint. GitHub
     * Apps must have write access to the `codespaces_metadata` repository permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  location  Optional parameter: The location to check for available machines. Assigned
     *         by IP if not provided.
     * @param  clientIp  Optional parameter: IP for location auto-detection when proxying a request
     * @return    Returns the ReposCodespacesMachinesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCodespacesMachinesResponse codespacesRepoMachinesForAuthenticatedUser(
            final String owner,
            final String repo,
            final String location,
            final String clientIp) throws ApiException, IOException {
        return prepareCodespacesRepoMachinesForAuthenticatedUserRequest(owner, repo, location,
                clientIp).execute();
    }

    /**
     * List the machine types available for a given repository based on its configuration. You must
     * authenticate using an access token with the `codespace` scope to use this endpoint. GitHub
     * Apps must have write access to the `codespaces_metadata` repository permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  location  Optional parameter: The location to check for available machines. Assigned
     *         by IP if not provided.
     * @param  clientIp  Optional parameter: IP for location auto-detection when proxying a request
     * @return    Returns the ReposCodespacesMachinesResponse response from the API call
     */
    public CompletableFuture<ReposCodespacesMachinesResponse> codespacesRepoMachinesForAuthenticatedUserAsync(
            final String owner,
            final String repo,
            final String location,
            final String clientIp) {
        try { 
            return prepareCodespacesRepoMachinesForAuthenticatedUserRequest(owner, repo, location,
            clientIp).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesRepoMachinesForAuthenticatedUser.
     */
    private ApiCall<ReposCodespacesMachinesResponse, ApiException> prepareCodespacesRepoMachinesForAuthenticatedUserRequest(
            final String owner,
            final String repo,
            final String location,
            final String clientIp) throws IOException {
        return new ApiCall.Builder<ReposCodespacesMachinesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/codespaces/machines")
                        .queryParam(param -> param.key("location")
                                .value(location).isRequired(false))
                        .queryParam(param -> param.key("client_ip")
                                .value(clientIp).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCodespacesMachinesResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new ReposCodespacesMachines401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposCodespacesMachines403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposCodespacesMachines404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new ReposCodespacesMachines500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the default attributes for codespaces created by the user with the repository. You must
     * authenticate using an access token with the `codespace` scope to use this endpoint. GitHub
     * Apps must have write access to the `codespaces` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Optional parameter: The branch or commit to check for a default devcontainer
     *         path. If not specified, the default branch will be checked.
     * @param  clientIp  Optional parameter: An alternative IP for default location auto-detection,
     *         such as when proxying a request.
     * @return    Returns the ReposCodespacesNewResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCodespacesNewResponse codespacesPreFlightWithRepoForAuthenticatedUser(
            final String owner,
            final String repo,
            final String ref,
            final String clientIp) throws ApiException, IOException {
        return prepareCodespacesPreFlightWithRepoForAuthenticatedUserRequest(owner, repo, ref,
                clientIp).execute();
    }

    /**
     * Gets the default attributes for codespaces created by the user with the repository. You must
     * authenticate using an access token with the `codespace` scope to use this endpoint. GitHub
     * Apps must have write access to the `codespaces` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Optional parameter: The branch or commit to check for a default devcontainer
     *         path. If not specified, the default branch will be checked.
     * @param  clientIp  Optional parameter: An alternative IP for default location auto-detection,
     *         such as when proxying a request.
     * @return    Returns the ReposCodespacesNewResponse response from the API call
     */
    public CompletableFuture<ReposCodespacesNewResponse> codespacesPreFlightWithRepoForAuthenticatedUserAsync(
            final String owner,
            final String repo,
            final String ref,
            final String clientIp) {
        try { 
            return prepareCodespacesPreFlightWithRepoForAuthenticatedUserRequest(owner, repo, ref,
            clientIp).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesPreFlightWithRepoForAuthenticatedUser.
     */
    private ApiCall<ReposCodespacesNewResponse, ApiException> prepareCodespacesPreFlightWithRepoForAuthenticatedUserRequest(
            final String owner,
            final String repo,
            final String ref,
            final String clientIp) throws IOException {
        return new ApiCall.Builder<ReposCodespacesNewResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/codespaces/new")
                        .queryParam(param -> param.key("ref")
                                .value(ref).isRequired(false))
                        .queryParam(param -> param.key("client_ip")
                                .value(clientIp).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCodespacesNewResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new ReposCodespacesNew401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposCodespacesNew403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposCodespacesNew404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all secrets available in a repository without revealing their encrypted values. You
     * must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
     * Apps must have write access to the `codespaces_secrets` repository permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposCodespacesSecretsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCodespacesSecretsResponse codespacesListRepoSecrets(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareCodespacesListRepoSecretsRequest(owner, repo, perPage, page).execute();
    }

    /**
     * Lists all secrets available in a repository without revealing their encrypted values. You
     * must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
     * Apps must have write access to the `codespaces_secrets` repository permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposCodespacesSecretsResponse response from the API call
     */
    public CompletableFuture<ReposCodespacesSecretsResponse> codespacesListRepoSecretsAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareCodespacesListRepoSecretsRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesListRepoSecrets.
     */
    private ApiCall<ReposCodespacesSecretsResponse, ApiException> prepareCodespacesListRepoSecretsRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposCodespacesSecretsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/codespaces/secrets")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCodespacesSecretsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
     * you can create or update secrets. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have write access to the `codespaces_secrets` repository permission to use
     * this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposCodespacesSecretsPublicKeyResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCodespacesSecretsPublicKeyResponse codespacesGetRepoPublicKey(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareCodespacesGetRepoPublicKeyRequest(owner, repo).execute();
    }

    /**
     * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
     * you can create or update secrets. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have write access to the `codespaces_secrets` repository permission to use
     * this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposCodespacesSecretsPublicKeyResponse response from the API call
     */
    public CompletableFuture<ReposCodespacesSecretsPublicKeyResponse> codespacesGetRepoPublicKeyAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareCodespacesGetRepoPublicKeyRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesGetRepoPublicKey.
     */
    private ApiCall<ReposCodespacesSecretsPublicKeyResponse, ApiException> prepareCodespacesGetRepoPublicKeyRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposCodespacesSecretsPublicKeyResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/codespaces/secrets/public-key")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCodespacesSecretsPublicKeyResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a single repository secret without revealing its encrypted value. You must authenticate
     * using an access token with the `repo` scope to use this endpoint. GitHub Apps must have write
     * access to the `codespaces_secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the ReposCodespacesSecretsSecretNameResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCodespacesSecretsSecretNameResponse codespacesGetRepoSecret(
            final String owner,
            final String repo,
            final String secretName) throws ApiException, IOException {
        return prepareCodespacesGetRepoSecretRequest(owner, repo, secretName).execute();
    }

    /**
     * Gets a single repository secret without revealing its encrypted value. You must authenticate
     * using an access token with the `repo` scope to use this endpoint. GitHub Apps must have write
     * access to the `codespaces_secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the ReposCodespacesSecretsSecretNameResponse response from the API call
     */
    public CompletableFuture<ReposCodespacesSecretsSecretNameResponse> codespacesGetRepoSecretAsync(
            final String owner,
            final String repo,
            final String secretName) {
        try { 
            return prepareCodespacesGetRepoSecretRequest(owner, repo, secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesGetRepoSecret.
     */
    private ApiCall<ReposCodespacesSecretsSecretNameResponse, ApiException> prepareCodespacesGetRepoSecretRequest(
            final String owner,
            final String repo,
            final String secretName) throws IOException {
        return new ApiCall.Builder<ReposCodespacesSecretsSecretNameResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/codespaces/secrets/{secret_name}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCodespacesSecretsSecretNameResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates or updates a repository secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have write access to the `codespaces_secrets` repository permission to use this
     * endpoint. #### Example of encrypting a secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example of encrypting a secret using Python Encrypt your
     * secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox)
     * with Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example of encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example of encrypting
     * a secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object codespacesCreateOrUpdateRepoSecret(
            final String owner,
            final String repo,
            final String secretName,
            final ReposCodespacesSecretsSecretNameRequest body) throws ApiException, IOException {
        return prepareCodespacesCreateOrUpdateRepoSecretRequest(owner, repo, secretName,
                body).execute();
    }

    /**
     * Creates or updates a repository secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have write access to the `codespaces_secrets` repository permission to use this
     * endpoint. #### Example of encrypting a secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example of encrypting a secret using Python Encrypt your
     * secret using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox)
     * with Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example of encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example of encrypting
     * a secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> codespacesCreateOrUpdateRepoSecretAsync(
            final String owner,
            final String repo,
            final String secretName,
            final ReposCodespacesSecretsSecretNameRequest body) {
        try { 
            return prepareCodespacesCreateOrUpdateRepoSecretRequest(owner, repo, secretName,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesCreateOrUpdateRepoSecret.
     */
    private ApiCall<Object, ApiException> prepareCodespacesCreateOrUpdateRepoSecretRequest(
            final String owner,
            final String repo,
            final String secretName,
            final ReposCodespacesSecretsSecretNameRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/codespaces/secrets/{secret_name}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a secret in a repository using the secret name. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have write access to the
     * `codespaces_secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void codespacesDeleteRepoSecret(
            final String owner,
            final String repo,
            final String secretName) throws ApiException, IOException {
        prepareCodespacesDeleteRepoSecretRequest(owner, repo, secretName).execute();
    }

    /**
     * Deletes a secret in a repository using the secret name. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have write access to the
     * `codespaces_secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> codespacesDeleteRepoSecretAsync(
            final String owner,
            final String repo,
            final String secretName) {
        try { 
            return prepareCodespacesDeleteRepoSecretRequest(owner, repo, secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesDeleteRepoSecret.
     */
    private ApiCall<Void, ApiException> prepareCodespacesDeleteRepoSecretRequest(
            final String owner,
            final String repo,
            final String secretName) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/codespaces/secrets/{secret_name}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates a codespace owned by the authenticated user for the specified pull request. You must
     * authenticate using an access token with the `codespace` scope to use this endpoint. GitHub
     * Apps must have write access to the `codespaces` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  pullNumber  Required parameter: The number that identifies the pull request.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposPullsPullNumberCodespacesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposPullsPullNumberCodespacesResponse codespacesCreateWithPrForAuthenticatedUser(
            final String owner,
            final String repo,
            final int pullNumber,
            final Object body) throws ApiException, IOException {
        return prepareCodespacesCreateWithPrForAuthenticatedUserRequest(owner, repo, pullNumber,
                body).execute();
    }

    /**
     * Creates a codespace owned by the authenticated user for the specified pull request. You must
     * authenticate using an access token with the `codespace` scope to use this endpoint. GitHub
     * Apps must have write access to the `codespaces` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  pullNumber  Required parameter: The number that identifies the pull request.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposPullsPullNumberCodespacesResponse response from the API call
     */
    public CompletableFuture<ReposPullsPullNumberCodespacesResponse> codespacesCreateWithPrForAuthenticatedUserAsync(
            final String owner,
            final String repo,
            final int pullNumber,
            final Object body) {
        try { 
            return prepareCodespacesCreateWithPrForAuthenticatedUserRequest(owner, repo, pullNumber,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesCreateWithPrForAuthenticatedUser.
     */
    private ApiCall<ReposPullsPullNumberCodespacesResponse, ApiException> prepareCodespacesCreateWithPrForAuthenticatedUserRequest(
            final String owner,
            final String repo,
            final int pullNumber,
            final Object body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposPullsPullNumberCodespacesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/pulls/{pull_number}/codespaces")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("pull_number").value(pullNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposPullsPullNumberCodespacesResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new ReposPullsPullNumberCodespaces401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposPullsPullNumberCodespaces403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposPullsPullNumberCodespaces404ErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.create("Service unavailable",
                                (reason, context) -> new ServiceUnavailable1Exception(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the authenticated user's codespaces. You must authenticate using an access token with
     * the `codespace` scope to use this endpoint. GitHub Apps must have read access to the
     * `codespaces` repository permission to use this endpoint.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  repositoryId  Optional parameter: ID of the Repository to filter on
     * @return    Returns the UserCodespacesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserCodespacesResponse codespacesListForAuthenticatedUser(
            final Integer perPage,
            final Integer page,
            final Integer repositoryId) throws ApiException, IOException {
        return prepareCodespacesListForAuthenticatedUserRequest(perPage, page,
                repositoryId).execute();
    }

    /**
     * Lists the authenticated user's codespaces. You must authenticate using an access token with
     * the `codespace` scope to use this endpoint. GitHub Apps must have read access to the
     * `codespaces` repository permission to use this endpoint.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  repositoryId  Optional parameter: ID of the Repository to filter on
     * @return    Returns the UserCodespacesResponse response from the API call
     */
    public CompletableFuture<UserCodespacesResponse> codespacesListForAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page,
            final Integer repositoryId) {
        try { 
            return prepareCodespacesListForAuthenticatedUserRequest(perPage, page,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesListForAuthenticatedUser.
     */
    private ApiCall<UserCodespacesResponse, ApiException> prepareCodespacesListForAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page,
            final Integer repositoryId) throws IOException {
        return new ApiCall.Builder<UserCodespacesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("repository_id")
                                .value(repositoryId).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserCodespacesResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserCodespaces401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserCodespaces403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespaces404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new UserCodespaces500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates a new codespace, owned by the authenticated user. This endpoint requires either a
     * `repository_id` OR a `pull_request` but not both. You must authenticate using an access token
     * with the `codespace` scope to use this endpoint. GitHub Apps must have write access to the
     * `codespaces` repository permission to use this endpoint.
     * @param  body  Required parameter: Example:
     * @return    Returns the UserCodespacesResponse1 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserCodespacesResponse1 codespacesCreateForAuthenticatedUser(
            final CodespacesCreateForAuthenticatedUserBody body) throws ApiException, IOException {
        return prepareCodespacesCreateForAuthenticatedUserRequest(body).execute();
    }

    /**
     * Creates a new codespace, owned by the authenticated user. This endpoint requires either a
     * `repository_id` OR a `pull_request` but not both. You must authenticate using an access token
     * with the `codespace` scope to use this endpoint. GitHub Apps must have write access to the
     * `codespaces` repository permission to use this endpoint.
     * @param  body  Required parameter: Example:
     * @return    Returns the UserCodespacesResponse1 response from the API call
     */
    public CompletableFuture<UserCodespacesResponse1> codespacesCreateForAuthenticatedUserAsync(
            final CodespacesCreateForAuthenticatedUserBody body) {
        try { 
            return prepareCodespacesCreateForAuthenticatedUserRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesCreateForAuthenticatedUser.
     */
    private ApiCall<UserCodespacesResponse1, ApiException> prepareCodespacesCreateForAuthenticatedUserRequest(
            final CodespacesCreateForAuthenticatedUserBody body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<UserCodespacesResponse1, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serializeTypeCombinator(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserCodespacesResponse1.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserCodespaces401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserCodespaces403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespaces404ErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.create("Service unavailable",
                                (reason, context) -> new ServiceUnavailable1Exception(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all secrets available for a user's Codespaces without revealing their encrypted values.
     * You must authenticate using an access token with the `codespace` or `codespace:secrets` scope
     * to use this endpoint. User must have Codespaces access to use this endpoint. GitHub Apps must
     * have read access to the `codespaces_user_secrets` user permission to use this endpoint.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the UserCodespacesSecretsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserCodespacesSecretsResponse codespacesListSecretsForAuthenticatedUser(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareCodespacesListSecretsForAuthenticatedUserRequest(perPage, page).execute();
    }

    /**
     * Lists all secrets available for a user's Codespaces without revealing their encrypted values.
     * You must authenticate using an access token with the `codespace` or `codespace:secrets` scope
     * to use this endpoint. User must have Codespaces access to use this endpoint. GitHub Apps must
     * have read access to the `codespaces_user_secrets` user permission to use this endpoint.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the UserCodespacesSecretsResponse response from the API call
     */
    public CompletableFuture<UserCodespacesSecretsResponse> codespacesListSecretsForAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareCodespacesListSecretsForAuthenticatedUserRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesListSecretsForAuthenticatedUser.
     */
    private ApiCall<UserCodespacesSecretsResponse, ApiException> prepareCodespacesListSecretsForAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<UserCodespacesSecretsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/secrets")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserCodespacesSecretsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
     * you can create or update secrets. You must authenticate using an access token with the
     * `codespace` or `codespace:secrets` scope to use this endpoint. User must have Codespaces
     * access to use this endpoint. GitHub Apps must have read access to the
     * `codespaces_user_secrets` user permission to use this endpoint.
     * @return    Returns the UserCodespacesSecretsPublicKeyResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserCodespacesSecretsPublicKeyResponse codespacesGetPublicKeyForAuthenticatedUser() throws ApiException, IOException {
        return prepareCodespacesGetPublicKeyForAuthenticatedUserRequest().execute();
    }

    /**
     * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
     * you can create or update secrets. You must authenticate using an access token with the
     * `codespace` or `codespace:secrets` scope to use this endpoint. User must have Codespaces
     * access to use this endpoint. GitHub Apps must have read access to the
     * `codespaces_user_secrets` user permission to use this endpoint.
     * @return    Returns the UserCodespacesSecretsPublicKeyResponse response from the API call
     */
    public CompletableFuture<UserCodespacesSecretsPublicKeyResponse> codespacesGetPublicKeyForAuthenticatedUserAsync() {
        try { 
            return prepareCodespacesGetPublicKeyForAuthenticatedUserRequest().executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesGetPublicKeyForAuthenticatedUser.
     */
    private ApiCall<UserCodespacesSecretsPublicKeyResponse, ApiException> prepareCodespacesGetPublicKeyForAuthenticatedUserRequest() throws IOException {
        return new ApiCall.Builder<UserCodespacesSecretsPublicKeyResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/secrets/public-key")
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserCodespacesSecretsPublicKeyResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a secret available to a user's codespaces without revealing its encrypted value. You
     * must authenticate using an access token with the `codespace` or `codespace:secrets` scope to
     * use this endpoint. User must have Codespaces access to use this endpoint. GitHub Apps must
     * have read access to the `codespaces_user_secrets` user permission to use this endpoint.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the UserCodespacesSecretsResponse1 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserCodespacesSecretsResponse1 codespacesGetSecretForAuthenticatedUser(
            final String secretName) throws ApiException, IOException {
        return prepareCodespacesGetSecretForAuthenticatedUserRequest(secretName).execute();
    }

    /**
     * Gets a secret available to a user's codespaces without revealing its encrypted value. You
     * must authenticate using an access token with the `codespace` or `codespace:secrets` scope to
     * use this endpoint. User must have Codespaces access to use this endpoint. GitHub Apps must
     * have read access to the `codespaces_user_secrets` user permission to use this endpoint.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the UserCodespacesSecretsResponse1 response from the API call
     */
    public CompletableFuture<UserCodespacesSecretsResponse1> codespacesGetSecretForAuthenticatedUserAsync(
            final String secretName) {
        try { 
            return prepareCodespacesGetSecretForAuthenticatedUserRequest(secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesGetSecretForAuthenticatedUser.
     */
    private ApiCall<UserCodespacesSecretsResponse1, ApiException> prepareCodespacesGetSecretForAuthenticatedUserRequest(
            final String secretName) throws IOException {
        return new ApiCall.Builder<UserCodespacesSecretsResponse1, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/secrets/{secret_name}")
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserCodespacesSecretsResponse1.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates or updates a secret for a user's codespace with an encrypted value. Encrypt your
     * secret using [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You
     * must authenticate using an access token with the `codespace` or `codespace:secrets` scope to
     * use this endpoint. User must also have Codespaces access to use this endpoint. GitHub Apps
     * must have write access to the `codespaces_user_secrets` user permission and
     * `codespaces_secrets` repository permission on all referenced repositories to use this
     * endpoint. #### Example encrypting a secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example encrypting a secret using Python Encrypt your secret
     * using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with
     * Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example encrypting a
     * secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object codespacesCreateOrUpdateSecretForAuthenticatedUser(
            final String secretName,
            final UserCodespacesSecretsRequest body) throws ApiException, IOException {
        return prepareCodespacesCreateOrUpdateSecretForAuthenticatedUserRequest(secretName,
                body).execute();
    }

    /**
     * Creates or updates a secret for a user's codespace with an encrypted value. Encrypt your
     * secret using [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You
     * must authenticate using an access token with the `codespace` or `codespace:secrets` scope to
     * use this endpoint. User must also have Codespaces access to use this endpoint. GitHub Apps
     * must have write access to the `codespaces_user_secrets` user permission and
     * `codespaces_secrets` repository permission on all referenced repositories to use this
     * endpoint. #### Example encrypting a secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example encrypting a secret using Python Encrypt your secret
     * using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with
     * Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example encrypting a
     * secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> codespacesCreateOrUpdateSecretForAuthenticatedUserAsync(
            final String secretName,
            final UserCodespacesSecretsRequest body) {
        try { 
            return prepareCodespacesCreateOrUpdateSecretForAuthenticatedUserRequest(secretName,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesCreateOrUpdateSecretForAuthenticatedUser.
     */
    private ApiCall<Object, ApiException> prepareCodespacesCreateOrUpdateSecretForAuthenticatedUserRequest(
            final String secretName,
            final UserCodespacesSecretsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/secrets/{secret_name}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespacesSecrets404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UserCodespacesSecrets422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a secret from a user's codespaces using the secret name. Deleting the secret will
     * remove access from all codespaces that were allowed to access the secret. You must
     * authenticate using an access token with the `codespace` or `codespace:secrets` scope to use
     * this endpoint. User must have Codespaces access to use this endpoint. GitHub Apps must have
     * write access to the `codespaces_user_secrets` user permission to use this endpoint.
     * @param  secretName  Required parameter: The name of the secret.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void codespacesDeleteSecretForAuthenticatedUser(
            final String secretName) throws ApiException, IOException {
        prepareCodespacesDeleteSecretForAuthenticatedUserRequest(secretName).execute();
    }

    /**
     * Deletes a secret from a user's codespaces using the secret name. Deleting the secret will
     * remove access from all codespaces that were allowed to access the secret. You must
     * authenticate using an access token with the `codespace` or `codespace:secrets` scope to use
     * this endpoint. User must have Codespaces access to use this endpoint. GitHub Apps must have
     * write access to the `codespaces_user_secrets` user permission to use this endpoint.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> codespacesDeleteSecretForAuthenticatedUserAsync(
            final String secretName) {
        try { 
            return prepareCodespacesDeleteSecretForAuthenticatedUserRequest(secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesDeleteSecretForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareCodespacesDeleteSecretForAuthenticatedUserRequest(
            final String secretName) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/secrets/{secret_name}")
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List the repositories that have been granted the ability to use a user's codespace secret.
     * You must authenticate using an access token with the `codespace` or `codespace:secrets` scope
     * to use this endpoint. User must have Codespaces access to use this endpoint. GitHub Apps must
     * have read access to the `codespaces_user_secrets` user permission and write access to the
     * `codespaces_secrets` repository permission on all referenced repositories to use this
     * endpoint.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the OrgsActionsSecretsRepositoriesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsSecretsRepositoriesResponse codespacesListRepositoriesForSecretForAuthenticatedUser(
            final String secretName) throws ApiException, IOException {
        return prepareCodespacesListRepositoriesForSecretForAuthenticatedUserRequest(
                secretName).execute();
    }

    /**
     * List the repositories that have been granted the ability to use a user's codespace secret.
     * You must authenticate using an access token with the `codespace` or `codespace:secrets` scope
     * to use this endpoint. User must have Codespaces access to use this endpoint. GitHub Apps must
     * have read access to the `codespaces_user_secrets` user permission and write access to the
     * `codespaces_secrets` repository permission on all referenced repositories to use this
     * endpoint.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the OrgsActionsSecretsRepositoriesResponse response from the API call
     */
    public CompletableFuture<OrgsActionsSecretsRepositoriesResponse> codespacesListRepositoriesForSecretForAuthenticatedUserAsync(
            final String secretName) {
        try { 
            return prepareCodespacesListRepositoriesForSecretForAuthenticatedUserRequest(
            secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesListRepositoriesForSecretForAuthenticatedUser.
     */
    private ApiCall<OrgsActionsSecretsRepositoriesResponse, ApiException> prepareCodespacesListRepositoriesForSecretForAuthenticatedUserRequest(
            final String secretName) throws IOException {
        return new ApiCall.Builder<OrgsActionsSecretsRepositoriesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/secrets/{secret_name}/repositories")
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsSecretsRepositoriesResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserCodespacesSecretsRepositories401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserCodespacesSecretsRepositories403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespacesSecretsRepositories404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new UserCodespacesSecretsRepositories500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Select the repositories that will use a user's codespace secret. You must authenticate using
     * an access token with the `codespace` or `codespace:secrets` scope to use this endpoint. User
     * must have Codespaces access to use this endpoint. GitHub Apps must have write access to the
     * `codespaces_user_secrets` user permission and write access to the `codespaces_secrets`
     * repository permission on all referenced repositories to use this endpoint.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void codespacesSetRepositoriesForSecretForAuthenticatedUser(
            final String secretName,
            final UserCodespacesSecretsRepositoriesRequest body) throws ApiException, IOException {
        prepareCodespacesSetRepositoriesForSecretForAuthenticatedUserRequest(secretName,
                body).execute();
    }

    /**
     * Select the repositories that will use a user's codespace secret. You must authenticate using
     * an access token with the `codespace` or `codespace:secrets` scope to use this endpoint. User
     * must have Codespaces access to use this endpoint. GitHub Apps must have write access to the
     * `codespaces_user_secrets` user permission and write access to the `codespaces_secrets`
     * repository permission on all referenced repositories to use this endpoint.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> codespacesSetRepositoriesForSecretForAuthenticatedUserAsync(
            final String secretName,
            final UserCodespacesSecretsRepositoriesRequest body) {
        try { 
            return prepareCodespacesSetRepositoriesForSecretForAuthenticatedUserRequest(secretName,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesSetRepositoriesForSecretForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareCodespacesSetRepositoriesForSecretForAuthenticatedUserRequest(
            final String secretName,
            final UserCodespacesSecretsRepositoriesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/secrets/{secret_name}/repositories")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserCodespacesSecretsRepositories401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserCodespacesSecretsRepositories403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespacesSecretsRepositories404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new UserCodespacesSecretsRepositories500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Adds a repository to the selected repositories for a user's codespace secret. You must
     * authenticate using an access token with the `codespace` or `codespace:secrets` scope to use
     * this endpoint. User must have Codespaces access to use this endpoint. GitHub Apps must have
     * write access to the `codespaces_user_secrets` user permission and write access to the
     * `codespaces_secrets` repository permission on the referenced repository to use this endpoint.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void codespacesAddRepositoryForSecretForAuthenticatedUser(
            final String secretName,
            final int repositoryId) throws ApiException, IOException {
        prepareCodespacesAddRepositoryForSecretForAuthenticatedUserRequest(secretName,
                repositoryId).execute();
    }

    /**
     * Adds a repository to the selected repositories for a user's codespace secret. You must
     * authenticate using an access token with the `codespace` or `codespace:secrets` scope to use
     * this endpoint. User must have Codespaces access to use this endpoint. GitHub Apps must have
     * write access to the `codespaces_user_secrets` user permission and write access to the
     * `codespaces_secrets` repository permission on the referenced repository to use this endpoint.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> codespacesAddRepositoryForSecretForAuthenticatedUserAsync(
            final String secretName,
            final int repositoryId) {
        try { 
            return prepareCodespacesAddRepositoryForSecretForAuthenticatedUserRequest(secretName,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesAddRepositoryForSecretForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareCodespacesAddRepositoryForSecretForAuthenticatedUserRequest(
            final String secretName,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/secrets/{secret_name}/repositories/{repository_id}")
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserCodespacesSecretsRepositories401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserCodespacesSecretsRepositories403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespacesSecretsRepositories404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new UserCodespacesSecretsRepositories500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes a repository from the selected repositories for a user's codespace secret. You must
     * authenticate using an access token with the `codespace` or `codespace:secrets` scope to use
     * this endpoint. User must have Codespaces access to use this endpoint. GitHub Apps must have
     * write access to the `codespaces_user_secrets` user permission to use this endpoint.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void codespacesRemoveRepositoryForSecretForAuthenticatedUser(
            final String secretName,
            final int repositoryId) throws ApiException, IOException {
        prepareCodespacesRemoveRepositoryForSecretForAuthenticatedUserRequest(secretName,
                repositoryId).execute();
    }

    /**
     * Removes a repository from the selected repositories for a user's codespace secret. You must
     * authenticate using an access token with the `codespace` or `codespace:secrets` scope to use
     * this endpoint. User must have Codespaces access to use this endpoint. GitHub Apps must have
     * write access to the `codespaces_user_secrets` user permission to use this endpoint.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> codespacesRemoveRepositoryForSecretForAuthenticatedUserAsync(
            final String secretName,
            final int repositoryId) {
        try { 
            return prepareCodespacesRemoveRepositoryForSecretForAuthenticatedUserRequest(secretName,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesRemoveRepositoryForSecretForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareCodespacesRemoveRepositoryForSecretForAuthenticatedUserRequest(
            final String secretName,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/secrets/{secret_name}/repositories/{repository_id}")
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserCodespacesSecretsRepositories401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserCodespacesSecretsRepositories403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespacesSecretsRepositories404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new UserCodespacesSecretsRepositories500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets information about a user's codespace. You must authenticate using an access token with
     * the `codespace` scope to use this endpoint. GitHub Apps must have read access to the
     * `codespaces` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the UserCodespacesResponse1 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserCodespacesResponse1 codespacesGetForAuthenticatedUser(
            final String codespaceName) throws ApiException, IOException {
        return prepareCodespacesGetForAuthenticatedUserRequest(codespaceName).execute();
    }

    /**
     * Gets information about a user's codespace. You must authenticate using an access token with
     * the `codespace` scope to use this endpoint. GitHub Apps must have read access to the
     * `codespaces` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the UserCodespacesResponse1 response from the API call
     */
    public CompletableFuture<UserCodespacesResponse1> codespacesGetForAuthenticatedUserAsync(
            final String codespaceName) {
        try { 
            return prepareCodespacesGetForAuthenticatedUserRequest(codespaceName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesGetForAuthenticatedUser.
     */
    private ApiCall<UserCodespacesResponse1, ApiException> prepareCodespacesGetForAuthenticatedUserRequest(
            final String codespaceName) throws IOException {
        return new ApiCall.Builder<UserCodespacesResponse1, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/{codespace_name}")
                        .templateParam(param -> param.key("codespace_name").value(codespaceName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserCodespacesResponse1.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserCodespaces401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserCodespaces403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespaces404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new UserCodespaces500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates a codespace owned by the authenticated user. Currently only the codespace's machine
     * type and recent folders can be modified using this endpoint. If you specify a new machine
     * type it will be applied the next time your codespace is started. You must authenticate using
     * an access token with the `codespace` scope to use this endpoint. GitHub Apps must have write
     * access to the `codespaces` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @param  body  Optional parameter: Example:
     * @return    Returns the UserCodespacesResponse1 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserCodespacesResponse1 codespacesUpdateForAuthenticatedUser(
            final String codespaceName,
            final UserCodespacesRequest2 body) throws ApiException, IOException {
        return prepareCodespacesUpdateForAuthenticatedUserRequest(codespaceName, body).execute();
    }

    /**
     * Updates a codespace owned by the authenticated user. Currently only the codespace's machine
     * type and recent folders can be modified using this endpoint. If you specify a new machine
     * type it will be applied the next time your codespace is started. You must authenticate using
     * an access token with the `codespace` scope to use this endpoint. GitHub Apps must have write
     * access to the `codespaces` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @param  body  Optional parameter: Example:
     * @return    Returns the UserCodespacesResponse1 response from the API call
     */
    public CompletableFuture<UserCodespacesResponse1> codespacesUpdateForAuthenticatedUserAsync(
            final String codespaceName,
            final UserCodespacesRequest2 body) {
        try { 
            return prepareCodespacesUpdateForAuthenticatedUserRequest(codespaceName, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesUpdateForAuthenticatedUser.
     */
    private ApiCall<UserCodespacesResponse1, ApiException> prepareCodespacesUpdateForAuthenticatedUserRequest(
            final String codespaceName,
            final UserCodespacesRequest2 body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<UserCodespacesResponse1, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/{codespace_name}")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("codespace_name").value(codespaceName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserCodespacesResponse1.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserCodespaces401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserCodespaces403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespaces404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a user's codespace. You must authenticate using an access token with the `codespace`
     * scope to use this endpoint. GitHub Apps must have write access to the `codespaces` repository
     * permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object codespacesDeleteForAuthenticatedUser(
            final String codespaceName) throws ApiException, IOException {
        return prepareCodespacesDeleteForAuthenticatedUserRequest(codespaceName).execute();
    }

    /**
     * Deletes a user's codespace. You must authenticate using an access token with the `codespace`
     * scope to use this endpoint. GitHub Apps must have write access to the `codespaces` repository
     * permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> codespacesDeleteForAuthenticatedUserAsync(
            final String codespaceName) {
        try { 
            return prepareCodespacesDeleteForAuthenticatedUserRequest(codespaceName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesDeleteForAuthenticatedUser.
     */
    private ApiCall<Object, ApiException> prepareCodespacesDeleteForAuthenticatedUserRequest(
            final String codespaceName) throws IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/{codespace_name}")
                        .templateParam(param -> param.key("codespace_name").value(codespaceName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserCodespaces401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserCodespaces403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespaces404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new UserCodespaces500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Triggers an export of the specified codespace and returns a URL and ID where the status of
     * the export can be monitored. If changes cannot be pushed to the codespace's repository, they
     * will be pushed to a new or previously-existing fork instead. You must authenticate using a
     * personal access token with the `codespace` scope to use this endpoint. GitHub Apps must have
     * write access to the `codespaces_lifecycle_admin` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the UserCodespacesExportsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserCodespacesExportsResponse codespacesExportForAuthenticatedUser(
            final String codespaceName) throws ApiException, IOException {
        return prepareCodespacesExportForAuthenticatedUserRequest(codespaceName).execute();
    }

    /**
     * Triggers an export of the specified codespace and returns a URL and ID where the status of
     * the export can be monitored. If changes cannot be pushed to the codespace's repository, they
     * will be pushed to a new or previously-existing fork instead. You must authenticate using a
     * personal access token with the `codespace` scope to use this endpoint. GitHub Apps must have
     * write access to the `codespaces_lifecycle_admin` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the UserCodespacesExportsResponse response from the API call
     */
    public CompletableFuture<UserCodespacesExportsResponse> codespacesExportForAuthenticatedUserAsync(
            final String codespaceName) {
        try { 
            return prepareCodespacesExportForAuthenticatedUserRequest(codespaceName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesExportForAuthenticatedUser.
     */
    private ApiCall<UserCodespacesExportsResponse, ApiException> prepareCodespacesExportForAuthenticatedUserRequest(
            final String codespaceName) throws IOException {
        return new ApiCall.Builder<UserCodespacesExportsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/{codespace_name}/exports")
                        .templateParam(param -> param.key("codespace_name").value(codespaceName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserCodespacesExportsResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserCodespacesExports401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserCodespacesExports403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespacesExports404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UserCodespacesExports422ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new UserCodespacesExports500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets information about an export of a codespace. You must authenticate using a personal
     * access token with the `codespace` scope to use this endpoint. GitHub Apps must have read
     * access to the `codespaces_lifecycle_admin` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @param  exportId  Required parameter: The ID of the export operation, or `latest`. Currently
     *         only `latest` is currently supported.
     * @return    Returns the UserCodespacesExportsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserCodespacesExportsResponse codespacesGetExportDetailsForAuthenticatedUser(
            final String codespaceName,
            final String exportId) throws ApiException, IOException {
        return prepareCodespacesGetExportDetailsForAuthenticatedUserRequest(codespaceName,
                exportId).execute();
    }

    /**
     * Gets information about an export of a codespace. You must authenticate using a personal
     * access token with the `codespace` scope to use this endpoint. GitHub Apps must have read
     * access to the `codespaces_lifecycle_admin` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @param  exportId  Required parameter: The ID of the export operation, or `latest`. Currently
     *         only `latest` is currently supported.
     * @return    Returns the UserCodespacesExportsResponse response from the API call
     */
    public CompletableFuture<UserCodespacesExportsResponse> codespacesGetExportDetailsForAuthenticatedUserAsync(
            final String codespaceName,
            final String exportId) {
        try { 
            return prepareCodespacesGetExportDetailsForAuthenticatedUserRequest(codespaceName,
            exportId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesGetExportDetailsForAuthenticatedUser.
     */
    private ApiCall<UserCodespacesExportsResponse, ApiException> prepareCodespacesGetExportDetailsForAuthenticatedUserRequest(
            final String codespaceName,
            final String exportId) throws IOException {
        return new ApiCall.Builder<UserCodespacesExportsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/{codespace_name}/exports/{export_id}")
                        .templateParam(param -> param.key("codespace_name").value(codespaceName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("export_id").value(exportId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserCodespacesExportsResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespacesExports404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List the machine types a codespace can transition to use. You must authenticate using an
     * access token with the `codespace` scope to use this endpoint. GitHub Apps must have read
     * access to the `codespaces_metadata` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the UserCodespacesMachinesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserCodespacesMachinesResponse codespacesCodespaceMachinesForAuthenticatedUser(
            final String codespaceName) throws ApiException, IOException {
        return prepareCodespacesCodespaceMachinesForAuthenticatedUserRequest(
                codespaceName).execute();
    }

    /**
     * List the machine types a codespace can transition to use. You must authenticate using an
     * access token with the `codespace` scope to use this endpoint. GitHub Apps must have read
     * access to the `codespaces_metadata` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the UserCodespacesMachinesResponse response from the API call
     */
    public CompletableFuture<UserCodespacesMachinesResponse> codespacesCodespaceMachinesForAuthenticatedUserAsync(
            final String codespaceName) {
        try { 
            return prepareCodespacesCodespaceMachinesForAuthenticatedUserRequest(
            codespaceName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesCodespaceMachinesForAuthenticatedUser.
     */
    private ApiCall<UserCodespacesMachinesResponse, ApiException> prepareCodespacesCodespaceMachinesForAuthenticatedUserRequest(
            final String codespaceName) throws IOException {
        return new ApiCall.Builder<UserCodespacesMachinesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/{codespace_name}/machines")
                        .templateParam(param -> param.key("codespace_name").value(codespaceName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserCodespacesMachinesResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserCodespacesMachines401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserCodespacesMachines403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespacesMachines404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new UserCodespacesMachines500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Publishes an unpublished codespace, creating a new repository and assigning it to the
     * codespace. The codespace's token is granted write permissions to the repository, allowing the
     * user to push their changes. This will fail for a codespace that is already published, meaning
     * it has an associated repository. You must authenticate using a personal access token with the
     * `codespace` scope to use this endpoint. GitHub Apps must have write access to the
     * `codespaces` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @param  body  Required parameter: Example:
     * @return    Returns the UserCodespacesPublishResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserCodespacesPublishResponse codespacesPublishForAuthenticatedUser(
            final String codespaceName,
            final UserCodespacesPublishRequest body) throws ApiException, IOException {
        return prepareCodespacesPublishForAuthenticatedUserRequest(codespaceName, body).execute();
    }

    /**
     * Publishes an unpublished codespace, creating a new repository and assigning it to the
     * codespace. The codespace's token is granted write permissions to the repository, allowing the
     * user to push their changes. This will fail for a codespace that is already published, meaning
     * it has an associated repository. You must authenticate using a personal access token with the
     * `codespace` scope to use this endpoint. GitHub Apps must have write access to the
     * `codespaces` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @param  body  Required parameter: Example:
     * @return    Returns the UserCodespacesPublishResponse response from the API call
     */
    public CompletableFuture<UserCodespacesPublishResponse> codespacesPublishForAuthenticatedUserAsync(
            final String codespaceName,
            final UserCodespacesPublishRequest body) {
        try { 
            return prepareCodespacesPublishForAuthenticatedUserRequest(codespaceName, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesPublishForAuthenticatedUser.
     */
    private ApiCall<UserCodespacesPublishResponse, ApiException> prepareCodespacesPublishForAuthenticatedUserRequest(
            final String codespaceName,
            final UserCodespacesPublishRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<UserCodespacesPublishResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/{codespace_name}/publish")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("codespace_name").value(codespaceName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserCodespacesPublishResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserCodespacesPublish401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserCodespacesPublish403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespacesPublish404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UserCodespacesPublish422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Starts a user's codespace. You must authenticate using an access token with the `codespace`
     * scope to use this endpoint. GitHub Apps must have write access to the
     * `codespaces_lifecycle_admin` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the UserCodespacesStartResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserCodespacesStartResponse codespacesStartForAuthenticatedUser(
            final String codespaceName) throws ApiException, IOException {
        return prepareCodespacesStartForAuthenticatedUserRequest(codespaceName).execute();
    }

    /**
     * Starts a user's codespace. You must authenticate using an access token with the `codespace`
     * scope to use this endpoint. GitHub Apps must have write access to the
     * `codespaces_lifecycle_admin` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the UserCodespacesStartResponse response from the API call
     */
    public CompletableFuture<UserCodespacesStartResponse> codespacesStartForAuthenticatedUserAsync(
            final String codespaceName) {
        try { 
            return prepareCodespacesStartForAuthenticatedUserRequest(codespaceName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesStartForAuthenticatedUser.
     */
    private ApiCall<UserCodespacesStartResponse, ApiException> prepareCodespacesStartForAuthenticatedUserRequest(
            final String codespaceName) throws IOException {
        return new ApiCall.Builder<UserCodespacesStartResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/{codespace_name}/start")
                        .templateParam(param -> param.key("codespace_name").value(codespaceName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserCodespacesStartResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new UserCodespacesStart400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserCodespacesStart401ErrorException(reason, context)))
                        .localErrorCase("402",
                                 ErrorCase.create("Payment required",
                                (reason, context) -> new UserCodespacesStart402ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserCodespacesStart403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespacesStart404ErrorException(reason, context)))
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict",
                                (reason, context) -> new UserCodespacesStart409ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new UserCodespacesStart500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Stops a user's codespace. You must authenticate using an access token with the `codespace`
     * scope to use this endpoint. GitHub Apps must have write access to the
     * `codespaces_lifecycle_admin` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the UserCodespacesStopResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserCodespacesStopResponse codespacesStopForAuthenticatedUser(
            final String codespaceName) throws ApiException, IOException {
        return prepareCodespacesStopForAuthenticatedUserRequest(codespaceName).execute();
    }

    /**
     * Stops a user's codespace. You must authenticate using an access token with the `codespace`
     * scope to use this endpoint. GitHub Apps must have write access to the
     * `codespaces_lifecycle_admin` repository permission to use this endpoint.
     * @param  codespaceName  Required parameter: The name of the codespace.
     * @return    Returns the UserCodespacesStopResponse response from the API call
     */
    public CompletableFuture<UserCodespacesStopResponse> codespacesStopForAuthenticatedUserAsync(
            final String codespaceName) {
        try { 
            return prepareCodespacesStopForAuthenticatedUserRequest(codespaceName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for codespacesStopForAuthenticatedUser.
     */
    private ApiCall<UserCodespacesStopResponse, ApiException> prepareCodespacesStopForAuthenticatedUserRequest(
            final String codespaceName) throws IOException {
        return new ApiCall.Builder<UserCodespacesStopResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/codespaces/{codespace_name}/stop")
                        .templateParam(param -> param.key("codespace_name").value(codespaceName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserCodespacesStopResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserCodespacesStop401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserCodespacesStop403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserCodespacesStop404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new UserCodespacesStop500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}