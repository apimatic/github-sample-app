/*
 * GitHubAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.github.api.controllers;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.github.api.ApiHelper;
import com.github.api.DateTimeHelper;
import com.github.api.Server;
import com.github.api.exceptions.ApiException;
import com.github.api.exceptions.Issues404ErrorException;
import com.github.api.exceptions.Issues422ErrorException;
import com.github.api.exceptions.OrgsIssues404ErrorException;
import com.github.api.exceptions.ReposAssignees404ErrorException;
import com.github.api.exceptions.ReposAssigneesAssignee404ErrorException;
import com.github.api.exceptions.ReposIssues403ErrorException;
import com.github.api.exceptions.ReposIssues404ErrorException;
import com.github.api.exceptions.ReposIssues410ErrorException;
import com.github.api.exceptions.ReposIssues422ErrorException;
import com.github.api.exceptions.ReposIssuesComments404ErrorException;
import com.github.api.exceptions.ReposIssuesComments422ErrorException;
import com.github.api.exceptions.ReposIssuesCommentsCommentId404ErrorException;
import com.github.api.exceptions.ReposIssuesCommentsCommentId422ErrorException;
import com.github.api.exceptions.ReposIssuesEvents422ErrorException;
import com.github.api.exceptions.ReposIssuesEventsEventId403ErrorException;
import com.github.api.exceptions.ReposIssuesEventsEventId404ErrorException;
import com.github.api.exceptions.ReposIssuesEventsEventId410ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumber403ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumber404ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumber410ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumber422ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberAssigneesAssignee404ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberComments403ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberComments404ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberComments410ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberComments422ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberEvents410ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberLabels404ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberLabels410ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberLabels422ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberLabelsName404ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberLabelsName410ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberLock403ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberLock404ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberLock410ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberLock422ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberTimeline404ErrorException;
import com.github.api.exceptions.ReposIssuesIssueNumberTimeline410ErrorException;
import com.github.api.exceptions.ReposLabels404ErrorException;
import com.github.api.exceptions.ReposLabels422ErrorException;
import com.github.api.exceptions.ReposLabelsName404ErrorException;
import com.github.api.exceptions.ReposMilestones404ErrorException;
import com.github.api.exceptions.ReposMilestones422ErrorException;
import com.github.api.exceptions.ReposMilestonesMilestoneNumber404ErrorException;
import com.github.api.exceptions.ServiceUnavailable1Exception;
import com.github.api.exceptions.UserIssues404ErrorException;
import com.github.api.http.request.HttpMethod;
import com.github.api.models.ContentType3Enum;
import com.github.api.models.Direction15Enum;
import com.github.api.models.Direction16Enum;
import com.github.api.models.Direction1Enum;
import com.github.api.models.Filter1Enum;
import com.github.api.models.Issue;
import com.github.api.models.IssueComment;
import com.github.api.models.IssueEvent;
import com.github.api.models.IssueEventforIssue1;
import com.github.api.models.Label;
import com.github.api.models.Milestone;
import com.github.api.models.ReposIssuesCommentsCommentIdRequest;
import com.github.api.models.ReposIssuesCommentsCommentIdResponse;
import com.github.api.models.ReposIssuesEventsEventIdResponse;
import com.github.api.models.ReposIssuesIssueNumberAssigneesRequest;
import com.github.api.models.ReposIssuesIssueNumberAssigneesResponse;
import com.github.api.models.ReposIssuesIssueNumberCommentsResponse;
import com.github.api.models.ReposIssuesIssueNumberRequest;
import com.github.api.models.ReposIssuesIssueNumberResponse;
import com.github.api.models.ReposIssuesRequest;
import com.github.api.models.ReposIssuesResponse1;
import com.github.api.models.ReposLabelsNameRequest;
import com.github.api.models.ReposLabelsNameResponse;
import com.github.api.models.ReposLabelsRequest;
import com.github.api.models.ReposLabelsResponse;
import com.github.api.models.ReposMilestonesMilestoneNumberRequest;
import com.github.api.models.ReposMilestonesMilestoneNumberResponse;
import com.github.api.models.ReposMilestonesRequest;
import com.github.api.models.ReposMilestonesResponse;
import com.github.api.models.SimpleUser;
import com.github.api.models.Sort121Enum;
import com.github.api.models.Sort1Enum;
import com.github.api.models.Sort23Enum;
import com.github.api.models.State1671Enum;
import com.github.api.models.State1674Enum;
import com.github.api.models.TimelineEvent1;
import com.github.api.models.containers.IssuesAddLabelsBody;
import com.github.api.models.containers.IssuesSetLabelsBody;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;

/**
 * This class lists all the endpoints of the groups.
 */
public final class IssuesController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public IssuesController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * List issues assigned to the authenticated user across all visible repositories including
     * owned repositories, member repositories, and organization repositories. You can use the
     * `filter` query parameter to fetch issues that are not necessarily assigned to you. **Note**:
     * GitHub's REST API considers every pull request an issue, but not every issue is a pull
     * request. For this reason, "Issues" endpoints may return both issues and pull requests in the
     * response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of
     * a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull
     * requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
     * @param  filter  Optional parameter: Indicates which sorts of issues to return. `assigned`
     *         means issues assigned to you. `created` means issues created by you. `mentioned`
     *         means issues mentioning you. `subscribed` means issues you're subscribed to updates
     *         for. `all` or `repos` means all issues you can see, regardless of participation or
     *         creation.
     * @param  state  Optional parameter: Indicates the state of the issues to return.
     * @param  labels  Optional parameter: A list of comma separated label names. Example:
     *         `bug,ui,@high`
     * @param  sort  Optional parameter: What to sort results by.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  collab  Optional parameter: Example:
     * @param  orgs  Optional parameter: Example:
     * @param  owned  Optional parameter: Example:
     * @param  pulls  Optional parameter: Example:
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Issue response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Issue> issuesList(
            final Filter1Enum filter,
            final State1671Enum state,
            final String labels,
            final Sort23Enum sort,
            final Direction1Enum direction,
            final LocalDateTime since,
            final Boolean collab,
            final Boolean orgs,
            final Boolean owned,
            final Boolean pulls,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareIssuesListRequest(filter, state, labels, sort, direction, since, collab, orgs,
                owned, pulls, perPage, page).execute();
    }

    /**
     * List issues assigned to the authenticated user across all visible repositories including
     * owned repositories, member repositories, and organization repositories. You can use the
     * `filter` query parameter to fetch issues that are not necessarily assigned to you. **Note**:
     * GitHub's REST API considers every pull request an issue, but not every issue is a pull
     * request. For this reason, "Issues" endpoints may return both issues and pull requests in the
     * response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of
     * a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull
     * requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
     * @param  filter  Optional parameter: Indicates which sorts of issues to return. `assigned`
     *         means issues assigned to you. `created` means issues created by you. `mentioned`
     *         means issues mentioning you. `subscribed` means issues you're subscribed to updates
     *         for. `all` or `repos` means all issues you can see, regardless of participation or
     *         creation.
     * @param  state  Optional parameter: Indicates the state of the issues to return.
     * @param  labels  Optional parameter: A list of comma separated label names. Example:
     *         `bug,ui,@high`
     * @param  sort  Optional parameter: What to sort results by.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  collab  Optional parameter: Example:
     * @param  orgs  Optional parameter: Example:
     * @param  owned  Optional parameter: Example:
     * @param  pulls  Optional parameter: Example:
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Issue response from the API call
     */
    public CompletableFuture<List<Issue>> issuesListAsync(
            final Filter1Enum filter,
            final State1671Enum state,
            final String labels,
            final Sort23Enum sort,
            final Direction1Enum direction,
            final LocalDateTime since,
            final Boolean collab,
            final Boolean orgs,
            final Boolean owned,
            final Boolean pulls,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareIssuesListRequest(filter, state, labels, sort, direction, since, collab, orgs,
            owned, pulls, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesList.
     */
    private ApiCall<List<Issue>, ApiException> prepareIssuesListRequest(
            final Filter1Enum filter,
            final State1671Enum state,
            final String labels,
            final Sort23Enum sort,
            final Direction1Enum direction,
            final LocalDateTime since,
            final Boolean collab,
            final Boolean orgs,
            final Boolean owned,
            final Boolean pulls,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Issue>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/issues")
                        .queryParam(param -> param.key("filter")
                                .value((filter != null) ? filter.value() : null).isRequired(false))
                        .queryParam(param -> param.key("state")
                                .value((state != null) ? state.value() : null).isRequired(false))
                        .queryParam(param -> param.key("labels")
                                .value(labels).isRequired(false))
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("since")
                                .value(DateTimeHelper.toRfc8601DateTime(since)).isRequired(false))
                        .queryParam(param -> param.key("collab")
                                .value(collab).isRequired(false))
                        .queryParam(param -> param.key("orgs")
                                .value(orgs).isRequired(false))
                        .queryParam(param -> param.key("owned")
                                .value(owned).isRequired(false))
                        .queryParam(param -> param.key("pulls")
                                .value(pulls).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Issue[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new Issues404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new Issues422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List issues in an organization assigned to the authenticated user. **Note**: GitHub's REST
     * API considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can
     * identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request
     * returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use
     * the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)"
     * endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  filter  Optional parameter: Indicates which sorts of issues to return. `assigned`
     *         means issues assigned to you. `created` means issues created by you. `mentioned`
     *         means issues mentioning you. `subscribed` means issues you're subscribed to updates
     *         for. `all` or `repos` means all issues you can see, regardless of participation or
     *         creation.
     * @param  state  Optional parameter: Indicates the state of the issues to return.
     * @param  labels  Optional parameter: A list of comma separated label names. Example:
     *         `bug,ui,@high`
     * @param  sort  Optional parameter: What to sort results by.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Issue response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Issue> issuesListForOrg(
            final String org,
            final Filter1Enum filter,
            final State1671Enum state,
            final String labels,
            final Sort23Enum sort,
            final Direction1Enum direction,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareIssuesListForOrgRequest(org, filter, state, labels, sort, direction, since,
                perPage, page).execute();
    }

    /**
     * List issues in an organization assigned to the authenticated user. **Note**: GitHub's REST
     * API considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can
     * identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request
     * returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use
     * the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)"
     * endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  filter  Optional parameter: Indicates which sorts of issues to return. `assigned`
     *         means issues assigned to you. `created` means issues created by you. `mentioned`
     *         means issues mentioning you. `subscribed` means issues you're subscribed to updates
     *         for. `all` or `repos` means all issues you can see, regardless of participation or
     *         creation.
     * @param  state  Optional parameter: Indicates the state of the issues to return.
     * @param  labels  Optional parameter: A list of comma separated label names. Example:
     *         `bug,ui,@high`
     * @param  sort  Optional parameter: What to sort results by.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Issue response from the API call
     */
    public CompletableFuture<List<Issue>> issuesListForOrgAsync(
            final String org,
            final Filter1Enum filter,
            final State1671Enum state,
            final String labels,
            final Sort23Enum sort,
            final Direction1Enum direction,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareIssuesListForOrgRequest(org, filter, state, labels, sort, direction, since,
            perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesListForOrg.
     */
    private ApiCall<List<Issue>, ApiException> prepareIssuesListForOrgRequest(
            final String org,
            final Filter1Enum filter,
            final State1671Enum state,
            final String labels,
            final Sort23Enum sort,
            final Direction1Enum direction,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Issue>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/issues")
                        .queryParam(param -> param.key("filter")
                                .value((filter != null) ? filter.value() : null).isRequired(false))
                        .queryParam(param -> param.key("state")
                                .value((state != null) ? state.value() : null).isRequired(false))
                        .queryParam(param -> param.key("labels")
                                .value(labels).isRequired(false))
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("since")
                                .value(DateTimeHelper.toRfc8601DateTime(since)).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Issue[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsIssues404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the [available
     * assignees](https://docs.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/)
     * for issues in a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SimpleUser response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<SimpleUser> issuesListAssignees(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareIssuesListAssigneesRequest(owner, repo, perPage, page).execute();
    }

    /**
     * Lists the [available
     * assignees](https://docs.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/)
     * for issues in a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SimpleUser response from the API call
     */
    public CompletableFuture<List<SimpleUser>> issuesListAssigneesAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareIssuesListAssigneesRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesListAssignees.
     */
    private ApiCall<List<SimpleUser>, ApiException> prepareIssuesListAssigneesRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<SimpleUser>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/assignees")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        SimpleUser[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposAssignees404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Checks if a user has permission to be assigned to an issue in this repository. If the
     * `assignee` can be assigned to issues in the repository, a `204` header with no content is
     * returned. Otherwise a `404` status code is returned.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  assignee  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void issuesCheckUserCanBeAssigned(
            final String owner,
            final String repo,
            final String assignee) throws ApiException, IOException {
        prepareIssuesCheckUserCanBeAssignedRequest(owner, repo, assignee).execute();
    }

    /**
     * Checks if a user has permission to be assigned to an issue in this repository. If the
     * `assignee` can be assigned to issues in the repository, a `204` header with no content is
     * returned. Otherwise a `404` status code is returned.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  assignee  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> issuesCheckUserCanBeAssignedAsync(
            final String owner,
            final String repo,
            final String assignee) {
        try { 
            return prepareIssuesCheckUserCanBeAssignedRequest(owner, repo, assignee).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesCheckUserCanBeAssigned.
     */
    private ApiCall<Void, ApiException> prepareIssuesCheckUserCanBeAssignedRequest(
            final String owner,
            final String repo,
            final String assignee) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/assignees/{assignee}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("assignee").value(assignee)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Otherwise a `404` status code is returned.",
                                (reason, context) -> new ReposAssigneesAssignee404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List issues in a repository. Only open issues will be listed. **Note**: GitHub's REST API
     * considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can
     * identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request
     * returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use
     * the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)"
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  milestone  Optional parameter: If an `integer` is passed, it should refer to a
     *         milestone by its `number` field. If the string `*` is passed, issues with any
     *         milestone are accepted. If the string `none` is passed, issues without milestones are
     *         returned.
     * @param  state  Optional parameter: Indicates the state of the issues to return.
     * @param  assignee  Optional parameter: Can be the name of a user. Pass in `none` for issues
     *         with no assigned user, and `*` for issues assigned to any user.
     * @param  creator  Optional parameter: The user that created the issue.
     * @param  mentioned  Optional parameter: A user that's mentioned in the issue.
     * @param  labels  Optional parameter: A list of comma separated label names. Example:
     *         `bug,ui,@high`
     * @param  sort  Optional parameter: What to sort results by.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Issue response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Issue> issuesListForRepo(
            final String owner,
            final String repo,
            final String milestone,
            final State1671Enum state,
            final String assignee,
            final String creator,
            final String mentioned,
            final String labels,
            final Sort23Enum sort,
            final Direction1Enum direction,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareIssuesListForRepoRequest(owner, repo, milestone, state, assignee, creator,
                mentioned, labels, sort, direction, since, perPage, page).execute();
    }

    /**
     * List issues in a repository. Only open issues will be listed. **Note**: GitHub's REST API
     * considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can
     * identify pull requests by the `pull_request` key. Be aware that the `id` of a pull request
     * returned from "Issues" endpoints will be an _issue id_. To find out the pull request id, use
     * the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)"
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  milestone  Optional parameter: If an `integer` is passed, it should refer to a
     *         milestone by its `number` field. If the string `*` is passed, issues with any
     *         milestone are accepted. If the string `none` is passed, issues without milestones are
     *         returned.
     * @param  state  Optional parameter: Indicates the state of the issues to return.
     * @param  assignee  Optional parameter: Can be the name of a user. Pass in `none` for issues
     *         with no assigned user, and `*` for issues assigned to any user.
     * @param  creator  Optional parameter: The user that created the issue.
     * @param  mentioned  Optional parameter: A user that's mentioned in the issue.
     * @param  labels  Optional parameter: A list of comma separated label names. Example:
     *         `bug,ui,@high`
     * @param  sort  Optional parameter: What to sort results by.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Issue response from the API call
     */
    public CompletableFuture<List<Issue>> issuesListForRepoAsync(
            final String owner,
            final String repo,
            final String milestone,
            final State1671Enum state,
            final String assignee,
            final String creator,
            final String mentioned,
            final String labels,
            final Sort23Enum sort,
            final Direction1Enum direction,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareIssuesListForRepoRequest(owner, repo, milestone, state, assignee, creator,
            mentioned, labels, sort, direction, since, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesListForRepo.
     */
    private ApiCall<List<Issue>, ApiException> prepareIssuesListForRepoRequest(
            final String owner,
            final String repo,
            final String milestone,
            final State1671Enum state,
            final String assignee,
            final String creator,
            final String mentioned,
            final String labels,
            final Sort23Enum sort,
            final Direction1Enum direction,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Issue>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues")
                        .queryParam(param -> param.key("milestone")
                                .value(milestone).isRequired(false))
                        .queryParam(param -> param.key("state")
                                .value((state != null) ? state.value() : null).isRequired(false))
                        .queryParam(param -> param.key("assignee")
                                .value(assignee).isRequired(false))
                        .queryParam(param -> param.key("creator")
                                .value(creator).isRequired(false))
                        .queryParam(param -> param.key("mentioned")
                                .value(mentioned).isRequired(false))
                        .queryParam(param -> param.key("labels")
                                .value(labels).isRequired(false))
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("since")
                                .value(DateTimeHelper.toRfc8601DateTime(since)).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Issue[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssues404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposIssues422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Any user with pull access to a repository can create an issue. If [issues are disabled in the
     * repository](https://docs.github.com/articles/disabling-issues/), the API returns a `410 Gone`
     * status. This endpoint triggers
     * [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
     * Creating content too quickly using this endpoint may result in secondary rate limiting. See
     * "[Secondary rate
     * limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
     * and "[Dealing with secondary rate
     * limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)"
     * for details.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposIssuesResponse1 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposIssuesResponse1 issuesCreate(
            final String owner,
            final String repo,
            final ReposIssuesRequest body) throws ApiException, IOException {
        return prepareIssuesCreateRequest(owner, repo, body).execute();
    }

    /**
     * Any user with pull access to a repository can create an issue. If [issues are disabled in the
     * repository](https://docs.github.com/articles/disabling-issues/), the API returns a `410 Gone`
     * status. This endpoint triggers
     * [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
     * Creating content too quickly using this endpoint may result in secondary rate limiting. See
     * "[Secondary rate
     * limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
     * and "[Dealing with secondary rate
     * limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)"
     * for details.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposIssuesResponse1 response from the API call
     */
    public CompletableFuture<ReposIssuesResponse1> issuesCreateAsync(
            final String owner,
            final String repo,
            final ReposIssuesRequest body) {
        try { 
            return prepareIssuesCreateRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesCreate.
     */
    private ApiCall<ReposIssuesResponse1, ApiException> prepareIssuesCreateRequest(
            final String owner,
            final String repo,
            final ReposIssuesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposIssuesResponse1, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposIssuesResponse1.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposIssues403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssues404ErrorException(reason, context)))
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposIssues410ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposIssues422ErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.create("Service unavailable",
                                (reason, context) -> new ServiceUnavailable1Exception(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * By default, Issue Comments are ordered by ascending ID.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  sort  Optional parameter: The property to sort the results by. `created` means when
     *         the repository was starred. `updated` means when the repository was last pushed to.
     * @param  direction  Optional parameter: Either `asc` or `desc`. Ignored without the `sort`
     *         parameter.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of IssueComment response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<IssueComment> issuesListCommentsForRepo(
            final String owner,
            final String repo,
            final Sort1Enum sort,
            final Direction15Enum direction,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareIssuesListCommentsForRepoRequest(owner, repo, sort, direction, since, perPage,
                page).execute();
    }

    /**
     * By default, Issue Comments are ordered by ascending ID.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  sort  Optional parameter: The property to sort the results by. `created` means when
     *         the repository was starred. `updated` means when the repository was last pushed to.
     * @param  direction  Optional parameter: Either `asc` or `desc`. Ignored without the `sort`
     *         parameter.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of IssueComment response from the API call
     */
    public CompletableFuture<List<IssueComment>> issuesListCommentsForRepoAsync(
            final String owner,
            final String repo,
            final Sort1Enum sort,
            final Direction15Enum direction,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareIssuesListCommentsForRepoRequest(owner, repo, sort, direction, since, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesListCommentsForRepo.
     */
    private ApiCall<List<IssueComment>, ApiException> prepareIssuesListCommentsForRepoRequest(
            final String owner,
            final String repo,
            final Sort1Enum sort,
            final Direction15Enum direction,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<IssueComment>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/comments")
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("since")
                                .value(DateTimeHelper.toRfc8601DateTime(since)).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        IssueComment[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesComments404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposIssuesComments422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get an issue comment.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commentId  Required parameter: The unique identifier of the comment.
     * @return    Returns the ReposIssuesCommentsCommentIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposIssuesCommentsCommentIdResponse issuesGetComment(
            final String owner,
            final String repo,
            final int commentId) throws ApiException, IOException {
        return prepareIssuesGetCommentRequest(owner, repo, commentId).execute();
    }

    /**
     * Get an issue comment.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commentId  Required parameter: The unique identifier of the comment.
     * @return    Returns the ReposIssuesCommentsCommentIdResponse response from the API call
     */
    public CompletableFuture<ReposIssuesCommentsCommentIdResponse> issuesGetCommentAsync(
            final String owner,
            final String repo,
            final int commentId) {
        try { 
            return prepareIssuesGetCommentRequest(owner, repo, commentId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesGetComment.
     */
    private ApiCall<ReposIssuesCommentsCommentIdResponse, ApiException> prepareIssuesGetCommentRequest(
            final String owner,
            final String repo,
            final int commentId) throws IOException {
        return new ApiCall.Builder<ReposIssuesCommentsCommentIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/comments/{comment_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("comment_id").value(commentId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposIssuesCommentsCommentIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesCommentsCommentId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Update an issue comment.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commentId  Required parameter: The unique identifier of the comment.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposIssuesCommentsCommentIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposIssuesCommentsCommentIdResponse issuesUpdateComment(
            final String owner,
            final String repo,
            final int commentId,
            final ReposIssuesCommentsCommentIdRequest body) throws ApiException, IOException {
        return prepareIssuesUpdateCommentRequest(owner, repo, commentId, body).execute();
    }

    /**
     * Update an issue comment.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commentId  Required parameter: The unique identifier of the comment.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposIssuesCommentsCommentIdResponse response from the API call
     */
    public CompletableFuture<ReposIssuesCommentsCommentIdResponse> issuesUpdateCommentAsync(
            final String owner,
            final String repo,
            final int commentId,
            final ReposIssuesCommentsCommentIdRequest body) {
        try { 
            return prepareIssuesUpdateCommentRequest(owner, repo, commentId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesUpdateComment.
     */
    private ApiCall<ReposIssuesCommentsCommentIdResponse, ApiException> prepareIssuesUpdateCommentRequest(
            final String owner,
            final String repo,
            final int commentId,
            final ReposIssuesCommentsCommentIdRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposIssuesCommentsCommentIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/comments/{comment_id}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("comment_id").value(commentId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposIssuesCommentsCommentIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposIssuesCommentsCommentId422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Delete an issue comment.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commentId  Required parameter: The unique identifier of the comment.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void issuesDeleteComment(
            final String owner,
            final String repo,
            final int commentId) throws ApiException, IOException {
        prepareIssuesDeleteCommentRequest(owner, repo, commentId).execute();
    }

    /**
     * Delete an issue comment.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commentId  Required parameter: The unique identifier of the comment.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> issuesDeleteCommentAsync(
            final String owner,
            final String repo,
            final int commentId) {
        try { 
            return prepareIssuesDeleteCommentRequest(owner, repo, commentId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesDeleteComment.
     */
    private ApiCall<Void, ApiException> prepareIssuesDeleteCommentRequest(
            final String owner,
            final String repo,
            final int commentId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/comments/{comment_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("comment_id").value(commentId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List issue events for a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of IssueEvent response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<IssueEvent> issuesListEventsForRepo(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareIssuesListEventsForRepoRequest(owner, repo, perPage, page).execute();
    }

    /**
     * List issue events for a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of IssueEvent response from the API call
     */
    public CompletableFuture<List<IssueEvent>> issuesListEventsForRepoAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareIssuesListEventsForRepoRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesListEventsForRepo.
     */
    private ApiCall<List<IssueEvent>, ApiException> prepareIssuesListEventsForRepoRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<IssueEvent>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/events")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        IssueEvent[].class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposIssuesEvents422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get an issue event.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  eventId  Required parameter: Example:
     * @return    Returns the ReposIssuesEventsEventIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposIssuesEventsEventIdResponse issuesGetEvent(
            final String owner,
            final String repo,
            final int eventId) throws ApiException, IOException {
        return prepareIssuesGetEventRequest(owner, repo, eventId).execute();
    }

    /**
     * Get an issue event.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  eventId  Required parameter: Example:
     * @return    Returns the ReposIssuesEventsEventIdResponse response from the API call
     */
    public CompletableFuture<ReposIssuesEventsEventIdResponse> issuesGetEventAsync(
            final String owner,
            final String repo,
            final int eventId) {
        try { 
            return prepareIssuesGetEventRequest(owner, repo, eventId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesGetEvent.
     */
    private ApiCall<ReposIssuesEventsEventIdResponse, ApiException> prepareIssuesGetEventRequest(
            final String owner,
            final String repo,
            final int eventId) throws IOException {
        return new ApiCall.Builder<ReposIssuesEventsEventIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/events/{event_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("event_id").value(eventId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposIssuesEventsEventIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposIssuesEventsEventId403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesEventsEventId404ErrorException(reason, context)))
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposIssuesEventsEventId410ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * The API returns a [`301 Moved Permanently`
     * status](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-redirects-redirects)
     * if the issue was
     * [transferred](https://docs.github.com/articles/transferring-an-issue-to-another-repository/)
     * to another repository. If the issue was transferred to or deleted from a repository where the
     * authenticated user lacks read access, the API returns a `404 Not Found` status. If the issue
     * was deleted from a repository where the authenticated user has read access, the API returns a
     * `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe to
     * the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook. **Note**:
     * GitHub's REST API considers every pull request an issue, but not every issue is a pull
     * request. For this reason, "Issues" endpoints may return both issues and pull requests in the
     * response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of
     * a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull
     * requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @return    Returns the ReposIssuesIssueNumberResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposIssuesIssueNumberResponse issuesGet(
            final String owner,
            final String repo,
            final int issueNumber) throws ApiException, IOException {
        return prepareIssuesGetRequest(owner, repo, issueNumber).execute();
    }

    /**
     * The API returns a [`301 Moved Permanently`
     * status](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-redirects-redirects)
     * if the issue was
     * [transferred](https://docs.github.com/articles/transferring-an-issue-to-another-repository/)
     * to another repository. If the issue was transferred to or deleted from a repository where the
     * authenticated user lacks read access, the API returns a `404 Not Found` status. If the issue
     * was deleted from a repository where the authenticated user has read access, the API returns a
     * `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe to
     * the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook. **Note**:
     * GitHub's REST API considers every pull request an issue, but not every issue is a pull
     * request. For this reason, "Issues" endpoints may return both issues and pull requests in the
     * response. You can identify pull requests by the `pull_request` key. Be aware that the `id` of
     * a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull
     * requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @return    Returns the ReposIssuesIssueNumberResponse response from the API call
     */
    public CompletableFuture<ReposIssuesIssueNumberResponse> issuesGetAsync(
            final String owner,
            final String repo,
            final int issueNumber) {
        try { 
            return prepareIssuesGetRequest(owner, repo, issueNumber).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesGet.
     */
    private ApiCall<ReposIssuesIssueNumberResponse, ApiException> prepareIssuesGetRequest(
            final String owner,
            final String repo,
            final int issueNumber) throws IOException {
        return new ApiCall.Builder<ReposIssuesIssueNumberResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposIssuesIssueNumberResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesIssueNumber404ErrorException(reason, context)))
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposIssuesIssueNumber410ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Issue owners and users with push access can edit an issue.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposIssuesIssueNumberResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposIssuesIssueNumberResponse issuesUpdate(
            final String owner,
            final String repo,
            final int issueNumber,
            final ReposIssuesIssueNumberRequest body) throws ApiException, IOException {
        return prepareIssuesUpdateRequest(owner, repo, issueNumber, body).execute();
    }

    /**
     * Issue owners and users with push access can edit an issue.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposIssuesIssueNumberResponse response from the API call
     */
    public CompletableFuture<ReposIssuesIssueNumberResponse> issuesUpdateAsync(
            final String owner,
            final String repo,
            final int issueNumber,
            final ReposIssuesIssueNumberRequest body) {
        try { 
            return prepareIssuesUpdateRequest(owner, repo, issueNumber, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesUpdate.
     */
    private ApiCall<ReposIssuesIssueNumberResponse, ApiException> prepareIssuesUpdateRequest(
            final String owner,
            final String repo,
            final int issueNumber,
            final ReposIssuesIssueNumberRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposIssuesIssueNumberResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposIssuesIssueNumberResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposIssuesIssueNumber403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesIssueNumber404ErrorException(reason, context)))
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposIssuesIssueNumber410ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposIssuesIssueNumber422ErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.create("Service unavailable",
                                (reason, context) -> new ServiceUnavailable1Exception(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposIssuesIssueNumberAssigneesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposIssuesIssueNumberAssigneesResponse issuesAddAssignees(
            final String owner,
            final String repo,
            final int issueNumber,
            final ReposIssuesIssueNumberAssigneesRequest body) throws ApiException, IOException {
        return prepareIssuesAddAssigneesRequest(owner, repo, issueNumber, body).execute();
    }

    /**
     * Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposIssuesIssueNumberAssigneesResponse response from the API call
     */
    public CompletableFuture<ReposIssuesIssueNumberAssigneesResponse> issuesAddAssigneesAsync(
            final String owner,
            final String repo,
            final int issueNumber,
            final ReposIssuesIssueNumberAssigneesRequest body) {
        try { 
            return prepareIssuesAddAssigneesRequest(owner, repo, issueNumber, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesAddAssignees.
     */
    private ApiCall<ReposIssuesIssueNumberAssigneesResponse, ApiException> prepareIssuesAddAssigneesRequest(
            final String owner,
            final String repo,
            final int issueNumber,
            final ReposIssuesIssueNumberAssigneesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposIssuesIssueNumberAssigneesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}/assignees")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposIssuesIssueNumberAssigneesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes one or more assignees from an issue.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  contentType  Required parameter: Example:
     * @return    Returns the ReposIssuesIssueNumberAssigneesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposIssuesIssueNumberAssigneesResponse issuesRemoveAssignees(
            final String owner,
            final String repo,
            final int issueNumber,
            final ContentType3Enum contentType) throws ApiException, IOException {
        return prepareIssuesRemoveAssigneesRequest(owner, repo, issueNumber, contentType).execute();
    }

    /**
     * Removes one or more assignees from an issue.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  contentType  Required parameter: Example:
     * @return    Returns the ReposIssuesIssueNumberAssigneesResponse response from the API call
     */
    public CompletableFuture<ReposIssuesIssueNumberAssigneesResponse> issuesRemoveAssigneesAsync(
            final String owner,
            final String repo,
            final int issueNumber,
            final ContentType3Enum contentType) {
        try { 
            return prepareIssuesRemoveAssigneesRequest(owner, repo, issueNumber,
            contentType).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesRemoveAssignees.
     */
    private ApiCall<ReposIssuesIssueNumberAssigneesResponse, ApiException> prepareIssuesRemoveAssigneesRequest(
            final String owner,
            final String repo,
            final int issueNumber,
            final ContentType3Enum contentType) throws IOException {
        return new ApiCall.Builder<ReposIssuesIssueNumberAssigneesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}/assignees")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value((contentType != null) ? contentType.value() : null).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposIssuesIssueNumberAssigneesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Checks if a user has permission to be assigned to a specific issue. If the `assignee` can be
     * assigned to this issue, a `204` status code with no content is returned. Otherwise a `404`
     * status code is returned.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  assignee  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void issuesCheckUserCanBeAssignedToIssue(
            final String owner,
            final String repo,
            final int issueNumber,
            final String assignee) throws ApiException, IOException {
        prepareIssuesCheckUserCanBeAssignedToIssueRequest(owner, repo, issueNumber,
                assignee).execute();
    }

    /**
     * Checks if a user has permission to be assigned to a specific issue. If the `assignee` can be
     * assigned to this issue, a `204` status code with no content is returned. Otherwise a `404`
     * status code is returned.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  assignee  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> issuesCheckUserCanBeAssignedToIssueAsync(
            final String owner,
            final String repo,
            final int issueNumber,
            final String assignee) {
        try { 
            return prepareIssuesCheckUserCanBeAssignedToIssueRequest(owner, repo, issueNumber,
            assignee).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesCheckUserCanBeAssignedToIssue.
     */
    private ApiCall<Void, ApiException> prepareIssuesCheckUserCanBeAssignedToIssueRequest(
            final String owner,
            final String repo,
            final int issueNumber,
            final String assignee) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("assignee").value(assignee)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Response if `assignee` can not be assigned to `issue_number`",
                                (reason, context) -> new ReposIssuesIssueNumberAssigneesAssignee404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Issue Comments are ordered by ascending ID.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of IssueComment response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<IssueComment> issuesListComments(
            final String owner,
            final String repo,
            final int issueNumber,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareIssuesListCommentsRequest(owner, repo, issueNumber, since, perPage,
                page).execute();
    }

    /**
     * Issue Comments are ordered by ascending ID.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of IssueComment response from the API call
     */
    public CompletableFuture<List<IssueComment>> issuesListCommentsAsync(
            final String owner,
            final String repo,
            final int issueNumber,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareIssuesListCommentsRequest(owner, repo, issueNumber, since, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesListComments.
     */
    private ApiCall<List<IssueComment>, ApiException> prepareIssuesListCommentsRequest(
            final String owner,
            final String repo,
            final int issueNumber,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<IssueComment>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}/comments")
                        .queryParam(param -> param.key("since")
                                .value(DateTimeHelper.toRfc8601DateTime(since)).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        IssueComment[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesIssueNumberComments404ErrorException(reason, context)))
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposIssuesIssueNumberComments410ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This endpoint triggers
     * [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
     * Creating content too quickly using this endpoint may result in secondary rate limiting. See
     * "[Secondary rate
     * limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
     * and "[Dealing with secondary rate
     * limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)"
     * for details.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposIssuesIssueNumberCommentsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposIssuesIssueNumberCommentsResponse issuesCreateComment(
            final String owner,
            final String repo,
            final int issueNumber,
            final ReposIssuesCommentsCommentIdRequest body) throws ApiException, IOException {
        return prepareIssuesCreateCommentRequest(owner, repo, issueNumber, body).execute();
    }

    /**
     * This endpoint triggers
     * [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
     * Creating content too quickly using this endpoint may result in secondary rate limiting. See
     * "[Secondary rate
     * limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
     * and "[Dealing with secondary rate
     * limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)"
     * for details.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposIssuesIssueNumberCommentsResponse response from the API call
     */
    public CompletableFuture<ReposIssuesIssueNumberCommentsResponse> issuesCreateCommentAsync(
            final String owner,
            final String repo,
            final int issueNumber,
            final ReposIssuesCommentsCommentIdRequest body) {
        try { 
            return prepareIssuesCreateCommentRequest(owner, repo, issueNumber, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesCreateComment.
     */
    private ApiCall<ReposIssuesIssueNumberCommentsResponse, ApiException> prepareIssuesCreateCommentRequest(
            final String owner,
            final String repo,
            final int issueNumber,
            final ReposIssuesCommentsCommentIdRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposIssuesIssueNumberCommentsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}/comments")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposIssuesIssueNumberCommentsResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposIssuesIssueNumberComments403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesIssueNumberComments404ErrorException(reason, context)))
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposIssuesIssueNumberComments410ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposIssuesIssueNumberComments422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List issue events.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of IssueEventforIssue1 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<IssueEventforIssue1> issuesListEvents(
            final String owner,
            final String repo,
            final int issueNumber,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareIssuesListEventsRequest(owner, repo, issueNumber, perPage, page).execute();
    }

    /**
     * List issue events.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of IssueEventforIssue1 response from the API call
     */
    public CompletableFuture<List<IssueEventforIssue1>> issuesListEventsAsync(
            final String owner,
            final String repo,
            final int issueNumber,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareIssuesListEventsRequest(owner, repo, issueNumber, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesListEvents.
     */
    private ApiCall<List<IssueEventforIssue1>, ApiException> prepareIssuesListEventsRequest(
            final String owner,
            final String repo,
            final int issueNumber,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<IssueEventforIssue1>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}/events")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        IssueEventforIssue1[].class))
                        .nullify404(false)
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposIssuesIssueNumberEvents410ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List labels for an issue.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Label response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Label> issuesListLabelsOnIssue(
            final String owner,
            final String repo,
            final int issueNumber,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareIssuesListLabelsOnIssueRequest(owner, repo, issueNumber, perPage,
                page).execute();
    }

    /**
     * List labels for an issue.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Label response from the API call
     */
    public CompletableFuture<List<Label>> issuesListLabelsOnIssueAsync(
            final String owner,
            final String repo,
            final int issueNumber,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareIssuesListLabelsOnIssueRequest(owner, repo, issueNumber, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesListLabelsOnIssue.
     */
    private ApiCall<List<Label>, ApiException> prepareIssuesListLabelsOnIssueRequest(
            final String owner,
            final String repo,
            final int issueNumber,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Label>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}/labels")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Label[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesIssueNumberLabels404ErrorException(reason, context)))
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposIssuesIssueNumberLabels410ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Add labels to an issue.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of Label response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Label> issuesAddLabels(
            final String owner,
            final String repo,
            final int issueNumber,
            final IssuesAddLabelsBody body) throws ApiException, IOException {
        return prepareIssuesAddLabelsRequest(owner, repo, issueNumber, body).execute();
    }

    /**
     * Add labels to an issue.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of Label response from the API call
     */
    public CompletableFuture<List<Label>> issuesAddLabelsAsync(
            final String owner,
            final String repo,
            final int issueNumber,
            final IssuesAddLabelsBody body) {
        try { 
            return prepareIssuesAddLabelsRequest(owner, repo, issueNumber, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesAddLabels.
     */
    private ApiCall<List<Label>, ApiException> prepareIssuesAddLabelsRequest(
            final String owner,
            final String repo,
            final int issueNumber,
            final IssuesAddLabelsBody body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<List<Label>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}/labels")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serializeTypeCombinator(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Label[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesIssueNumberLabels404ErrorException(reason, context)))
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposIssuesIssueNumberLabels410ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposIssuesIssueNumberLabels422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes any previous labels and sets the new labels for an issue.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of Label response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Label> issuesSetLabels(
            final String owner,
            final String repo,
            final int issueNumber,
            final IssuesSetLabelsBody body) throws ApiException, IOException {
        return prepareIssuesSetLabelsRequest(owner, repo, issueNumber, body).execute();
    }

    /**
     * Removes any previous labels and sets the new labels for an issue.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of Label response from the API call
     */
    public CompletableFuture<List<Label>> issuesSetLabelsAsync(
            final String owner,
            final String repo,
            final int issueNumber,
            final IssuesSetLabelsBody body) {
        try { 
            return prepareIssuesSetLabelsRequest(owner, repo, issueNumber, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesSetLabels.
     */
    private ApiCall<List<Label>, ApiException> prepareIssuesSetLabelsRequest(
            final String owner,
            final String repo,
            final int issueNumber,
            final IssuesSetLabelsBody body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<List<Label>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}/labels")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serializeTypeCombinator(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Label[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesIssueNumberLabels404ErrorException(reason, context)))
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposIssuesIssueNumberLabels410ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposIssuesIssueNumberLabels422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Remove all labels from an issue.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void issuesRemoveAllLabels(
            final String owner,
            final String repo,
            final int issueNumber) throws ApiException, IOException {
        prepareIssuesRemoveAllLabelsRequest(owner, repo, issueNumber).execute();
    }

    /**
     * Remove all labels from an issue.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> issuesRemoveAllLabelsAsync(
            final String owner,
            final String repo,
            final int issueNumber) {
        try { 
            return prepareIssuesRemoveAllLabelsRequest(owner, repo, issueNumber).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesRemoveAllLabels.
     */
    private ApiCall<Void, ApiException> prepareIssuesRemoveAllLabelsRequest(
            final String owner,
            final String repo,
            final int issueNumber) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}/labels")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesIssueNumberLabels404ErrorException(reason, context)))
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposIssuesIssueNumberLabels410ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes the specified label from the issue, and returns the remaining labels on the issue.
     * This endpoint returns a `404 Not Found` status if the label does not exist.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  name  Required parameter: Example:
     * @return    Returns the List of Label response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Label> issuesRemoveLabel(
            final String owner,
            final String repo,
            final int issueNumber,
            final String name) throws ApiException, IOException {
        return prepareIssuesRemoveLabelRequest(owner, repo, issueNumber, name).execute();
    }

    /**
     * Removes the specified label from the issue, and returns the remaining labels on the issue.
     * This endpoint returns a `404 Not Found` status if the label does not exist.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  name  Required parameter: Example:
     * @return    Returns the List of Label response from the API call
     */
    public CompletableFuture<List<Label>> issuesRemoveLabelAsync(
            final String owner,
            final String repo,
            final int issueNumber,
            final String name) {
        try { 
            return prepareIssuesRemoveLabelRequest(owner, repo, issueNumber, name).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesRemoveLabel.
     */
    private ApiCall<List<Label>, ApiException> prepareIssuesRemoveLabelRequest(
            final String owner,
            final String repo,
            final int issueNumber,
            final String name) throws IOException {
        return new ApiCall.Builder<List<Label>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}/labels/{name}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Label[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesIssueNumberLabelsName404ErrorException(reason, context)))
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposIssuesIssueNumberLabelsName410ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Users with push access can lock an issue or pull request's conversation. Note that, if you
     * choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling
     * out to this endpoint. For more information, see "[HTTP
     * verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  body  Optional parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void issuesLock(
            final String owner,
            final String repo,
            final int issueNumber,
            final Object body) throws ApiException, IOException {
        prepareIssuesLockRequest(owner, repo, issueNumber, body).execute();
    }

    /**
     * Users with push access can lock an issue or pull request's conversation. Note that, if you
     * choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling
     * out to this endpoint. For more information, see "[HTTP
     * verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  body  Optional parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> issuesLockAsync(
            final String owner,
            final String repo,
            final int issueNumber,
            final Object body) {
        try { 
            return prepareIssuesLockRequest(owner, repo, issueNumber, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesLock.
     */
    private ApiCall<Void, ApiException> prepareIssuesLockRequest(
            final String owner,
            final String repo,
            final int issueNumber,
            final Object body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}/lock")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposIssuesIssueNumberLock403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesIssueNumberLock404ErrorException(reason, context)))
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposIssuesIssueNumberLock410ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposIssuesIssueNumberLock422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Users with push access can unlock an issue's conversation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void issuesUnlock(
            final String owner,
            final String repo,
            final int issueNumber) throws ApiException, IOException {
        prepareIssuesUnlockRequest(owner, repo, issueNumber).execute();
    }

    /**
     * Users with push access can unlock an issue's conversation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> issuesUnlockAsync(
            final String owner,
            final String repo,
            final int issueNumber) {
        try { 
            return prepareIssuesUnlockRequest(owner, repo, issueNumber).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesUnlock.
     */
    private ApiCall<Void, ApiException> prepareIssuesUnlockRequest(
            final String owner,
            final String repo,
            final int issueNumber) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}/lock")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposIssuesIssueNumberLock403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesIssueNumberLock404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List timeline events for an issue.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of TimelineEvent1 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<TimelineEvent1> issuesListEventsForTimeline(
            final String owner,
            final String repo,
            final int issueNumber,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareIssuesListEventsForTimelineRequest(owner, repo, issueNumber, perPage,
                page).execute();
    }

    /**
     * List timeline events for an issue.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  issueNumber  Required parameter: The number that identifies the issue.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of TimelineEvent1 response from the API call
     */
    public CompletableFuture<List<TimelineEvent1>> issuesListEventsForTimelineAsync(
            final String owner,
            final String repo,
            final int issueNumber,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareIssuesListEventsForTimelineRequest(owner, repo, issueNumber, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesListEventsForTimeline.
     */
    private ApiCall<List<TimelineEvent1>, ApiException> prepareIssuesListEventsForTimelineRequest(
            final String owner,
            final String repo,
            final int issueNumber,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<TimelineEvent1>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/issues/{issue_number}/timeline")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("issue_number").value(issueNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        TimelineEvent1[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposIssuesIssueNumberTimeline404ErrorException(reason, context)))
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposIssuesIssueNumberTimeline410ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List labels for a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Label response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Label> issuesListLabelsForRepo(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareIssuesListLabelsForRepoRequest(owner, repo, perPage, page).execute();
    }

    /**
     * List labels for a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Label response from the API call
     */
    public CompletableFuture<List<Label>> issuesListLabelsForRepoAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareIssuesListLabelsForRepoRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesListLabelsForRepo.
     */
    private ApiCall<List<Label>, ApiException> prepareIssuesListLabelsForRepoRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Label>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/labels")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Label[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposLabels404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Create a label.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposLabelsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposLabelsResponse issuesCreateLabel(
            final String owner,
            final String repo,
            final ReposLabelsRequest body) throws ApiException, IOException {
        return prepareIssuesCreateLabelRequest(owner, repo, body).execute();
    }

    /**
     * Create a label.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposLabelsResponse response from the API call
     */
    public CompletableFuture<ReposLabelsResponse> issuesCreateLabelAsync(
            final String owner,
            final String repo,
            final ReposLabelsRequest body) {
        try { 
            return prepareIssuesCreateLabelRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesCreateLabel.
     */
    private ApiCall<ReposLabelsResponse, ApiException> prepareIssuesCreateLabelRequest(
            final String owner,
            final String repo,
            final ReposLabelsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposLabelsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/labels")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposLabelsResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposLabels404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposLabels422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get a label.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  name  Required parameter: Example:
     * @return    Returns the ReposLabelsNameResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposLabelsNameResponse issuesGetLabel(
            final String owner,
            final String repo,
            final String name) throws ApiException, IOException {
        return prepareIssuesGetLabelRequest(owner, repo, name).execute();
    }

    /**
     * Get a label.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  name  Required parameter: Example:
     * @return    Returns the ReposLabelsNameResponse response from the API call
     */
    public CompletableFuture<ReposLabelsNameResponse> issuesGetLabelAsync(
            final String owner,
            final String repo,
            final String name) {
        try { 
            return prepareIssuesGetLabelRequest(owner, repo, name).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesGetLabel.
     */
    private ApiCall<ReposLabelsNameResponse, ApiException> prepareIssuesGetLabelRequest(
            final String owner,
            final String repo,
            final String name) throws IOException {
        return new ApiCall.Builder<ReposLabelsNameResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/labels/{name}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposLabelsNameResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposLabelsName404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Update a label.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  name  Required parameter: Example:
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposLabelsNameResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposLabelsNameResponse issuesUpdateLabel(
            final String owner,
            final String repo,
            final String name,
            final ReposLabelsNameRequest body) throws ApiException, IOException {
        return prepareIssuesUpdateLabelRequest(owner, repo, name, body).execute();
    }

    /**
     * Update a label.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  name  Required parameter: Example:
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposLabelsNameResponse response from the API call
     */
    public CompletableFuture<ReposLabelsNameResponse> issuesUpdateLabelAsync(
            final String owner,
            final String repo,
            final String name,
            final ReposLabelsNameRequest body) {
        try { 
            return prepareIssuesUpdateLabelRequest(owner, repo, name, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesUpdateLabel.
     */
    private ApiCall<ReposLabelsNameResponse, ApiException> prepareIssuesUpdateLabelRequest(
            final String owner,
            final String repo,
            final String name,
            final ReposLabelsNameRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposLabelsNameResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/labels/{name}")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposLabelsNameResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Delete a label.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  name  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void issuesDeleteLabel(
            final String owner,
            final String repo,
            final String name) throws ApiException, IOException {
        prepareIssuesDeleteLabelRequest(owner, repo, name).execute();
    }

    /**
     * Delete a label.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  name  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> issuesDeleteLabelAsync(
            final String owner,
            final String repo,
            final String name) {
        try { 
            return prepareIssuesDeleteLabelRequest(owner, repo, name).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesDeleteLabel.
     */
    private ApiCall<Void, ApiException> prepareIssuesDeleteLabelRequest(
            final String owner,
            final String repo,
            final String name) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/labels/{name}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List milestones.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  state  Optional parameter: The state of the milestone. Either `open`, `closed`, or
     *         `all`.
     * @param  sort  Optional parameter: What to sort results by. Either `due_on` or `completeness`.
     * @param  direction  Optional parameter: The direction of the sort. Either `asc` or `desc`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Milestone response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Milestone> issuesListMilestones(
            final String owner,
            final String repo,
            final State1674Enum state,
            final Sort121Enum sort,
            final Direction16Enum direction,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareIssuesListMilestonesRequest(owner, repo, state, sort, direction, perPage,
                page).execute();
    }

    /**
     * List milestones.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  state  Optional parameter: The state of the milestone. Either `open`, `closed`, or
     *         `all`.
     * @param  sort  Optional parameter: What to sort results by. Either `due_on` or `completeness`.
     * @param  direction  Optional parameter: The direction of the sort. Either `asc` or `desc`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Milestone response from the API call
     */
    public CompletableFuture<List<Milestone>> issuesListMilestonesAsync(
            final String owner,
            final String repo,
            final State1674Enum state,
            final Sort121Enum sort,
            final Direction16Enum direction,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareIssuesListMilestonesRequest(owner, repo, state, sort, direction, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesListMilestones.
     */
    private ApiCall<List<Milestone>, ApiException> prepareIssuesListMilestonesRequest(
            final String owner,
            final String repo,
            final State1674Enum state,
            final Sort121Enum sort,
            final Direction16Enum direction,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Milestone>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/milestones")
                        .queryParam(param -> param.key("state")
                                .value((state != null) ? state.value() : null).isRequired(false))
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Milestone[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposMilestones404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Create a milestone.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposMilestonesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposMilestonesResponse issuesCreateMilestone(
            final String owner,
            final String repo,
            final ReposMilestonesRequest body) throws ApiException, IOException {
        return prepareIssuesCreateMilestoneRequest(owner, repo, body).execute();
    }

    /**
     * Create a milestone.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposMilestonesResponse response from the API call
     */
    public CompletableFuture<ReposMilestonesResponse> issuesCreateMilestoneAsync(
            final String owner,
            final String repo,
            final ReposMilestonesRequest body) {
        try { 
            return prepareIssuesCreateMilestoneRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesCreateMilestone.
     */
    private ApiCall<ReposMilestonesResponse, ApiException> prepareIssuesCreateMilestoneRequest(
            final String owner,
            final String repo,
            final ReposMilestonesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposMilestonesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/milestones")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposMilestonesResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposMilestones404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposMilestones422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get a milestone.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  milestoneNumber  Required parameter: The number that identifies the milestone.
     * @return    Returns the ReposMilestonesMilestoneNumberResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposMilestonesMilestoneNumberResponse issuesGetMilestone(
            final String owner,
            final String repo,
            final int milestoneNumber) throws ApiException, IOException {
        return prepareIssuesGetMilestoneRequest(owner, repo, milestoneNumber).execute();
    }

    /**
     * Get a milestone.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  milestoneNumber  Required parameter: The number that identifies the milestone.
     * @return    Returns the ReposMilestonesMilestoneNumberResponse response from the API call
     */
    public CompletableFuture<ReposMilestonesMilestoneNumberResponse> issuesGetMilestoneAsync(
            final String owner,
            final String repo,
            final int milestoneNumber) {
        try { 
            return prepareIssuesGetMilestoneRequest(owner, repo, milestoneNumber).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesGetMilestone.
     */
    private ApiCall<ReposMilestonesMilestoneNumberResponse, ApiException> prepareIssuesGetMilestoneRequest(
            final String owner,
            final String repo,
            final int milestoneNumber) throws IOException {
        return new ApiCall.Builder<ReposMilestonesMilestoneNumberResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/milestones/{milestone_number}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("milestone_number").value(milestoneNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposMilestonesMilestoneNumberResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposMilestonesMilestoneNumber404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Update a milestone.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  milestoneNumber  Required parameter: The number that identifies the milestone.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposMilestonesMilestoneNumberResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposMilestonesMilestoneNumberResponse issuesUpdateMilestone(
            final String owner,
            final String repo,
            final int milestoneNumber,
            final ReposMilestonesMilestoneNumberRequest body) throws ApiException, IOException {
        return prepareIssuesUpdateMilestoneRequest(owner, repo, milestoneNumber, body).execute();
    }

    /**
     * Update a milestone.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  milestoneNumber  Required parameter: The number that identifies the milestone.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposMilestonesMilestoneNumberResponse response from the API call
     */
    public CompletableFuture<ReposMilestonesMilestoneNumberResponse> issuesUpdateMilestoneAsync(
            final String owner,
            final String repo,
            final int milestoneNumber,
            final ReposMilestonesMilestoneNumberRequest body) {
        try { 
            return prepareIssuesUpdateMilestoneRequest(owner, repo, milestoneNumber, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesUpdateMilestone.
     */
    private ApiCall<ReposMilestonesMilestoneNumberResponse, ApiException> prepareIssuesUpdateMilestoneRequest(
            final String owner,
            final String repo,
            final int milestoneNumber,
            final ReposMilestonesMilestoneNumberRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposMilestonesMilestoneNumberResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/milestones/{milestone_number}")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("milestone_number").value(milestoneNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposMilestonesMilestoneNumberResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Delete a milestone.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  milestoneNumber  Required parameter: The number that identifies the milestone.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void issuesDeleteMilestone(
            final String owner,
            final String repo,
            final int milestoneNumber) throws ApiException, IOException {
        prepareIssuesDeleteMilestoneRequest(owner, repo, milestoneNumber).execute();
    }

    /**
     * Delete a milestone.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  milestoneNumber  Required parameter: The number that identifies the milestone.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> issuesDeleteMilestoneAsync(
            final String owner,
            final String repo,
            final int milestoneNumber) {
        try { 
            return prepareIssuesDeleteMilestoneRequest(owner, repo, milestoneNumber).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesDeleteMilestone.
     */
    private ApiCall<Void, ApiException> prepareIssuesDeleteMilestoneRequest(
            final String owner,
            final String repo,
            final int milestoneNumber) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/milestones/{milestone_number}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("milestone_number").value(milestoneNumber).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposMilestonesMilestoneNumber404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List labels for issues in a milestone.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  milestoneNumber  Required parameter: The number that identifies the milestone.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Label response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Label> issuesListLabelsForMilestone(
            final String owner,
            final String repo,
            final int milestoneNumber,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareIssuesListLabelsForMilestoneRequest(owner, repo, milestoneNumber, perPage,
                page).execute();
    }

    /**
     * List labels for issues in a milestone.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  milestoneNumber  Required parameter: The number that identifies the milestone.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Label response from the API call
     */
    public CompletableFuture<List<Label>> issuesListLabelsForMilestoneAsync(
            final String owner,
            final String repo,
            final int milestoneNumber,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareIssuesListLabelsForMilestoneRequest(owner, repo, milestoneNumber, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesListLabelsForMilestone.
     */
    private ApiCall<List<Label>, ApiException> prepareIssuesListLabelsForMilestoneRequest(
            final String owner,
            final String repo,
            final int milestoneNumber,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Label>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/milestones/{milestone_number}/labels")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("milestone_number").value(milestoneNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Label[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List issues across owned and member repositories assigned to the authenticated user.
     * **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a
     * pull request. For this reason, "Issues" endpoints may return both issues and pull requests in
     * the response. You can identify pull requests by the `pull_request` key. Be aware that the
     * `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out
     * the pull request id, use the "[List pull
     * requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
     * @param  filter  Optional parameter: Indicates which sorts of issues to return. `assigned`
     *         means issues assigned to you. `created` means issues created by you. `mentioned`
     *         means issues mentioning you. `subscribed` means issues you're subscribed to updates
     *         for. `all` or `repos` means all issues you can see, regardless of participation or
     *         creation.
     * @param  state  Optional parameter: Indicates the state of the issues to return.
     * @param  labels  Optional parameter: A list of comma separated label names. Example:
     *         `bug,ui,@high`
     * @param  sort  Optional parameter: What to sort results by.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Issue response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Issue> issuesListForAuthenticatedUser(
            final Filter1Enum filter,
            final State1671Enum state,
            final String labels,
            final Sort23Enum sort,
            final Direction1Enum direction,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareIssuesListForAuthenticatedUserRequest(filter, state, labels, sort, direction,
                since, perPage, page).execute();
    }

    /**
     * List issues across owned and member repositories assigned to the authenticated user.
     * **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a
     * pull request. For this reason, "Issues" endpoints may return both issues and pull requests in
     * the response. You can identify pull requests by the `pull_request` key. Be aware that the
     * `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out
     * the pull request id, use the "[List pull
     * requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
     * @param  filter  Optional parameter: Indicates which sorts of issues to return. `assigned`
     *         means issues assigned to you. `created` means issues created by you. `mentioned`
     *         means issues mentioning you. `subscribed` means issues you're subscribed to updates
     *         for. `all` or `repos` means all issues you can see, regardless of participation or
     *         creation.
     * @param  state  Optional parameter: Indicates the state of the issues to return.
     * @param  labels  Optional parameter: A list of comma separated label names. Example:
     *         `bug,ui,@high`
     * @param  sort  Optional parameter: What to sort results by.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Issue response from the API call
     */
    public CompletableFuture<List<Issue>> issuesListForAuthenticatedUserAsync(
            final Filter1Enum filter,
            final State1671Enum state,
            final String labels,
            final Sort23Enum sort,
            final Direction1Enum direction,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareIssuesListForAuthenticatedUserRequest(filter, state, labels, sort, direction,
            since, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for issuesListForAuthenticatedUser.
     */
    private ApiCall<List<Issue>, ApiException> prepareIssuesListForAuthenticatedUserRequest(
            final Filter1Enum filter,
            final State1671Enum state,
            final String labels,
            final Sort23Enum sort,
            final Direction1Enum direction,
            final LocalDateTime since,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Issue>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/issues")
                        .queryParam(param -> param.key("filter")
                                .value((filter != null) ? filter.value() : null).isRequired(false))
                        .queryParam(param -> param.key("state")
                                .value((state != null) ? state.value() : null).isRequired(false))
                        .queryParam(param -> param.key("labels")
                                .value(labels).isRequired(false))
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("since")
                                .value(DateTimeHelper.toRfc8601DateTime(since)).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Issue[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserIssues404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}