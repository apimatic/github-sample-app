/*
 * GitHubAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.github.api.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.github.api.ApiHelper;
import com.github.api.DateTimeHelper;
import com.github.api.Server;
import com.github.api.exceptions.ApiException;
import com.github.api.exceptions.AppHookDeliveries400ErrorException;
import com.github.api.exceptions.AppHookDeliveries422ErrorException;
import com.github.api.exceptions.AppHookDeliveriesAttempts400ErrorException;
import com.github.api.exceptions.AppHookDeliveriesAttempts422ErrorException;
import com.github.api.exceptions.AppInstallations404ErrorException;
import com.github.api.exceptions.AppInstallationsAccessTokens401ErrorException;
import com.github.api.exceptions.AppInstallationsAccessTokens403ErrorException;
import com.github.api.exceptions.AppInstallationsAccessTokens404ErrorException;
import com.github.api.exceptions.AppInstallationsAccessTokens422ErrorException;
import com.github.api.exceptions.AppInstallationsSuspended404ErrorException;
import com.github.api.exceptions.AppManifestsConversions404ErrorException;
import com.github.api.exceptions.AppManifestsConversions422ErrorException;
import com.github.api.exceptions.ApplicationsGrant422ErrorException;
import com.github.api.exceptions.ApplicationsToken404ErrorException;
import com.github.api.exceptions.ApplicationsToken422ErrorException;
import com.github.api.exceptions.ApplicationsTokenScoped401ErrorException;
import com.github.api.exceptions.ApplicationsTokenScoped403ErrorException;
import com.github.api.exceptions.ApplicationsTokenScoped404ErrorException;
import com.github.api.exceptions.ApplicationsTokenScoped422ErrorException;
import com.github.api.exceptions.Apps403ErrorException;
import com.github.api.exceptions.Apps404ErrorException;
import com.github.api.exceptions.InstallationRepositories401ErrorException;
import com.github.api.exceptions.InstallationRepositories403ErrorException;
import com.github.api.exceptions.MarketplaceListingAccounts401ErrorException;
import com.github.api.exceptions.MarketplaceListingAccounts404ErrorException;
import com.github.api.exceptions.MarketplaceListingPlans401ErrorException;
import com.github.api.exceptions.MarketplaceListingPlans404ErrorException;
import com.github.api.exceptions.MarketplaceListingPlansAccounts401ErrorException;
import com.github.api.exceptions.MarketplaceListingPlansAccounts404ErrorException;
import com.github.api.exceptions.MarketplaceListingPlansAccounts422ErrorException;
import com.github.api.exceptions.MarketplaceListingStubbedAccounts401ErrorException;
import com.github.api.exceptions.MarketplaceListingStubbedPlans401ErrorException;
import com.github.api.exceptions.MarketplaceListingStubbedPlansAccounts401ErrorException;
import com.github.api.exceptions.ReposInstallation404ErrorException;
import com.github.api.exceptions.UserInstallations401ErrorException;
import com.github.api.exceptions.UserInstallations403ErrorException;
import com.github.api.exceptions.UserInstallationsRepositories403ErrorException;
import com.github.api.exceptions.UserInstallationsRepositories404ErrorException;
import com.github.api.exceptions.UserMarketplacePurchases401ErrorException;
import com.github.api.exceptions.UserMarketplacePurchases404ErrorException;
import com.github.api.exceptions.UserMarketplacePurchasesStubbed401ErrorException;
import com.github.api.http.request.HttpMethod;
import com.github.api.models.AppHookConfigRequest;
import com.github.api.models.AppHookDeliveriesResponse1;
import com.github.api.models.AppInstallationsAccessTokensRequest;
import com.github.api.models.AppInstallationsAccessTokensResponse;
import com.github.api.models.AppInstallationsResponse;
import com.github.api.models.AppManifestsConversionsResponse;
import com.github.api.models.AppResponse;
import com.github.api.models.ApplicationsTokenRequest;
import com.github.api.models.ApplicationsTokenResponse;
import com.github.api.models.ApplicationsTokenScopedRequest;
import com.github.api.models.ApplicationsTokenScopedResponse;
import com.github.api.models.AppsResponse;
import com.github.api.models.ContentType3Enum;
import com.github.api.models.Direction4Enum;
import com.github.api.models.Installation;
import com.github.api.models.InstallationRepositoriesResponse;
import com.github.api.models.MarketplaceListingAccountsResponse;
import com.github.api.models.MarketplaceListingPlan;
import com.github.api.models.MarketplaceListingStubbedAccountsResponse;
import com.github.api.models.MarketplacePurchase;
import com.github.api.models.OrgsInstallationResponse;
import com.github.api.models.OrgsInstallationsResponse;
import com.github.api.models.ReposInstallationResponse;
import com.github.api.models.Simplewebhookdelivery;
import com.github.api.models.Sort1Enum;
import com.github.api.models.UserMarketplacePurchase;
import com.github.api.models.UsersInstallationResponse;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class AppsController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public AppsController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Returns the GitHub App associated with the authentication credentials used. To see how many
     * app installations are associated with this GitHub App, see the `installations_count` in the
     * response. For more details about your app's installations, see the "[List installations for
     * the authenticated
     * app](https://docs.github.com/rest/reference/apps#list-installations-for-the-authenticated-app)"
     * endpoint. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @return    Returns the AppResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AppResponse appsGetAuthenticated() throws ApiException, IOException {
        return prepareAppsGetAuthenticatedRequest().execute();
    }

    /**
     * Returns the GitHub App associated with the authentication credentials used. To see how many
     * app installations are associated with this GitHub App, see the `installations_count` in the
     * response. For more details about your app's installations, see the "[List installations for
     * the authenticated
     * app](https://docs.github.com/rest/reference/apps#list-installations-for-the-authenticated-app)"
     * endpoint. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @return    Returns the AppResponse response from the API call
     */
    public CompletableFuture<AppResponse> appsGetAuthenticatedAsync() {
        try { 
            return prepareAppsGetAuthenticatedRequest().executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsGetAuthenticated.
     */
    private ApiCall<AppResponse, ApiException> prepareAppsGetAuthenticatedRequest() throws IOException {
        return new ApiCall.Builder<AppResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/app")
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, AppResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Use this endpoint to complete the handshake necessary when implementing the [GitHub App
     * Manifest
     * flow](https://docs.github.com/apps/building-github-apps/creating-github-apps-from-a-manifest/).
     * When you create a GitHub App with the manifest flow, you receive a temporary `code` used to
     * retrieve the GitHub App's `id`, `pem` (private key), and `webhook_secret`.
     * @param  code  Required parameter: Example:
     * @return    Returns the AppManifestsConversionsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AppManifestsConversionsResponse appsCreateFromManifest(
            final String code) throws ApiException, IOException {
        return prepareAppsCreateFromManifestRequest(code).execute();
    }

    /**
     * Use this endpoint to complete the handshake necessary when implementing the [GitHub App
     * Manifest
     * flow](https://docs.github.com/apps/building-github-apps/creating-github-apps-from-a-manifest/).
     * When you create a GitHub App with the manifest flow, you receive a temporary `code` used to
     * retrieve the GitHub App's `id`, `pem` (private key), and `webhook_secret`.
     * @param  code  Required parameter: Example:
     * @return    Returns the AppManifestsConversionsResponse response from the API call
     */
    public CompletableFuture<AppManifestsConversionsResponse> appsCreateFromManifestAsync(
            final String code) {
        try { 
            return prepareAppsCreateFromManifestRequest(code).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsCreateFromManifest.
     */
    private ApiCall<AppManifestsConversionsResponse, ApiException> prepareAppsCreateFromManifestRequest(
            final String code) throws IOException {
        return new ApiCall.Builder<AppManifestsConversionsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/app-manifests/{code}/conversions")
                        .templateParam(param -> param.key("code").value(code)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, AppManifestsConversionsResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new AppManifestsConversions404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new AppManifestsConversions422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns the webhook configuration for a GitHub App. For more information about configuring a
     * webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
     * You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @return    Returns the AppHookConfigRequest response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AppHookConfigRequest appsGetWebhookConfigForApp() throws ApiException, IOException {
        return prepareAppsGetWebhookConfigForAppRequest().execute();
    }

    /**
     * Returns the webhook configuration for a GitHub App. For more information about configuring a
     * webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
     * You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @return    Returns the AppHookConfigRequest response from the API call
     */
    public CompletableFuture<AppHookConfigRequest> appsGetWebhookConfigForAppAsync() {
        try { 
            return prepareAppsGetWebhookConfigForAppRequest().executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsGetWebhookConfigForApp.
     */
    private ApiCall<AppHookConfigRequest, ApiException> prepareAppsGetWebhookConfigForAppRequest() throws IOException {
        return new ApiCall.Builder<AppHookConfigRequest, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/app/hook/config")
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, AppHookConfigRequest.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates the webhook configuration for a GitHub App. For more information about configuring a
     * webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
     * You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  body  Required parameter: Example:
     * @return    Returns the AppHookConfigRequest response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AppHookConfigRequest appsUpdateWebhookConfigForApp(
            final AppHookConfigRequest body) throws ApiException, IOException {
        return prepareAppsUpdateWebhookConfigForAppRequest(body).execute();
    }

    /**
     * Updates the webhook configuration for a GitHub App. For more information about configuring a
     * webhook for your app, see "[Creating a GitHub App](/developers/apps/creating-a-github-app)."
     * You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  body  Required parameter: Example:
     * @return    Returns the AppHookConfigRequest response from the API call
     */
    public CompletableFuture<AppHookConfigRequest> appsUpdateWebhookConfigForAppAsync(
            final AppHookConfigRequest body) {
        try { 
            return prepareAppsUpdateWebhookConfigForAppRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsUpdateWebhookConfigForApp.
     */
    private ApiCall<AppHookConfigRequest, ApiException> prepareAppsUpdateWebhookConfigForAppRequest(
            final AppHookConfigRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<AppHookConfigRequest, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/app/hook/config")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, AppHookConfigRequest.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns a list of webhook deliveries for the webhook configured for a GitHub App. You must
     * use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  cursor  Optional parameter: Used for pagination: the starting delivery from which the
     *         page of deliveries is fetched. Refer to the `link` header for the next and previous
     *         page cursors.
     * @param  redelivery  Optional parameter: Example:
     * @return    Returns the List of Simplewebhookdelivery response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Simplewebhookdelivery> appsListWebhookDeliveries(
            final Integer perPage,
            final String cursor,
            final Boolean redelivery) throws ApiException, IOException {
        return prepareAppsListWebhookDeliveriesRequest(perPage, cursor, redelivery).execute();
    }

    /**
     * Returns a list of webhook deliveries for the webhook configured for a GitHub App. You must
     * use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  cursor  Optional parameter: Used for pagination: the starting delivery from which the
     *         page of deliveries is fetched. Refer to the `link` header for the next and previous
     *         page cursors.
     * @param  redelivery  Optional parameter: Example:
     * @return    Returns the List of Simplewebhookdelivery response from the API call
     */
    public CompletableFuture<List<Simplewebhookdelivery>> appsListWebhookDeliveriesAsync(
            final Integer perPage,
            final String cursor,
            final Boolean redelivery) {
        try { 
            return prepareAppsListWebhookDeliveriesRequest(perPage, cursor, redelivery).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsListWebhookDeliveries.
     */
    private ApiCall<List<Simplewebhookdelivery>, ApiException> prepareAppsListWebhookDeliveriesRequest(
            final Integer perPage,
            final String cursor,
            final Boolean redelivery) throws IOException {
        return new ApiCall.Builder<List<Simplewebhookdelivery>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/app/hook/deliveries")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("cursor")
                                .value(cursor).isRequired(false))
                        .queryParam(param -> param.key("redelivery")
                                .value(redelivery).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Simplewebhookdelivery[].class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new AppHookDeliveries400ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new AppHookDeliveries422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns a delivery for the webhook configured for a GitHub App. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  deliveryId  Required parameter: Example:
     * @return    Returns the AppHookDeliveriesResponse1 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AppHookDeliveriesResponse1 appsGetWebhookDelivery(
            final int deliveryId) throws ApiException, IOException {
        return prepareAppsGetWebhookDeliveryRequest(deliveryId).execute();
    }

    /**
     * Returns a delivery for the webhook configured for a GitHub App. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  deliveryId  Required parameter: Example:
     * @return    Returns the AppHookDeliveriesResponse1 response from the API call
     */
    public CompletableFuture<AppHookDeliveriesResponse1> appsGetWebhookDeliveryAsync(
            final int deliveryId) {
        try { 
            return prepareAppsGetWebhookDeliveryRequest(deliveryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsGetWebhookDelivery.
     */
    private ApiCall<AppHookDeliveriesResponse1, ApiException> prepareAppsGetWebhookDeliveryRequest(
            final int deliveryId) throws IOException {
        return new ApiCall.Builder<AppHookDeliveriesResponse1, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/app/hook/deliveries/{delivery_id}")
                        .templateParam(param -> param.key("delivery_id").value(deliveryId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, AppHookDeliveriesResponse1.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new AppHookDeliveries400ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new AppHookDeliveries422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Redeliver a delivery for the webhook configured for a GitHub App. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  deliveryId  Required parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object appsRedeliverWebhookDelivery(
            final int deliveryId) throws ApiException, IOException {
        return prepareAppsRedeliverWebhookDeliveryRequest(deliveryId).execute();
    }

    /**
     * Redeliver a delivery for the webhook configured for a GitHub App. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  deliveryId  Required parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> appsRedeliverWebhookDeliveryAsync(
            final int deliveryId) {
        try { 
            return prepareAppsRedeliverWebhookDeliveryRequest(deliveryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsRedeliverWebhookDelivery.
     */
    private ApiCall<Object, ApiException> prepareAppsRedeliverWebhookDeliveryRequest(
            final int deliveryId) throws IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/app/hook/deliveries/{delivery_id}/attempts")
                        .templateParam(param -> param.key("delivery_id").value(deliveryId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new AppHookDeliveriesAttempts400ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new AppHookDeliveriesAttempts422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint. The permissions the installation has are included under the
     * `permissions` key.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  outdated  Optional parameter: Example:
     * @return    Returns the List of Installation response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Installation> appsListInstallations(
            final Integer perPage,
            final Integer page,
            final LocalDateTime since,
            final String outdated) throws ApiException, IOException {
        return prepareAppsListInstallationsRequest(perPage, page, since, outdated).execute();
    }

    /**
     * You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint. The permissions the installation has are included under the
     * `permissions` key.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  outdated  Optional parameter: Example:
     * @return    Returns the List of Installation response from the API call
     */
    public CompletableFuture<List<Installation>> appsListInstallationsAsync(
            final Integer perPage,
            final Integer page,
            final LocalDateTime since,
            final String outdated) {
        try { 
            return prepareAppsListInstallationsRequest(perPage, page, since, outdated).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsListInstallations.
     */
    private ApiCall<List<Installation>, ApiException> prepareAppsListInstallationsRequest(
            final Integer perPage,
            final Integer page,
            final LocalDateTime since,
            final String outdated) throws IOException {
        return new ApiCall.Builder<List<Installation>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/app/installations")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("since")
                                .value(DateTimeHelper.toRfc8601DateTime(since)).isRequired(false))
                        .queryParam(param -> param.key("outdated")
                                .value(outdated).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Installation[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Enables an authenticated GitHub App to find an installation's information using the
     * installation id. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @return    Returns the AppInstallationsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AppInstallationsResponse appsGetInstallation(
            final int installationId) throws ApiException, IOException {
        return prepareAppsGetInstallationRequest(installationId).execute();
    }

    /**
     * Enables an authenticated GitHub App to find an installation's information using the
     * installation id. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @return    Returns the AppInstallationsResponse response from the API call
     */
    public CompletableFuture<AppInstallationsResponse> appsGetInstallationAsync(
            final int installationId) {
        try { 
            return prepareAppsGetInstallationRequest(installationId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsGetInstallation.
     */
    private ApiCall<AppInstallationsResponse, ApiException> prepareAppsGetInstallationRequest(
            final int installationId) throws IOException {
        return new ApiCall.Builder<AppInstallationsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/app/installations/{installation_id}")
                        .templateParam(param -> param.key("installation_id").value(installationId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, AppInstallationsResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new AppInstallations404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Uninstalls a GitHub App on a user, organization, or business account. If you prefer to
     * temporarily suspend an app's access to your account's resources, then we recommend the
     * "[Suspend an app
     * installation](https://docs.github.com/rest/reference/apps/#suspend-an-app-installation)"
     * endpoint. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void appsDeleteInstallation(
            final int installationId) throws ApiException, IOException {
        prepareAppsDeleteInstallationRequest(installationId).execute();
    }

    /**
     * Uninstalls a GitHub App on a user, organization, or business account. If you prefer to
     * temporarily suspend an app's access to your account's resources, then we recommend the
     * "[Suspend an app
     * installation](https://docs.github.com/rest/reference/apps/#suspend-an-app-installation)"
     * endpoint. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> appsDeleteInstallationAsync(
            final int installationId) {
        try { 
            return prepareAppsDeleteInstallationRequest(installationId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsDeleteInstallation.
     */
    private ApiCall<Void, ApiException> prepareAppsDeleteInstallationRequest(
            final int installationId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/app/installations/{installation_id}")
                        .templateParam(param -> param.key("installation_id").value(installationId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new AppInstallations404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates an installation access token that enables a GitHub App to make authenticated API
     * requests for the app's installation on an organization or individual account. Installation
     * tokens expire one hour from the time you create them. Using an expired token produces a
     * status code of `401 - Unauthorized`, and requires creating a new installation token. By
     * default the installation token has access to all repositories that the installation can
     * access. To restrict the access to specific repositories, you can provide the `repository_ids`
     * when creating the token. When you omit `repository_ids`, the response does not contain the
     * `repositories` key. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @param  body  Optional parameter: Example:
     * @return    Returns the AppInstallationsAccessTokensResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AppInstallationsAccessTokensResponse appsCreateInstallationAccessToken(
            final int installationId,
            final AppInstallationsAccessTokensRequest body) throws ApiException, IOException {
        return prepareAppsCreateInstallationAccessTokenRequest(installationId, body).execute();
    }

    /**
     * Creates an installation access token that enables a GitHub App to make authenticated API
     * requests for the app's installation on an organization or individual account. Installation
     * tokens expire one hour from the time you create them. Using an expired token produces a
     * status code of `401 - Unauthorized`, and requires creating a new installation token. By
     * default the installation token has access to all repositories that the installation can
     * access. To restrict the access to specific repositories, you can provide the `repository_ids`
     * when creating the token. When you omit `repository_ids`, the response does not contain the
     * `repositories` key. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @param  body  Optional parameter: Example:
     * @return    Returns the AppInstallationsAccessTokensResponse response from the API call
     */
    public CompletableFuture<AppInstallationsAccessTokensResponse> appsCreateInstallationAccessTokenAsync(
            final int installationId,
            final AppInstallationsAccessTokensRequest body) {
        try { 
            return prepareAppsCreateInstallationAccessTokenRequest(installationId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsCreateInstallationAccessToken.
     */
    private ApiCall<AppInstallationsAccessTokensResponse, ApiException> prepareAppsCreateInstallationAccessTokenRequest(
            final int installationId,
            final AppInstallationsAccessTokensRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<AppInstallationsAccessTokensResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/app/installations/{installation_id}/access_tokens")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("installation_id").value(installationId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, AppInstallationsAccessTokensResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new AppInstallationsAccessTokens401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new AppInstallationsAccessTokens403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new AppInstallationsAccessTokens404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new AppInstallationsAccessTokens422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Suspends a GitHub App on a user, organization, or business account, which blocks the app from
     * accessing the account's resources. When a GitHub App is suspended, the app's access to the
     * GitHub API or webhook events is blocked for that account. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void appsSuspendInstallation(
            final int installationId) throws ApiException, IOException {
        prepareAppsSuspendInstallationRequest(installationId).execute();
    }

    /**
     * Suspends a GitHub App on a user, organization, or business account, which blocks the app from
     * accessing the account's resources. When a GitHub App is suspended, the app's access to the
     * GitHub API or webhook events is blocked for that account. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> appsSuspendInstallationAsync(
            final int installationId) {
        try { 
            return prepareAppsSuspendInstallationRequest(installationId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsSuspendInstallation.
     */
    private ApiCall<Void, ApiException> prepareAppsSuspendInstallationRequest(
            final int installationId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/app/installations/{installation_id}/suspended")
                        .templateParam(param -> param.key("installation_id").value(installationId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new AppInstallationsSuspended404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes a GitHub App installation suspension. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void appsUnsuspendInstallation(
            final int installationId) throws ApiException, IOException {
        prepareAppsUnsuspendInstallationRequest(installationId).execute();
    }

    /**
     * Removes a GitHub App installation suspension. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> appsUnsuspendInstallationAsync(
            final int installationId) {
        try { 
            return prepareAppsUnsuspendInstallationRequest(installationId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsUnsuspendInstallation.
     */
    private ApiCall<Void, ApiException> prepareAppsUnsuspendInstallationRequest(
            final int installationId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/app/installations/{installation_id}/suspended")
                        .templateParam(param -> param.key("installation_id").value(installationId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new AppInstallationsSuspended404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * OAuth application owners can revoke a grant for their OAuth application and a specific user.
     * You must use [Basic
     * Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * when accessing this endpoint, using the OAuth application's `client_id` and `client_secret`
     * as the username and password. You must also provide a valid OAuth `access_token` as an input
     * parameter and the grant for the token's owner will be deleted. Deleting an OAuth
     * application's grant will also delete all OAuth tokens associated with the application for the
     * user. Once deleted, the application will have no access to the user's account and will no
     * longer be listed on [the application authorizations settings screen within
     * GitHub](https://github.com/settings/applications#authorized).
     * @param  clientId  Required parameter: The client ID of the GitHub app.
     * @param  contentType  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void appsDeleteAuthorization(
            final String clientId,
            final ContentType3Enum contentType) throws ApiException, IOException {
        prepareAppsDeleteAuthorizationRequest(clientId, contentType).execute();
    }

    /**
     * OAuth application owners can revoke a grant for their OAuth application and a specific user.
     * You must use [Basic
     * Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * when accessing this endpoint, using the OAuth application's `client_id` and `client_secret`
     * as the username and password. You must also provide a valid OAuth `access_token` as an input
     * parameter and the grant for the token's owner will be deleted. Deleting an OAuth
     * application's grant will also delete all OAuth tokens associated with the application for the
     * user. Once deleted, the application will have no access to the user's account and will no
     * longer be listed on [the application authorizations settings screen within
     * GitHub](https://github.com/settings/applications#authorized).
     * @param  clientId  Required parameter: The client ID of the GitHub app.
     * @param  contentType  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> appsDeleteAuthorizationAsync(
            final String clientId,
            final ContentType3Enum contentType) {
        try { 
            return prepareAppsDeleteAuthorizationRequest(clientId, contentType).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsDeleteAuthorization.
     */
    private ApiCall<Void, ApiException> prepareAppsDeleteAuthorizationRequest(
            final String clientId,
            final ContentType3Enum contentType) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/applications/{client_id}/grant")
                        .templateParam(param -> param.key("client_id").value(clientId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value((contentType != null) ? contentType.value() : null).isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ApplicationsGrant422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * OAuth applications can use a special API method for checking OAuth token validity without
     * exceeding the normal rate limits for failed login attempts. Authentication works differently
     * with this particular endpoint. You must use [Basic
     * Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * to use this endpoint, where the username is the OAuth application `client_id` and the
     * password is its `client_secret`. Invalid tokens will return `404 NOT FOUND`.
     * @param  clientId  Required parameter: The client ID of the GitHub app.
     * @param  body  Required parameter: Example:
     * @return    Returns the ApplicationsTokenResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApplicationsTokenResponse appsCheckToken(
            final String clientId,
            final ApplicationsTokenRequest body) throws ApiException, IOException {
        return prepareAppsCheckTokenRequest(clientId, body).execute();
    }

    /**
     * OAuth applications can use a special API method for checking OAuth token validity without
     * exceeding the normal rate limits for failed login attempts. Authentication works differently
     * with this particular endpoint. You must use [Basic
     * Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * to use this endpoint, where the username is the OAuth application `client_id` and the
     * password is its `client_secret`. Invalid tokens will return `404 NOT FOUND`.
     * @param  clientId  Required parameter: The client ID of the GitHub app.
     * @param  body  Required parameter: Example:
     * @return    Returns the ApplicationsTokenResponse response from the API call
     */
    public CompletableFuture<ApplicationsTokenResponse> appsCheckTokenAsync(
            final String clientId,
            final ApplicationsTokenRequest body) {
        try { 
            return prepareAppsCheckTokenRequest(clientId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsCheckToken.
     */
    private ApiCall<ApplicationsTokenResponse, ApiException> prepareAppsCheckTokenRequest(
            final String clientId,
            final ApplicationsTokenRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ApplicationsTokenResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/applications/{client_id}/token")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("client_id").value(clientId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ApplicationsTokenResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ApplicationsToken404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ApplicationsToken422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * OAuth applications can use this API method to reset a valid OAuth token without end-user
     * involvement. Applications must save the "token" property in the response because changes take
     * effect immediately. You must use [Basic
     * Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * when accessing this endpoint, using the OAuth application's `client_id` and `client_secret`
     * as the username and password. Invalid tokens will return `404 NOT FOUND`.
     * @param  clientId  Required parameter: The client ID of the GitHub app.
     * @param  body  Required parameter: Example:
     * @return    Returns the ApplicationsTokenResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApplicationsTokenResponse appsResetToken(
            final String clientId,
            final ApplicationsTokenRequest body) throws ApiException, IOException {
        return prepareAppsResetTokenRequest(clientId, body).execute();
    }

    /**
     * OAuth applications can use this API method to reset a valid OAuth token without end-user
     * involvement. Applications must save the "token" property in the response because changes take
     * effect immediately. You must use [Basic
     * Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * when accessing this endpoint, using the OAuth application's `client_id` and `client_secret`
     * as the username and password. Invalid tokens will return `404 NOT FOUND`.
     * @param  clientId  Required parameter: The client ID of the GitHub app.
     * @param  body  Required parameter: Example:
     * @return    Returns the ApplicationsTokenResponse response from the API call
     */
    public CompletableFuture<ApplicationsTokenResponse> appsResetTokenAsync(
            final String clientId,
            final ApplicationsTokenRequest body) {
        try { 
            return prepareAppsResetTokenRequest(clientId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsResetToken.
     */
    private ApiCall<ApplicationsTokenResponse, ApiException> prepareAppsResetTokenRequest(
            final String clientId,
            final ApplicationsTokenRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ApplicationsTokenResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/applications/{client_id}/token")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("client_id").value(clientId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ApplicationsTokenResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ApplicationsToken422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * OAuth application owners can revoke a single token for an OAuth application. You must use
     * [Basic
     * Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * when accessing this endpoint, using the OAuth application's `client_id` and `client_secret`
     * as the username and password.
     * @param  clientId  Required parameter: The client ID of the GitHub app.
     * @param  contentType  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void appsDeleteToken(
            final String clientId,
            final ContentType3Enum contentType) throws ApiException, IOException {
        prepareAppsDeleteTokenRequest(clientId, contentType).execute();
    }

    /**
     * OAuth application owners can revoke a single token for an OAuth application. You must use
     * [Basic
     * Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * when accessing this endpoint, using the OAuth application's `client_id` and `client_secret`
     * as the username and password.
     * @param  clientId  Required parameter: The client ID of the GitHub app.
     * @param  contentType  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> appsDeleteTokenAsync(
            final String clientId,
            final ContentType3Enum contentType) {
        try { 
            return prepareAppsDeleteTokenRequest(clientId, contentType).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsDeleteToken.
     */
    private ApiCall<Void, ApiException> prepareAppsDeleteTokenRequest(
            final String clientId,
            final ContentType3Enum contentType) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/applications/{client_id}/token")
                        .templateParam(param -> param.key("client_id").value(clientId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value((contentType != null) ? contentType.value() : null).isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ApplicationsToken422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Use a non-scoped user-to-server OAuth access token to create a repository scoped and/or
     * permission scoped user-to-server OAuth access token. You can specify which repositories the
     * token can access and which permissions are granted to the token. You must use [Basic
     * Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * when accessing this endpoint, using the OAuth application's `client_id` and `client_secret`
     * as the username and password. Invalid tokens will return `404 NOT FOUND`.
     * @param  clientId  Required parameter: The client ID of the GitHub app.
     * @param  body  Required parameter: Example:
     * @return    Returns the ApplicationsTokenScopedResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ApplicationsTokenScopedResponse appsScopeToken(
            final String clientId,
            final ApplicationsTokenScopedRequest body) throws ApiException, IOException {
        return prepareAppsScopeTokenRequest(clientId, body).execute();
    }

    /**
     * Use a non-scoped user-to-server OAuth access token to create a repository scoped and/or
     * permission scoped user-to-server OAuth access token. You can specify which repositories the
     * token can access and which permissions are granted to the token. You must use [Basic
     * Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * when accessing this endpoint, using the OAuth application's `client_id` and `client_secret`
     * as the username and password. Invalid tokens will return `404 NOT FOUND`.
     * @param  clientId  Required parameter: The client ID of the GitHub app.
     * @param  body  Required parameter: Example:
     * @return    Returns the ApplicationsTokenScopedResponse response from the API call
     */
    public CompletableFuture<ApplicationsTokenScopedResponse> appsScopeTokenAsync(
            final String clientId,
            final ApplicationsTokenScopedRequest body) {
        try { 
            return prepareAppsScopeTokenRequest(clientId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsScopeToken.
     */
    private ApiCall<ApplicationsTokenScopedResponse, ApiException> prepareAppsScopeTokenRequest(
            final String clientId,
            final ApplicationsTokenScopedRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ApplicationsTokenScopedResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/applications/{client_id}/token/scoped")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("client_id").value(clientId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ApplicationsTokenScopedResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new ApplicationsTokenScoped401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ApplicationsTokenScoped403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ApplicationsTokenScoped404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ApplicationsTokenScoped422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * **Note**: The `:app_slug` is just the URL-friendly name of your GitHub App. You can find this
     * on the settings page for your GitHub App (e.g.,
     * `https://github.com/settings/apps/:app_slug`). If the GitHub App you specify is public, you
     * can access this endpoint without authenticating. If the GitHub App you specify is private,
     * you must authenticate with a [personal access
     * token](https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line/)
     * or an [installation access
     * token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
     * to access this endpoint.
     * @param  appSlug  Required parameter: Example:
     * @return    Returns the AppsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AppsResponse appsGetBySlug(
            final String appSlug) throws ApiException, IOException {
        return prepareAppsGetBySlugRequest(appSlug).execute();
    }

    /**
     * **Note**: The `:app_slug` is just the URL-friendly name of your GitHub App. You can find this
     * on the settings page for your GitHub App (e.g.,
     * `https://github.com/settings/apps/:app_slug`). If the GitHub App you specify is public, you
     * can access this endpoint without authenticating. If the GitHub App you specify is private,
     * you must authenticate with a [personal access
     * token](https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line/)
     * or an [installation access
     * token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
     * to access this endpoint.
     * @param  appSlug  Required parameter: Example:
     * @return    Returns the AppsResponse response from the API call
     */
    public CompletableFuture<AppsResponse> appsGetBySlugAsync(
            final String appSlug) {
        try { 
            return prepareAppsGetBySlugRequest(appSlug).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsGetBySlug.
     */
    private ApiCall<AppsResponse, ApiException> prepareAppsGetBySlugRequest(
            final String appSlug) throws IOException {
        return new ApiCall.Builder<AppsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/apps/{app_slug}")
                        .templateParam(param -> param.key("app_slug").value(appSlug)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, AppsResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new Apps403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new Apps404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List repositories that an app installation can access. You must use an [installation access
     * token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
     * to access this endpoint.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the InstallationRepositoriesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public InstallationRepositoriesResponse appsListReposAccessibleToInstallation(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareAppsListReposAccessibleToInstallationRequest(perPage, page).execute();
    }

    /**
     * List repositories that an app installation can access. You must use an [installation access
     * token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
     * to access this endpoint.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the InstallationRepositoriesResponse response from the API call
     */
    public CompletableFuture<InstallationRepositoriesResponse> appsListReposAccessibleToInstallationAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareAppsListReposAccessibleToInstallationRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsListReposAccessibleToInstallation.
     */
    private ApiCall<InstallationRepositoriesResponse, ApiException> prepareAppsListReposAccessibleToInstallationRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<InstallationRepositoriesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/installation/repositories")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, InstallationRepositoriesResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new InstallationRepositories401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new InstallationRepositories403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Revokes the installation token you're using to authenticate as an installation and access
     * this endpoint. Once an installation token is revoked, the token is invalidated and cannot be
     * used. Other endpoints that require the revoked installation token must have a new
     * installation token to work. You can create a new token using the "[Create an installation
     * access token for an
     * app](https://docs.github.com/rest/reference/apps#create-an-installation-access-token-for-an-app)"
     * endpoint. You must use an [installation access
     * token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
     * to access this endpoint.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void appsRevokeInstallationAccessToken() throws ApiException, IOException {
        prepareAppsRevokeInstallationAccessTokenRequest().execute();
    }

    /**
     * Revokes the installation token you're using to authenticate as an installation and access
     * this endpoint. Once an installation token is revoked, the token is invalidated and cannot be
     * used. Other endpoints that require the revoked installation token must have a new
     * installation token to work. You can create a new token using the "[Create an installation
     * access token for an
     * app](https://docs.github.com/rest/reference/apps#create-an-installation-access-token-for-an-app)"
     * endpoint. You must use an [installation access
     * token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation)
     * to access this endpoint.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> appsRevokeInstallationAccessTokenAsync() {
        try { 
            return prepareAppsRevokeInstallationAccessTokenRequest().executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsRevokeInstallationAccessToken.
     */
    private ApiCall<Void, ApiException> prepareAppsRevokeInstallationAccessTokenRequest() throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/installation/token")
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Shows whether the user or organization account actively subscribes to a plan listed by the
     * authenticated GitHub App. When someone submits a plan change that won't be processed until
     * the end of their billing cycle, you will also see the upcoming pending change. GitHub Apps
     * must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint. OAuth Apps must use [basic
     * authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * with their client ID and client secret to access this endpoint.
     * @param  accountId  Required parameter: account_id parameter
     * @return    Returns the MarketplaceListingAccountsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public MarketplaceListingAccountsResponse appsGetSubscriptionPlanForAccount(
            final int accountId) throws ApiException, IOException {
        return prepareAppsGetSubscriptionPlanForAccountRequest(accountId).execute();
    }

    /**
     * Shows whether the user or organization account actively subscribes to a plan listed by the
     * authenticated GitHub App. When someone submits a plan change that won't be processed until
     * the end of their billing cycle, you will also see the upcoming pending change. GitHub Apps
     * must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint. OAuth Apps must use [basic
     * authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * with their client ID and client secret to access this endpoint.
     * @param  accountId  Required parameter: account_id parameter
     * @return    Returns the MarketplaceListingAccountsResponse response from the API call
     */
    public CompletableFuture<MarketplaceListingAccountsResponse> appsGetSubscriptionPlanForAccountAsync(
            final int accountId) {
        try { 
            return prepareAppsGetSubscriptionPlanForAccountRequest(accountId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsGetSubscriptionPlanForAccount.
     */
    private ApiCall<MarketplaceListingAccountsResponse, ApiException> prepareAppsGetSubscriptionPlanForAccountRequest(
            final int accountId) throws IOException {
        return new ApiCall.Builder<MarketplaceListingAccountsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/marketplace_listing/accounts/{account_id}")
                        .templateParam(param -> param.key("account_id").value(accountId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, MarketplaceListingAccountsResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new MarketplaceListingAccounts401ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Not Found when the account has not purchased the listing",
                                (reason, context) -> new MarketplaceListingAccounts404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all plans that are part of your GitHub Marketplace listing. GitHub Apps must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint. OAuth Apps must use [basic
     * authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * with their client ID and client secret to access this endpoint.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MarketplaceListingPlan response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<MarketplaceListingPlan> appsListPlans(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareAppsListPlansRequest(perPage, page).execute();
    }

    /**
     * Lists all plans that are part of your GitHub Marketplace listing. GitHub Apps must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint. OAuth Apps must use [basic
     * authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * with their client ID and client secret to access this endpoint.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MarketplaceListingPlan response from the API call
     */
    public CompletableFuture<List<MarketplaceListingPlan>> appsListPlansAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareAppsListPlansRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsListPlans.
     */
    private ApiCall<List<MarketplaceListingPlan>, ApiException> prepareAppsListPlansRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<MarketplaceListingPlan>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/marketplace_listing/plans")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        MarketplaceListingPlan[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new MarketplaceListingPlans401ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new MarketplaceListingPlans404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns user and organization accounts associated with the specified plan, including free
     * plans. For per-seat pricing, you see the list of accounts that have purchased the plan,
     * including the number of seats purchased. When someone submits a plan change that won't be
     * processed until the end of their billing cycle, you will also see the upcoming pending
     * change. GitHub Apps must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint. OAuth Apps must use [basic
     * authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * with their client ID and client secret to access this endpoint.
     * @param  planId  Required parameter: The unique identifier of the plan.
     * @param  sort  Optional parameter: The property to sort the results by. `created` means when
     *         the repository was starred. `updated` means when the repository was last pushed to.
     * @param  direction  Optional parameter: To return the oldest accounts first, set to `asc`.
     *         Ignored without the `sort` parameter.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MarketplacePurchase response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<MarketplacePurchase> appsListAccountsForPlan(
            final int planId,
            final Sort1Enum sort,
            final Direction4Enum direction,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareAppsListAccountsForPlanRequest(planId, sort, direction, perPage,
                page).execute();
    }

    /**
     * Returns user and organization accounts associated with the specified plan, including free
     * plans. For per-seat pricing, you see the list of accounts that have purchased the plan,
     * including the number of seats purchased. When someone submits a plan change that won't be
     * processed until the end of their billing cycle, you will also see the upcoming pending
     * change. GitHub Apps must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint. OAuth Apps must use [basic
     * authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * with their client ID and client secret to access this endpoint.
     * @param  planId  Required parameter: The unique identifier of the plan.
     * @param  sort  Optional parameter: The property to sort the results by. `created` means when
     *         the repository was starred. `updated` means when the repository was last pushed to.
     * @param  direction  Optional parameter: To return the oldest accounts first, set to `asc`.
     *         Ignored without the `sort` parameter.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MarketplacePurchase response from the API call
     */
    public CompletableFuture<List<MarketplacePurchase>> appsListAccountsForPlanAsync(
            final int planId,
            final Sort1Enum sort,
            final Direction4Enum direction,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareAppsListAccountsForPlanRequest(planId, sort, direction, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsListAccountsForPlan.
     */
    private ApiCall<List<MarketplacePurchase>, ApiException> prepareAppsListAccountsForPlanRequest(
            final int planId,
            final Sort1Enum sort,
            final Direction4Enum direction,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<MarketplacePurchase>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/marketplace_listing/plans/{plan_id}/accounts")
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("plan_id").value(planId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        MarketplacePurchase[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new MarketplaceListingPlansAccounts401ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new MarketplaceListingPlansAccounts404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new MarketplaceListingPlansAccounts422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Shows whether the user or organization account actively subscribes to a plan listed by the
     * authenticated GitHub App. When someone submits a plan change that won't be processed until
     * the end of their billing cycle, you will also see the upcoming pending change. GitHub Apps
     * must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint. OAuth Apps must use [basic
     * authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * with their client ID and client secret to access this endpoint.
     * @param  accountId  Required parameter: account_id parameter
     * @return    Returns the MarketplaceListingStubbedAccountsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public MarketplaceListingStubbedAccountsResponse appsGetSubscriptionPlanForAccountStubbed(
            final int accountId) throws ApiException, IOException {
        return prepareAppsGetSubscriptionPlanForAccountStubbedRequest(accountId).execute();
    }

    /**
     * Shows whether the user or organization account actively subscribes to a plan listed by the
     * authenticated GitHub App. When someone submits a plan change that won't be processed until
     * the end of their billing cycle, you will also see the upcoming pending change. GitHub Apps
     * must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint. OAuth Apps must use [basic
     * authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * with their client ID and client secret to access this endpoint.
     * @param  accountId  Required parameter: account_id parameter
     * @return    Returns the MarketplaceListingStubbedAccountsResponse response from the API call
     */
    public CompletableFuture<MarketplaceListingStubbedAccountsResponse> appsGetSubscriptionPlanForAccountStubbedAsync(
            final int accountId) {
        try { 
            return prepareAppsGetSubscriptionPlanForAccountStubbedRequest(accountId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsGetSubscriptionPlanForAccountStubbed.
     */
    private ApiCall<MarketplaceListingStubbedAccountsResponse, ApiException> prepareAppsGetSubscriptionPlanForAccountStubbedRequest(
            final int accountId) throws IOException {
        return new ApiCall.Builder<MarketplaceListingStubbedAccountsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/marketplace_listing/stubbed/accounts/{account_id}")
                        .templateParam(param -> param.key("account_id").value(accountId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, MarketplaceListingStubbedAccountsResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new MarketplaceListingStubbedAccounts401ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Not Found when the account has not purchased the listing",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all plans that are part of your GitHub Marketplace listing. GitHub Apps must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint. OAuth Apps must use [basic
     * authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * with their client ID and client secret to access this endpoint.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MarketplaceListingPlan response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<MarketplaceListingPlan> appsListPlansStubbed(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareAppsListPlansStubbedRequest(perPage, page).execute();
    }

    /**
     * Lists all plans that are part of your GitHub Marketplace listing. GitHub Apps must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint. OAuth Apps must use [basic
     * authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * with their client ID and client secret to access this endpoint.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MarketplaceListingPlan response from the API call
     */
    public CompletableFuture<List<MarketplaceListingPlan>> appsListPlansStubbedAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareAppsListPlansStubbedRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsListPlansStubbed.
     */
    private ApiCall<List<MarketplaceListingPlan>, ApiException> prepareAppsListPlansStubbedRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<MarketplaceListingPlan>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/marketplace_listing/stubbed/plans")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        MarketplaceListingPlan[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new MarketplaceListingStubbedPlans401ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns repository and organization accounts associated with the specified plan, including
     * free plans. For per-seat pricing, you see the list of accounts that have purchased the plan,
     * including the number of seats purchased. When someone submits a plan change that won't be
     * processed until the end of their billing cycle, you will also see the upcoming pending
     * change. GitHub Apps must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint. OAuth Apps must use [basic
     * authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * with their client ID and client secret to access this endpoint.
     * @param  planId  Required parameter: The unique identifier of the plan.
     * @param  sort  Optional parameter: The property to sort the results by. `created` means when
     *         the repository was starred. `updated` means when the repository was last pushed to.
     * @param  direction  Optional parameter: To return the oldest accounts first, set to `asc`.
     *         Ignored without the `sort` parameter.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MarketplacePurchase response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<MarketplacePurchase> appsListAccountsForPlanStubbed(
            final int planId,
            final Sort1Enum sort,
            final Direction4Enum direction,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareAppsListAccountsForPlanStubbedRequest(planId, sort, direction, perPage,
                page).execute();
    }

    /**
     * Returns repository and organization accounts associated with the specified plan, including
     * free plans. For per-seat pricing, you see the list of accounts that have purchased the plan,
     * including the number of seats purchased. When someone submits a plan change that won't be
     * processed until the end of their billing cycle, you will also see the upcoming pending
     * change. GitHub Apps must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint. OAuth Apps must use [basic
     * authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * with their client ID and client secret to access this endpoint.
     * @param  planId  Required parameter: The unique identifier of the plan.
     * @param  sort  Optional parameter: The property to sort the results by. `created` means when
     *         the repository was starred. `updated` means when the repository was last pushed to.
     * @param  direction  Optional parameter: To return the oldest accounts first, set to `asc`.
     *         Ignored without the `sort` parameter.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MarketplacePurchase response from the API call
     */
    public CompletableFuture<List<MarketplacePurchase>> appsListAccountsForPlanStubbedAsync(
            final int planId,
            final Sort1Enum sort,
            final Direction4Enum direction,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareAppsListAccountsForPlanStubbedRequest(planId, sort, direction, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsListAccountsForPlanStubbed.
     */
    private ApiCall<List<MarketplacePurchase>, ApiException> prepareAppsListAccountsForPlanStubbedRequest(
            final int planId,
            final Sort1Enum sort,
            final Direction4Enum direction,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<MarketplacePurchase>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/marketplace_listing/stubbed/plans/{plan_id}/accounts")
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("plan_id").value(planId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        MarketplacePurchase[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new MarketplaceListingStubbedPlansAccounts401ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Enables an authenticated GitHub App to find the organization's installation information. You
     * must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the OrgsInstallationResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsInstallationResponse appsGetOrgInstallation(
            final String org) throws ApiException, IOException {
        return prepareAppsGetOrgInstallationRequest(org).execute();
    }

    /**
     * Enables an authenticated GitHub App to find the organization's installation information. You
     * must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the OrgsInstallationResponse response from the API call
     */
    public CompletableFuture<OrgsInstallationResponse> appsGetOrgInstallationAsync(
            final String org) {
        try { 
            return prepareAppsGetOrgInstallationRequest(org).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsGetOrgInstallation.
     */
    private ApiCall<OrgsInstallationResponse, ApiException> prepareAppsGetOrgInstallationRequest(
            final String org) throws IOException {
        return new ApiCall.Builder<OrgsInstallationResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/installation")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsInstallationResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Enables an authenticated GitHub App to find the repository's installation information. The
     * installation's account type will be either an organization or a user account, depending which
     * account the repository belongs to. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposInstallationResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposInstallationResponse appsGetRepoInstallation(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareAppsGetRepoInstallationRequest(owner, repo).execute();
    }

    /**
     * Enables an authenticated GitHub App to find the repository's installation information. The
     * installation's account type will be either an organization or a user account, depending which
     * account the repository belongs to. You must use a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposInstallationResponse response from the API call
     */
    public CompletableFuture<ReposInstallationResponse> appsGetRepoInstallationAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareAppsGetRepoInstallationRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsGetRepoInstallation.
     */
    private ApiCall<ReposInstallationResponse, ApiException> prepareAppsGetRepoInstallationRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposInstallationResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/installation")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposInstallationResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposInstallation404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists installations of your GitHub App that the authenticated user has explicit permission
     * (`:read`, `:write`, or `:admin`) to access. You must use a [user-to-server OAuth access
     * token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site),
     * created for a user who has authorized your GitHub App, to access this endpoint. The
     * authenticated user has explicit permission to access repositories they own, repositories
     * where they are a collaborator, and repositories that they can access through an organization
     * membership. You can find the permissions for the installation under the `permissions` key.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsInstallationsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsInstallationsResponse appsListInstallationsForAuthenticatedUser(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareAppsListInstallationsForAuthenticatedUserRequest(perPage, page).execute();
    }

    /**
     * Lists installations of your GitHub App that the authenticated user has explicit permission
     * (`:read`, `:write`, or `:admin`) to access. You must use a [user-to-server OAuth access
     * token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site),
     * created for a user who has authorized your GitHub App, to access this endpoint. The
     * authenticated user has explicit permission to access repositories they own, repositories
     * where they are a collaborator, and repositories that they can access through an organization
     * membership. You can find the permissions for the installation under the `permissions` key.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsInstallationsResponse response from the API call
     */
    public CompletableFuture<OrgsInstallationsResponse> appsListInstallationsForAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareAppsListInstallationsForAuthenticatedUserRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsListInstallationsForAuthenticatedUser.
     */
    private ApiCall<OrgsInstallationsResponse, ApiException> prepareAppsListInstallationsForAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<OrgsInstallationsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/installations")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsInstallationsResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserInstallations401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserInstallations403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List repositories that the authenticated user has explicit permission (`:read`, `:write`, or
     * `:admin`) to access for an installation. The authenticated user has explicit permission to
     * access repositories they own, repositories where they are a collaborator, and repositories
     * that they can access through an organization membership. You must use a [user-to-server OAuth
     * access
     * token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site),
     * created for a user who has authorized your GitHub App, to access this endpoint. The access
     * the user has to each repository is included in the hash under the `permissions` key.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the InstallationRepositoriesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public InstallationRepositoriesResponse appsListInstallationReposForAuthenticatedUser(
            final int installationId,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareAppsListInstallationReposForAuthenticatedUserRequest(installationId, perPage,
                page).execute();
    }

    /**
     * List repositories that the authenticated user has explicit permission (`:read`, `:write`, or
     * `:admin`) to access for an installation. The authenticated user has explicit permission to
     * access repositories they own, repositories where they are a collaborator, and repositories
     * that they can access through an organization membership. You must use a [user-to-server OAuth
     * access
     * token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site),
     * created for a user who has authorized your GitHub App, to access this endpoint. The access
     * the user has to each repository is included in the hash under the `permissions` key.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the InstallationRepositoriesResponse response from the API call
     */
    public CompletableFuture<InstallationRepositoriesResponse> appsListInstallationReposForAuthenticatedUserAsync(
            final int installationId,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareAppsListInstallationReposForAuthenticatedUserRequest(installationId, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsListInstallationReposForAuthenticatedUser.
     */
    private ApiCall<InstallationRepositoriesResponse, ApiException> prepareAppsListInstallationReposForAuthenticatedUserRequest(
            final int installationId,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<InstallationRepositoriesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/installations/{installation_id}/repositories")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("installation_id").value(installationId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, InstallationRepositoriesResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserInstallationsRepositories403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserInstallationsRepositories404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Add a single repository to an installation. The authenticated user must have admin access to
     * the repository. You must use a personal access token (which you can create via the [command
     * line](https://docs.github.com/github/authenticating-to-github/creating-a-personal-access-token)
     * or [Basic
     * Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication))
     * to access this endpoint.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void appsAddRepoToInstallationForAuthenticatedUser(
            final int installationId,
            final int repositoryId) throws ApiException, IOException {
        prepareAppsAddRepoToInstallationForAuthenticatedUserRequest(installationId,
                repositoryId).execute();
    }

    /**
     * Add a single repository to an installation. The authenticated user must have admin access to
     * the repository. You must use a personal access token (which you can create via the [command
     * line](https://docs.github.com/github/authenticating-to-github/creating-a-personal-access-token)
     * or [Basic
     * Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication))
     * to access this endpoint.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> appsAddRepoToInstallationForAuthenticatedUserAsync(
            final int installationId,
            final int repositoryId) {
        try { 
            return prepareAppsAddRepoToInstallationForAuthenticatedUserRequest(installationId,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsAddRepoToInstallationForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareAppsAddRepoToInstallationForAuthenticatedUserRequest(
            final int installationId,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/installations/{installation_id}/repositories/{repository_id}")
                        .templateParam(param -> param.key("installation_id").value(installationId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserInstallationsRepositories403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserInstallationsRepositories404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Remove a single repository from an installation. The authenticated user must have admin
     * access to the repository. You must use a personal access token (which you can create via the
     * [command
     * line](https://docs.github.com/github/authenticating-to-github/creating-a-personal-access-token)
     * or [Basic
     * Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication))
     * to access this endpoint.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void appsRemoveRepoFromInstallationForAuthenticatedUser(
            final int installationId,
            final int repositoryId) throws ApiException, IOException {
        prepareAppsRemoveRepoFromInstallationForAuthenticatedUserRequest(installationId,
                repositoryId).execute();
    }

    /**
     * Remove a single repository from an installation. The authenticated user must have admin
     * access to the repository. You must use a personal access token (which you can create via the
     * [command
     * line](https://docs.github.com/github/authenticating-to-github/creating-a-personal-access-token)
     * or [Basic
     * Authentication](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication))
     * to access this endpoint.
     * @param  installationId  Required parameter: The unique identifier of the installation.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> appsRemoveRepoFromInstallationForAuthenticatedUserAsync(
            final int installationId,
            final int repositoryId) {
        try { 
            return prepareAppsRemoveRepoFromInstallationForAuthenticatedUserRequest(installationId,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsRemoveRepoFromInstallationForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareAppsRemoveRepoFromInstallationForAuthenticatedUserRequest(
            final int installationId,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/installations/{installation_id}/repositories/{repository_id}")
                        .templateParam(param -> param.key("installation_id").value(installationId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserInstallationsRepositories403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserInstallationsRepositories404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the active subscriptions for the authenticated user. You must use a [user-to-server
     * OAuth access
     * token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site),
     * created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps
     * must authenticate using an [OAuth
     * token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of UserMarketplacePurchase response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<UserMarketplacePurchase> appsListSubscriptionsForAuthenticatedUser(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareAppsListSubscriptionsForAuthenticatedUserRequest(perPage, page).execute();
    }

    /**
     * Lists the active subscriptions for the authenticated user. You must use a [user-to-server
     * OAuth access
     * token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site),
     * created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps
     * must authenticate using an [OAuth
     * token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of UserMarketplacePurchase response from the API call
     */
    public CompletableFuture<List<UserMarketplacePurchase>> appsListSubscriptionsForAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareAppsListSubscriptionsForAuthenticatedUserRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsListSubscriptionsForAuthenticatedUser.
     */
    private ApiCall<List<UserMarketplacePurchase>, ApiException> prepareAppsListSubscriptionsForAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<UserMarketplacePurchase>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/marketplace_purchases")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        UserMarketplacePurchase[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserMarketplacePurchases401ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserMarketplacePurchases404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the active subscriptions for the authenticated user. You must use a [user-to-server
     * OAuth access
     * token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site),
     * created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps
     * must authenticate using an [OAuth
     * token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of UserMarketplacePurchase response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<UserMarketplacePurchase> appsListSubscriptionsForAuthenticatedUserStubbed(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareAppsListSubscriptionsForAuthenticatedUserStubbedRequest(perPage,
                page).execute();
    }

    /**
     * Lists the active subscriptions for the authenticated user. You must use a [user-to-server
     * OAuth access
     * token](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site),
     * created for a user who has authorized your GitHub App, to access this endpoint. . OAuth Apps
     * must authenticate using an [OAuth
     * token](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/).
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of UserMarketplacePurchase response from the API call
     */
    public CompletableFuture<List<UserMarketplacePurchase>> appsListSubscriptionsForAuthenticatedUserStubbedAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareAppsListSubscriptionsForAuthenticatedUserStubbedRequest(perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsListSubscriptionsForAuthenticatedUserStubbed.
     */
    private ApiCall<List<UserMarketplacePurchase>, ApiException> prepareAppsListSubscriptionsForAuthenticatedUserStubbedRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<UserMarketplacePurchase>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/marketplace_purchases/stubbed")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        UserMarketplacePurchase[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserMarketplacePurchasesStubbed401ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Enables an authenticated GitHub App to find the users installation information. You must use
     * a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the UsersInstallationResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UsersInstallationResponse appsGetUserInstallation(
            final String username) throws ApiException, IOException {
        return prepareAppsGetUserInstallationRequest(username).execute();
    }

    /**
     * Enables an authenticated GitHub App to find the users installation information. You must use
     * a
     * [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app)
     * to access this endpoint.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the UsersInstallationResponse response from the API call
     */
    public CompletableFuture<UsersInstallationResponse> appsGetUserInstallationAsync(
            final String username) {
        try { 
            return prepareAppsGetUserInstallationRequest(username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for appsGetUserInstallation.
     */
    private ApiCall<UsersInstallationResponse, ApiException> prepareAppsGetUserInstallationRequest(
            final String username) throws IOException {
        return new ApiCall.Builder<UsersInstallationResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/installation")
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UsersInstallationResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}