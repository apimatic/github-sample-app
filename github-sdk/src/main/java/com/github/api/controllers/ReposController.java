/*
 * GitHubAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.github.api.controllers;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.github.api.ApiHelper;
import com.github.api.DateTimeHelper;
import com.github.api.Server;
import com.github.api.exceptions.*;
import com.github.api.http.request.HttpMethod;
import com.github.api.models.*;
import com.github.api.models.containers.ReposAddAppAccessRestrictionsBody;
import com.github.api.models.containers.ReposAddStatusCheckContextsBody;
import com.github.api.models.containers.ReposAddTeamAccessRestrictionsBody;
import com.github.api.models.containers.ReposAddUserAccessRestrictionsBody;
import com.github.api.models.containers.ReposGetContentResponse;
import com.github.api.models.containers.ReposSetAppAccessRestrictionsBody;
import com.github.api.models.containers.ReposSetStatusCheckContextsBody;
import com.github.api.models.containers.ReposSetTeamAccessRestrictionsBody;
import com.github.api.models.containers.ReposSetUserAccessRestrictionsBody;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;

/**
 * This class lists all the endpoints of the groups.
 */
public final class ReposController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public ReposController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Lists repositories for the specified organization. **Note:** In order to see the
     * `security_and_analysis` block for a repository you must have admin permissions for the
     * repository or be an owner or security manager for the organization that owns the repository.
     * For more information, see "[Managing security managers in your
     * organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  type  Optional parameter: Specifies the types of repositories you want returned.
     * @param  sort  Optional parameter: The property to sort the results by.
     * @param  direction  Optional parameter: The order to sort by. Default: `asc` when using
     *         `full_name`, otherwise `desc`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MinimalRepository response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<MinimalRepository> reposListForOrg(
            final String org,
            final Type6121Enum type,
            final Sort61Enum sort,
            final Direction21Enum direction,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListForOrgRequest(org, type, sort, direction, perPage, page).execute();
    }

    /**
     * Lists repositories for the specified organization. **Note:** In order to see the
     * `security_and_analysis` block for a repository you must have admin permissions for the
     * repository or be an owner or security manager for the organization that owns the repository.
     * For more information, see "[Managing security managers in your
     * organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  type  Optional parameter: Specifies the types of repositories you want returned.
     * @param  sort  Optional parameter: The property to sort the results by.
     * @param  direction  Optional parameter: The order to sort by. Default: `asc` when using
     *         `full_name`, otherwise `desc`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MinimalRepository response from the API call
     */
    public CompletableFuture<List<MinimalRepository>> reposListForOrgAsync(
            final String org,
            final Type6121Enum type,
            final Sort61Enum sort,
            final Direction21Enum direction,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListForOrgRequest(org, type, sort, direction, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListForOrg.
     */
    private ApiCall<List<MinimalRepository>, ApiException> prepareReposListForOrgRequest(
            final String org,
            final Type6121Enum type,
            final Sort61Enum sort,
            final Direction21Enum direction,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<MinimalRepository>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/repos")
                        .queryParam(param -> param.key("type")
                                .value((type != null) ? type.value() : null).isRequired(false))
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        MinimalRepository[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates a new repository in the specified organization. The authenticated user must be a
     * member of the organization. **OAuth scope requirements** When using
     * [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/),
     * authorizations must include: * `public_repo` scope or `repo` scope to create a public
     * repository. Note: For GitHub AE, use `repo` scope to create an internal repository. * `repo`
     * scope to create a private repository.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the OrgsReposResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsReposResponse reposCreateInOrg(
            final String org,
            final OrgsReposRequest body) throws ApiException, IOException {
        return prepareReposCreateInOrgRequest(org, body).execute();
    }

    /**
     * Creates a new repository in the specified organization. The authenticated user must be a
     * member of the organization. **OAuth scope requirements** When using
     * [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/),
     * authorizations must include: * `public_repo` scope or `repo` scope to create a public
     * repository. Note: For GitHub AE, use `repo` scope to create an internal repository. * `repo`
     * scope to create a private repository.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the OrgsReposResponse response from the API call
     */
    public CompletableFuture<OrgsReposResponse> reposCreateInOrgAsync(
            final String org,
            final OrgsReposRequest body) {
        try { 
            return prepareReposCreateInOrgRequest(org, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateInOrg.
     */
    private ApiCall<OrgsReposResponse, ApiException> prepareReposCreateInOrgRequest(
            final String org,
            final OrgsReposRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<OrgsReposResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/repos")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsReposResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new OrgsRepos403ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new OrgsRepos422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * The `parent` and `source` objects are present when the repository is a fork. `parent` is the
     * repository this repository was forked from, `source` is the ultimate source for the network.
     * **Note:** In order to see the `security_and_analysis` block for a repository you must have
     * admin permissions for the repository or be an owner or security manager for the organization
     * that owns the repository. For more information, see "[Managing security managers in your
     * organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposResponse reposGet(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposGetRequest(owner, repo).execute();
    }

    /**
     * The `parent` and `source` objects are present when the repository is a fork. `parent` is the
     * repository this repository was forked from, `source` is the ultimate source for the network.
     * **Note:** In order to see the `security_and_analysis` block for a repository you must have
     * admin permissions for the repository or be an owner or security manager for the organization
     * that owns the repository. For more information, see "[Managing security managers in your
     * organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposResponse response from the API call
     */
    public CompletableFuture<ReposResponse> reposGetAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposGetRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGet.
     */
    private ApiCall<ReposResponse, ApiException> prepareReposGetRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new Repos403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new Repos404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * **Note**: To edit a repository's topics, use the [Replace all repository
     * topics](https://docs.github.com/rest/reference/repos#replace-all-repository-topics) endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposResponse reposUpdate(
            final String owner,
            final String repo,
            final ReposRequest body) throws ApiException, IOException {
        return prepareReposUpdateRequest(owner, repo, body).execute();
    }

    /**
     * **Note**: To edit a repository's topics, use the [Replace all repository
     * topics](https://docs.github.com/rest/reference/repos#replace-all-repository-topics) endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposResponse response from the API call
     */
    public CompletableFuture<ReposResponse> reposUpdateAsync(
            final String owner,
            final String repo,
            final ReposRequest body) {
        try { 
            return prepareReposUpdateRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposUpdate.
     */
    private ApiCall<ReposResponse, ApiException> prepareReposUpdateRequest(
            final String owner,
            final String repo,
            final ReposRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new Repos403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new Repos404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new Repos422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deleting a repository requires admin access. If OAuth is used, the `delete_repo` scope is
     * required. If an organization owner has configured the organization to prevent members from
     * deleting organization-owned repositories, you will get a `403 Forbidden` response.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDelete(
            final String owner,
            final String repo) throws ApiException, IOException {
        prepareReposDeleteRequest(owner, repo).execute();
    }

    /**
     * Deleting a repository requires admin access. If OAuth is used, the `delete_repo` scope is
     * required. If an organization owner has configured the organization to prevent members from
     * deleting organization-owned repositories, you will get a `403 Forbidden` response.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposDeleteRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDelete.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("If an organization owner has configured the organization to prevent members from deleting organization-owned repositories, a member will get this response:",
                                (reason, context) -> new Repos403Error4Exception(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new Repos404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This returns a list of autolinks configured for the given repository. Information about
     * autolinks are only available to repository administrators.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Autolinkreference response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Autolinkreference> reposListAutolinks(
            final String owner,
            final String repo,
            final Integer page) throws ApiException, IOException {
        return prepareReposListAutolinksRequest(owner, repo, page).execute();
    }

    /**
     * This returns a list of autolinks configured for the given repository. Information about
     * autolinks are only available to repository administrators.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Autolinkreference response from the API call
     */
    public CompletableFuture<List<Autolinkreference>> reposListAutolinksAsync(
            final String owner,
            final String repo,
            final Integer page) {
        try { 
            return prepareReposListAutolinksRequest(owner, repo, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListAutolinks.
     */
    private ApiCall<List<Autolinkreference>, ApiException> prepareReposListAutolinksRequest(
            final String owner,
            final String repo,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Autolinkreference>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/autolinks")
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Autolinkreference[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Users with admin access to the repository can create an autolink.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposAutolinksResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposAutolinksResponse reposCreateAutolink(
            final String owner,
            final String repo,
            final ReposAutolinksRequest body) throws ApiException, IOException {
        return prepareReposCreateAutolinkRequest(owner, repo, body).execute();
    }

    /**
     * Users with admin access to the repository can create an autolink.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposAutolinksResponse response from the API call
     */
    public CompletableFuture<ReposAutolinksResponse> reposCreateAutolinkAsync(
            final String owner,
            final String repo,
            final ReposAutolinksRequest body) {
        try { 
            return prepareReposCreateAutolinkRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateAutolink.
     */
    private ApiCall<ReposAutolinksResponse, ApiException> prepareReposCreateAutolinkRequest(
            final String owner,
            final String repo,
            final ReposAutolinksRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposAutolinksResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/autolinks")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposAutolinksResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposAutolinks422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This returns a single autolink reference by ID that was configured for the given repository.
     * Information about autolinks are only available to repository administrators.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  autolinkId  Required parameter: The unique identifier of the autolink.
     * @return    Returns the ReposAutolinksAutolinkIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposAutolinksAutolinkIdResponse reposGetAutolink(
            final String owner,
            final String repo,
            final int autolinkId) throws ApiException, IOException {
        return prepareReposGetAutolinkRequest(owner, repo, autolinkId).execute();
    }

    /**
     * This returns a single autolink reference by ID that was configured for the given repository.
     * Information about autolinks are only available to repository administrators.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  autolinkId  Required parameter: The unique identifier of the autolink.
     * @return    Returns the ReposAutolinksAutolinkIdResponse response from the API call
     */
    public CompletableFuture<ReposAutolinksAutolinkIdResponse> reposGetAutolinkAsync(
            final String owner,
            final String repo,
            final int autolinkId) {
        try { 
            return prepareReposGetAutolinkRequest(owner, repo, autolinkId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetAutolink.
     */
    private ApiCall<ReposAutolinksAutolinkIdResponse, ApiException> prepareReposGetAutolinkRequest(
            final String owner,
            final String repo,
            final int autolinkId) throws IOException {
        return new ApiCall.Builder<ReposAutolinksAutolinkIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/autolinks/{autolink_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("autolink_id").value(autolinkId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposAutolinksAutolinkIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposAutolinksAutolinkId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This deletes a single autolink reference by ID that was configured for the given repository.
     * Information about autolinks are only available to repository administrators.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  autolinkId  Required parameter: The unique identifier of the autolink.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteAutolink(
            final String owner,
            final String repo,
            final int autolinkId) throws ApiException, IOException {
        prepareReposDeleteAutolinkRequest(owner, repo, autolinkId).execute();
    }

    /**
     * This deletes a single autolink reference by ID that was configured for the given repository.
     * Information about autolinks are only available to repository administrators.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  autolinkId  Required parameter: The unique identifier of the autolink.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteAutolinkAsync(
            final String owner,
            final String repo,
            final int autolinkId) {
        try { 
            return prepareReposDeleteAutolinkRequest(owner, repo, autolinkId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteAutolink.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteAutolinkRequest(
            final String owner,
            final String repo,
            final int autolinkId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/autolinks/{autolink_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("autolink_id").value(autolinkId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposAutolinksAutolinkId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Enables automated security fixes for a repository. The authenticated user must have admin
     * access to the repository. For more information, see "[Configuring automated security
     * fixes](https://docs.github.com/articles/configuring-automated-security-fixes)".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposEnableAutomatedSecurityFixes(
            final String owner,
            final String repo) throws ApiException, IOException {
        prepareReposEnableAutomatedSecurityFixesRequest(owner, repo).execute();
    }

    /**
     * Enables automated security fixes for a repository. The authenticated user must have admin
     * access to the repository. For more information, see "[Configuring automated security
     * fixes](https://docs.github.com/articles/configuring-automated-security-fixes)".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposEnableAutomatedSecurityFixesAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposEnableAutomatedSecurityFixesRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposEnableAutomatedSecurityFixes.
     */
    private ApiCall<Void, ApiException> prepareReposEnableAutomatedSecurityFixesRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/automated-security-fixes")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Disables automated security fixes for a repository. The authenticated user must have admin
     * access to the repository. For more information, see "[Configuring automated security
     * fixes](https://docs.github.com/articles/configuring-automated-security-fixes)".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDisableAutomatedSecurityFixes(
            final String owner,
            final String repo) throws ApiException, IOException {
        prepareReposDisableAutomatedSecurityFixesRequest(owner, repo).execute();
    }

    /**
     * Disables automated security fixes for a repository. The authenticated user must have admin
     * access to the repository. For more information, see "[Configuring automated security
     * fixes](https://docs.github.com/articles/configuring-automated-security-fixes)".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDisableAutomatedSecurityFixesAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposDisableAutomatedSecurityFixesRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDisableAutomatedSecurityFixes.
     */
    private ApiCall<Void, ApiException> prepareReposDisableAutomatedSecurityFixesRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/automated-security-fixes")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List branches.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  mProtected  Optional parameter: Setting to `true` returns only protected branches.
     *         When set to `false`, only unprotected branches are returned. Omitting this parameter
     *         returns all branches.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of ShortBranch response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<ShortBranch> reposListBranches(
            final String owner,
            final String repo,
            final Boolean mProtected,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListBranchesRequest(owner, repo, mProtected, perPage, page).execute();
    }

    /**
     * List branches.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  mProtected  Optional parameter: Setting to `true` returns only protected branches.
     *         When set to `false`, only unprotected branches are returned. Omitting this parameter
     *         returns all branches.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of ShortBranch response from the API call
     */
    public CompletableFuture<List<ShortBranch>> reposListBranchesAsync(
            final String owner,
            final String repo,
            final Boolean mProtected,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListBranchesRequest(owner, repo, mProtected, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListBranches.
     */
    private ApiCall<List<ShortBranch>, ApiException> prepareReposListBranchesRequest(
            final String owner,
            final String repo,
            final Boolean mProtected,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<ShortBranch>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches")
                        .queryParam(param -> param.key("protected")
                                .value(mProtected).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        ShortBranch[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranches404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get a branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the ReposBranchesBranchResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposBranchesBranchResponse reposGetBranch(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        return prepareReposGetBranchRequest(owner, repo, branch).execute();
    }

    /**
     * Get a branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the ReposBranchesBranchResponse response from the API call
     */
    public CompletableFuture<ReposBranchesBranchResponse> reposGetBranchAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposGetBranchRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetBranch.
     */
    private ApiCall<ReposBranchesBranchResponse, ApiException> prepareReposGetBranchRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<ReposBranchesBranchResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposBranchesBranchResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranch404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the ReposBranchesBranchProtectionResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposBranchesBranchProtectionResponse reposGetBranchProtection(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        return prepareReposGetBranchProtectionRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the ReposBranchesBranchProtectionResponse response from the API call
     */
    public CompletableFuture<ReposBranchesBranchProtectionResponse> reposGetBranchProtectionAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposGetBranchProtectionRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetBranchProtection.
     */
    private ApiCall<ReposBranchesBranchProtectionResponse, ApiException> prepareReposGetBranchProtectionRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<ReposBranchesBranchProtectionResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposBranchesBranchProtectionResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtection404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Protecting a branch requires admin or owner permissions to the
     * repository. **Note**: Passing new arrays of `users` and `teams` replaces their previous
     * values. **Note**: The list of users, apps, and teams in total is limited to 100 items.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposBranchesBranchProtectionResponse1 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposBranchesBranchProtectionResponse1 reposUpdateBranchProtection(
            final String owner,
            final String repo,
            final String branch,
            final ReposBranchesBranchProtectionRequest body) throws ApiException, IOException {
        return prepareReposUpdateBranchProtectionRequest(owner, repo, branch, body).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Protecting a branch requires admin or owner permissions to the
     * repository. **Note**: Passing new arrays of `users` and `teams` replaces their previous
     * values. **Note**: The list of users, apps, and teams in total is limited to 100 items.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposBranchesBranchProtectionResponse1 response from the API call
     */
    public CompletableFuture<ReposBranchesBranchProtectionResponse1> reposUpdateBranchProtectionAsync(
            final String owner,
            final String repo,
            final String branch,
            final ReposBranchesBranchProtectionRequest body) {
        try { 
            return prepareReposUpdateBranchProtectionRequest(owner, repo, branch, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposUpdateBranchProtection.
     */
    private ApiCall<ReposBranchesBranchProtectionResponse1, ApiException> prepareReposUpdateBranchProtectionRequest(
            final String owner,
            final String repo,
            final String branch,
            final ReposBranchesBranchProtectionRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposBranchesBranchProtectionResponse1, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposBranchesBranchProtectionResponse1.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposBranchesBranchProtection403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtection404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtection422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteBranchProtection(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        prepareReposDeleteBranchProtectionRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteBranchProtectionAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposDeleteBranchProtectionRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteBranchProtection.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteBranchProtectionRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposBranchesBranchProtection403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the EnforceAdmins response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public EnforceAdmins reposGetAdminBranchProtection(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        return prepareReposGetAdminBranchProtectionRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the EnforceAdmins response from the API call
     */
    public CompletableFuture<EnforceAdmins> reposGetAdminBranchProtectionAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposGetAdminBranchProtectionRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetAdminBranchProtection.
     */
    private ApiCall<EnforceAdmins, ApiException> prepareReposGetAdminBranchProtectionRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<EnforceAdmins, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, EnforceAdmins.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Adding admin enforcement requires admin or owner permissions to
     * the repository and branch protection to be enabled.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the EnforceAdmins response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public EnforceAdmins reposSetAdminBranchProtection(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        return prepareReposSetAdminBranchProtectionRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Adding admin enforcement requires admin or owner permissions to
     * the repository and branch protection to be enabled.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the EnforceAdmins response from the API call
     */
    public CompletableFuture<EnforceAdmins> reposSetAdminBranchProtectionAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposSetAdminBranchProtectionRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposSetAdminBranchProtection.
     */
    private ApiCall<EnforceAdmins, ApiException> prepareReposSetAdminBranchProtectionRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<EnforceAdmins, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, EnforceAdmins.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Removing admin enforcement requires admin or owner permissions to
     * the repository and branch protection to be enabled.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteAdminBranchProtection(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        prepareReposDeleteAdminBranchProtectionRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Removing admin enforcement requires admin or owner permissions to
     * the repository and branch protection to be enabled.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteAdminBranchProtectionAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposDeleteAdminBranchProtectionRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteAdminBranchProtection.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteAdminBranchProtectionRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionEnforceAdmins404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the ReposBranchesBranchProtectionRequiredPullRequestReviewsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposBranchesBranchProtectionRequiredPullRequestReviewsResponse reposGetPullRequestReviewProtection(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        return prepareReposGetPullRequestReviewProtectionRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the ReposBranchesBranchProtectionRequiredPullRequestReviewsResponse response from the API call
     */
    public CompletableFuture<ReposBranchesBranchProtectionRequiredPullRequestReviewsResponse> reposGetPullRequestReviewProtectionAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposGetPullRequestReviewProtectionRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetPullRequestReviewProtection.
     */
    private ApiCall<ReposBranchesBranchProtectionRequiredPullRequestReviewsResponse, ApiException> prepareReposGetPullRequestReviewProtectionRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<ReposBranchesBranchProtectionRequiredPullRequestReviewsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposBranchesBranchProtectionRequiredPullRequestReviewsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Updating pull request review enforcement requires admin or owner
     * permissions to the repository and branch protection to be enabled. **Note**: Passing new
     * arrays of `users` and `teams` replaces their previous values.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposBranchesBranchProtectionRequiredPullRequestReviewsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposBranchesBranchProtectionRequiredPullRequestReviewsResponse reposUpdatePullRequestReviewProtection(
            final String owner,
            final String repo,
            final String branch,
            final ReposBranchesBranchProtectionRequiredPullRequestReviewsRequest body) throws ApiException, IOException {
        return prepareReposUpdatePullRequestReviewProtectionRequest(owner, repo, branch,
                body).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Updating pull request review enforcement requires admin or owner
     * permissions to the repository and branch protection to be enabled. **Note**: Passing new
     * arrays of `users` and `teams` replaces their previous values.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposBranchesBranchProtectionRequiredPullRequestReviewsResponse response from the API call
     */
    public CompletableFuture<ReposBranchesBranchProtectionRequiredPullRequestReviewsResponse> reposUpdatePullRequestReviewProtectionAsync(
            final String owner,
            final String repo,
            final String branch,
            final ReposBranchesBranchProtectionRequiredPullRequestReviewsRequest body) {
        try { 
            return prepareReposUpdatePullRequestReviewProtectionRequest(owner, repo, branch,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposUpdatePullRequestReviewProtection.
     */
    private ApiCall<ReposBranchesBranchProtectionRequiredPullRequestReviewsResponse, ApiException> prepareReposUpdatePullRequestReviewProtectionRequest(
            final String owner,
            final String repo,
            final String branch,
            final ReposBranchesBranchProtectionRequiredPullRequestReviewsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposBranchesBranchProtectionRequiredPullRequestReviewsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposBranchesBranchProtectionRequiredPullRequestReviewsResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredPullRequestReviews422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeletePullRequestReviewProtection(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        prepareReposDeletePullRequestReviewProtectionRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeletePullRequestReviewProtectionAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposDeletePullRequestReviewProtectionRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeletePullRequestReviewProtection.
     */
    private ApiCall<Void, ApiException> prepareReposDeletePullRequestReviewProtectionRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredPullRequestReviews404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. When authenticated with admin or owner permissions to the
     * repository, you can use this endpoint to check whether a branch requires signed commits. An
     * enabled status of `true` indicates you must sign commits on this branch. For more
     * information, see [Signing commits with
     * GPG](https://docs.github.com/articles/signing-commits-with-gpg) in GitHub Help. **Note**: You
     * must enable branch protection to require signed commits.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the EnforceAdmins response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public EnforceAdmins reposGetCommitSignatureProtection(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        return prepareReposGetCommitSignatureProtectionRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. When authenticated with admin or owner permissions to the
     * repository, you can use this endpoint to check whether a branch requires signed commits. An
     * enabled status of `true` indicates you must sign commits on this branch. For more
     * information, see [Signing commits with
     * GPG](https://docs.github.com/articles/signing-commits-with-gpg) in GitHub Help. **Note**: You
     * must enable branch protection to require signed commits.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the EnforceAdmins response from the API call
     */
    public CompletableFuture<EnforceAdmins> reposGetCommitSignatureProtectionAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposGetCommitSignatureProtectionRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetCommitSignatureProtection.
     */
    private ApiCall<EnforceAdmins, ApiException> prepareReposGetCommitSignatureProtectionRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<EnforceAdmins, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, EnforceAdmins.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredSignatures404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. When authenticated with admin or owner permissions to the
     * repository, you can use this endpoint to require signed commits on a branch. You must enable
     * branch protection to require signed commits.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the EnforceAdmins response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public EnforceAdmins reposCreateCommitSignatureProtection(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        return prepareReposCreateCommitSignatureProtectionRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. When authenticated with admin or owner permissions to the
     * repository, you can use this endpoint to require signed commits on a branch. You must enable
     * branch protection to require signed commits.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the EnforceAdmins response from the API call
     */
    public CompletableFuture<EnforceAdmins> reposCreateCommitSignatureProtectionAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposCreateCommitSignatureProtectionRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateCommitSignatureProtection.
     */
    private ApiCall<EnforceAdmins, ApiException> prepareReposCreateCommitSignatureProtectionRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<EnforceAdmins, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, EnforceAdmins.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredSignatures404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. When authenticated with admin or owner permissions to the
     * repository, you can use this endpoint to disable required signed commits on a branch. You
     * must enable branch protection to require signed commits.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteCommitSignatureProtection(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        prepareReposDeleteCommitSignatureProtectionRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. When authenticated with admin or owner permissions to the
     * repository, you can use this endpoint to disable required signed commits on a branch. You
     * must enable branch protection to require signed commits.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteCommitSignatureProtectionAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposDeleteCommitSignatureProtectionRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteCommitSignatureProtection.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteCommitSignatureProtectionRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredSignatures404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the ReposBranchesBranchProtectionRequiredStatusChecksResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposBranchesBranchProtectionRequiredStatusChecksResponse reposGetStatusChecksProtection(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        return prepareReposGetStatusChecksProtectionRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the ReposBranchesBranchProtectionRequiredStatusChecksResponse response from the API call
     */
    public CompletableFuture<ReposBranchesBranchProtectionRequiredStatusChecksResponse> reposGetStatusChecksProtectionAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposGetStatusChecksProtectionRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetStatusChecksProtection.
     */
    private ApiCall<ReposBranchesBranchProtectionRequiredStatusChecksResponse, ApiException> prepareReposGetStatusChecksProtectionRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<ReposBranchesBranchProtectionRequiredStatusChecksResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposBranchesBranchProtectionRequiredStatusChecksResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredStatusChecks404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Updating required status checks requires admin or owner
     * permissions to the repository and branch protection to be enabled.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposBranchesBranchProtectionRequiredStatusChecksResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposBranchesBranchProtectionRequiredStatusChecksResponse reposUpdateStatusCheckProtection(
            final String owner,
            final String repo,
            final String branch,
            final ReposBranchesBranchProtectionRequiredStatusChecksRequest body) throws ApiException, IOException {
        return prepareReposUpdateStatusCheckProtectionRequest(owner, repo, branch, body).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Updating required status checks requires admin or owner
     * permissions to the repository and branch protection to be enabled.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposBranchesBranchProtectionRequiredStatusChecksResponse response from the API call
     */
    public CompletableFuture<ReposBranchesBranchProtectionRequiredStatusChecksResponse> reposUpdateStatusCheckProtectionAsync(
            final String owner,
            final String repo,
            final String branch,
            final ReposBranchesBranchProtectionRequiredStatusChecksRequest body) {
        try { 
            return prepareReposUpdateStatusCheckProtectionRequest(owner, repo, branch, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposUpdateStatusCheckProtection.
     */
    private ApiCall<ReposBranchesBranchProtectionRequiredStatusChecksResponse, ApiException> prepareReposUpdateStatusCheckProtectionRequest(
            final String owner,
            final String repo,
            final String branch,
            final ReposBranchesBranchProtectionRequiredStatusChecksRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposBranchesBranchProtectionRequiredStatusChecksResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposBranchesBranchProtectionRequiredStatusChecksResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredStatusChecks404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredStatusChecks422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposRemoveStatusCheckProtection(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        prepareReposRemoveStatusCheckProtectionRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposRemoveStatusCheckProtectionAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposRemoveStatusCheckProtectionRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposRemoveStatusCheckProtection.
     */
    private ApiCall<Void, ApiException> prepareReposRemoveStatusCheckProtectionRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the List of String response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<String> reposGetAllStatusCheckContexts(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        return prepareReposGetAllStatusCheckContextsRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the List of String response from the API call
     */
    public CompletableFuture<List<String>> reposGetAllStatusCheckContextsAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposGetAllStatusCheckContextsRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetAllStatusCheckContexts.
     */
    private ApiCall<List<String>, ApiException> prepareReposGetAllStatusCheckContextsRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<List<String>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        String[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredStatusChecksContexts404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of String response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<String> reposAddStatusCheckContexts(
            final String owner,
            final String repo,
            final String branch,
            final ReposAddStatusCheckContextsBody body) throws ApiException, IOException {
        return prepareReposAddStatusCheckContextsRequest(owner, repo, branch, body).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of String response from the API call
     */
    public CompletableFuture<List<String>> reposAddStatusCheckContextsAsync(
            final String owner,
            final String repo,
            final String branch,
            final ReposAddStatusCheckContextsBody body) {
        try { 
            return prepareReposAddStatusCheckContextsRequest(owner, repo, branch, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposAddStatusCheckContexts.
     */
    private ApiCall<List<String>, ApiException> prepareReposAddStatusCheckContextsRequest(
            final String owner,
            final String repo,
            final String branch,
            final ReposAddStatusCheckContextsBody body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<List<String>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serializeTypeCombinator(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        String[].class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredStatusChecksContexts403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredStatusChecksContexts404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredStatusChecksContexts422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of String response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<String> reposSetStatusCheckContexts(
            final String owner,
            final String repo,
            final String branch,
            final ReposSetStatusCheckContextsBody body) throws ApiException, IOException {
        return prepareReposSetStatusCheckContextsRequest(owner, repo, branch, body).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of String response from the API call
     */
    public CompletableFuture<List<String>> reposSetStatusCheckContextsAsync(
            final String owner,
            final String repo,
            final String branch,
            final ReposSetStatusCheckContextsBody body) {
        try { 
            return prepareReposSetStatusCheckContextsRequest(owner, repo, branch, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposSetStatusCheckContexts.
     */
    private ApiCall<List<String>, ApiException> prepareReposSetStatusCheckContextsRequest(
            final String owner,
            final String repo,
            final String branch,
            final ReposSetStatusCheckContextsBody body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<List<String>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serializeTypeCombinator(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        String[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredStatusChecksContexts404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredStatusChecksContexts422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  contentType  Required parameter: Example:
     * @return    Returns the List of String response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<String> reposRemoveStatusCheckContexts(
            final String owner,
            final String repo,
            final String branch,
            final ContentType3Enum contentType) throws ApiException, IOException {
        return prepareReposRemoveStatusCheckContextsRequest(owner, repo, branch,
                contentType).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  contentType  Required parameter: Example:
     * @return    Returns the List of String response from the API call
     */
    public CompletableFuture<List<String>> reposRemoveStatusCheckContextsAsync(
            final String owner,
            final String repo,
            final String branch,
            final ContentType3Enum contentType) {
        try { 
            return prepareReposRemoveStatusCheckContextsRequest(owner, repo, branch,
            contentType).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposRemoveStatusCheckContexts.
     */
    private ApiCall<List<String>, ApiException> prepareReposRemoveStatusCheckContextsRequest(
            final String owner,
            final String repo,
            final String branch,
            final ContentType3Enum contentType) throws IOException {
        return new ApiCall.Builder<List<String>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value((contentType != null) ? contentType.value() : null).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        String[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredStatusChecksContexts404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtectionRequiredStatusChecksContexts422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Lists who has access to this protected branch. **Note**: Users,
     * apps, and teams `restrictions` are only available for organization-owned repositories.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the ReposBranchesBranchProtectionRestrictionsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposBranchesBranchProtectionRestrictionsResponse reposGetAccessRestrictions(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        return prepareReposGetAccessRestrictionsRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Lists who has access to this protected branch. **Note**: Users,
     * apps, and teams `restrictions` are only available for organization-owned repositories.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the ReposBranchesBranchProtectionRestrictionsResponse response from the API call
     */
    public CompletableFuture<ReposBranchesBranchProtectionRestrictionsResponse> reposGetAccessRestrictionsAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposGetAccessRestrictionsRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetAccessRestrictions.
     */
    private ApiCall<ReposBranchesBranchProtectionRestrictionsResponse, ApiException> prepareReposGetAccessRestrictionsRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<ReposBranchesBranchProtectionRestrictionsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposBranchesBranchProtectionRestrictionsResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionRestrictions404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Disables the ability to restrict who can push to this branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteAccessRestrictions(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        prepareReposDeleteAccessRestrictionsRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Disables the ability to restrict who can push to this branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteAccessRestrictionsAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposDeleteAccessRestrictionsRequest(owner, repo, branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteAccessRestrictions.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteAccessRestrictionsRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Lists the GitHub Apps that have push access to this branch. Only
     * installed GitHub Apps with `write` access to the `contents` permission can be added as
     * authorized actors on a protected branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the List of GitHubapp response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<GitHubapp> reposGetAppsWithAccessToProtectedBranch(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        return prepareReposGetAppsWithAccessToProtectedBranchRequest(owner, repo, branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Lists the GitHub Apps that have push access to this branch. Only
     * installed GitHub Apps with `write` access to the `contents` permission can be added as
     * authorized actors on a protected branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the List of GitHubapp response from the API call
     */
    public CompletableFuture<List<GitHubapp>> reposGetAppsWithAccessToProtectedBranchAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposGetAppsWithAccessToProtectedBranchRequest(owner, repo,
            branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetAppsWithAccessToProtectedBranch.
     */
    private ApiCall<List<GitHubapp>, ApiException> prepareReposGetAppsWithAccessToProtectedBranchRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<List<GitHubapp>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        GitHubapp[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionRestrictionsApps404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Grants the specified apps push access for this branch. Only
     * installed GitHub Apps with `write` access to the `contents` permission can be added as
     * authorized actors on a protected branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of GitHubapp response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<GitHubapp> reposAddAppAccessRestrictions(
            final String owner,
            final String repo,
            final String branch,
            final ReposAddAppAccessRestrictionsBody body) throws ApiException, IOException {
        return prepareReposAddAppAccessRestrictionsRequest(owner, repo, branch, body).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Grants the specified apps push access for this branch. Only
     * installed GitHub Apps with `write` access to the `contents` permission can be added as
     * authorized actors on a protected branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of GitHubapp response from the API call
     */
    public CompletableFuture<List<GitHubapp>> reposAddAppAccessRestrictionsAsync(
            final String owner,
            final String repo,
            final String branch,
            final ReposAddAppAccessRestrictionsBody body) {
        try { 
            return prepareReposAddAppAccessRestrictionsRequest(owner, repo, branch, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposAddAppAccessRestrictions.
     */
    private ApiCall<List<GitHubapp>, ApiException> prepareReposAddAppAccessRestrictionsRequest(
            final String owner,
            final String repo,
            final String branch,
            final ReposAddAppAccessRestrictionsBody body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<List<GitHubapp>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serializeTypeCombinator(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        GitHubapp[].class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtectionRestrictionsApps422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Replaces the list of apps that have push access to this branch.
     * This removes all apps that previously had push access and grants push access to the new list
     * of apps. Only installed GitHub Apps with `write` access to the `contents` permission can be
     * added as authorized actors on a protected branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of GitHubapp response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<GitHubapp> reposSetAppAccessRestrictions(
            final String owner,
            final String repo,
            final String branch,
            final ReposSetAppAccessRestrictionsBody body) throws ApiException, IOException {
        return prepareReposSetAppAccessRestrictionsRequest(owner, repo, branch, body).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Replaces the list of apps that have push access to this branch.
     * This removes all apps that previously had push access and grants push access to the new list
     * of apps. Only installed GitHub Apps with `write` access to the `contents` permission can be
     * added as authorized actors on a protected branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of GitHubapp response from the API call
     */
    public CompletableFuture<List<GitHubapp>> reposSetAppAccessRestrictionsAsync(
            final String owner,
            final String repo,
            final String branch,
            final ReposSetAppAccessRestrictionsBody body) {
        try { 
            return prepareReposSetAppAccessRestrictionsRequest(owner, repo, branch, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposSetAppAccessRestrictions.
     */
    private ApiCall<List<GitHubapp>, ApiException> prepareReposSetAppAccessRestrictionsRequest(
            final String owner,
            final String repo,
            final String branch,
            final ReposSetAppAccessRestrictionsBody body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<List<GitHubapp>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serializeTypeCombinator(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        GitHubapp[].class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtectionRestrictionsApps422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Removes the ability of an app to push to this branch. Only
     * installed GitHub Apps with `write` access to the `contents` permission can be added as
     * authorized actors on a protected branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  contentType  Required parameter: Example:
     * @return    Returns the List of GitHubapp response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<GitHubapp> reposRemoveAppAccessRestrictions(
            final String owner,
            final String repo,
            final String branch,
            final ContentType3Enum contentType) throws ApiException, IOException {
        return prepareReposRemoveAppAccessRestrictionsRequest(owner, repo, branch,
                contentType).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Removes the ability of an app to push to this branch. Only
     * installed GitHub Apps with `write` access to the `contents` permission can be added as
     * authorized actors on a protected branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  contentType  Required parameter: Example:
     * @return    Returns the List of GitHubapp response from the API call
     */
    public CompletableFuture<List<GitHubapp>> reposRemoveAppAccessRestrictionsAsync(
            final String owner,
            final String repo,
            final String branch,
            final ContentType3Enum contentType) {
        try { 
            return prepareReposRemoveAppAccessRestrictionsRequest(owner, repo, branch,
            contentType).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposRemoveAppAccessRestrictions.
     */
    private ApiCall<List<GitHubapp>, ApiException> prepareReposRemoveAppAccessRestrictionsRequest(
            final String owner,
            final String repo,
            final String branch,
            final ContentType3Enum contentType) throws IOException {
        return new ApiCall.Builder<List<GitHubapp>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value((contentType != null) ? contentType.value() : null).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        GitHubapp[].class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtectionRestrictionsApps422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Lists the teams who have push access to this branch. The list
     * includes child teams.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the List of Team response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Team> reposGetTeamsWithAccessToProtectedBranch(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        return prepareReposGetTeamsWithAccessToProtectedBranchRequest(owner, repo,
                branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Lists the teams who have push access to this branch. The list
     * includes child teams.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the List of Team response from the API call
     */
    public CompletableFuture<List<Team>> reposGetTeamsWithAccessToProtectedBranchAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposGetTeamsWithAccessToProtectedBranchRequest(owner, repo,
            branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetTeamsWithAccessToProtectedBranch.
     */
    private ApiCall<List<Team>, ApiException> prepareReposGetTeamsWithAccessToProtectedBranchRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<List<Team>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Team[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionRestrictionsTeams404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Grants the specified teams push access for this branch. You can
     * also give push access to child teams. | Type | Description | | ------- |
     * ------------------------------------------------------------------------------------------------------------------------------------------
     * | | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list
     * of users, apps, and teams in total is limited to 100 items. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of Team response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Team> reposAddTeamAccessRestrictions(
            final String owner,
            final String repo,
            final String branch,
            final ReposAddTeamAccessRestrictionsBody body) throws ApiException, IOException {
        return prepareReposAddTeamAccessRestrictionsRequest(owner, repo, branch, body).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Grants the specified teams push access for this branch. You can
     * also give push access to child teams. | Type | Description | | ------- |
     * ------------------------------------------------------------------------------------------------------------------------------------------
     * | | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list
     * of users, apps, and teams in total is limited to 100 items. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of Team response from the API call
     */
    public CompletableFuture<List<Team>> reposAddTeamAccessRestrictionsAsync(
            final String owner,
            final String repo,
            final String branch,
            final ReposAddTeamAccessRestrictionsBody body) {
        try { 
            return prepareReposAddTeamAccessRestrictionsRequest(owner, repo, branch, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposAddTeamAccessRestrictions.
     */
    private ApiCall<List<Team>, ApiException> prepareReposAddTeamAccessRestrictionsRequest(
            final String owner,
            final String repo,
            final String branch,
            final ReposAddTeamAccessRestrictionsBody body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<List<Team>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serializeTypeCombinator(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Team[].class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtectionRestrictionsTeams422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Replaces the list of teams that have push access to this branch.
     * This removes all teams that previously had push access and grants push access to the new list
     * of teams. Team restrictions include child teams. | Type | Description | | ------- |
     * ------------------------------------------------------------------------------------------------------------------------------------------
     * | | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list
     * of users, apps, and teams in total is limited to 100 items. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of Team response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Team> reposSetTeamAccessRestrictions(
            final String owner,
            final String repo,
            final String branch,
            final ReposSetTeamAccessRestrictionsBody body) throws ApiException, IOException {
        return prepareReposSetTeamAccessRestrictionsRequest(owner, repo, branch, body).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Replaces the list of teams that have push access to this branch.
     * This removes all teams that previously had push access and grants push access to the new list
     * of teams. Team restrictions include child teams. | Type | Description | | ------- |
     * ------------------------------------------------------------------------------------------------------------------------------------------
     * | | `array` | The teams that can have push access. Use the team's `slug`. **Note**: The list
     * of users, apps, and teams in total is limited to 100 items. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of Team response from the API call
     */
    public CompletableFuture<List<Team>> reposSetTeamAccessRestrictionsAsync(
            final String owner,
            final String repo,
            final String branch,
            final ReposSetTeamAccessRestrictionsBody body) {
        try { 
            return prepareReposSetTeamAccessRestrictionsRequest(owner, repo, branch, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposSetTeamAccessRestrictions.
     */
    private ApiCall<List<Team>, ApiException> prepareReposSetTeamAccessRestrictionsRequest(
            final String owner,
            final String repo,
            final String branch,
            final ReposSetTeamAccessRestrictionsBody body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<List<Team>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serializeTypeCombinator(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Team[].class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtectionRestrictionsTeams422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Removes the ability of a team to push to this branch. You can also
     * remove push access for child teams. | Type | Description | | ------- |
     * ---------------------------------------------------------------------------------------------------------------------------------------------------
     * | | `array` | Teams that should no longer have push access. Use the team's `slug`. **Note**:
     * The list of users, apps, and teams in total is limited to 100 items. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  contentType  Required parameter: Example:
     * @return    Returns the List of Team response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Team> reposRemoveTeamAccessRestrictions(
            final String owner,
            final String repo,
            final String branch,
            final ContentType3Enum contentType) throws ApiException, IOException {
        return prepareReposRemoveTeamAccessRestrictionsRequest(owner, repo, branch,
                contentType).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Removes the ability of a team to push to this branch. You can also
     * remove push access for child teams. | Type | Description | | ------- |
     * ---------------------------------------------------------------------------------------------------------------------------------------------------
     * | | `array` | Teams that should no longer have push access. Use the team's `slug`. **Note**:
     * The list of users, apps, and teams in total is limited to 100 items. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  contentType  Required parameter: Example:
     * @return    Returns the List of Team response from the API call
     */
    public CompletableFuture<List<Team>> reposRemoveTeamAccessRestrictionsAsync(
            final String owner,
            final String repo,
            final String branch,
            final ContentType3Enum contentType) {
        try { 
            return prepareReposRemoveTeamAccessRestrictionsRequest(owner, repo, branch,
            contentType).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposRemoveTeamAccessRestrictions.
     */
    private ApiCall<List<Team>, ApiException> prepareReposRemoveTeamAccessRestrictionsRequest(
            final String owner,
            final String repo,
            final String branch,
            final ContentType3Enum contentType) throws IOException {
        return new ApiCall.Builder<List<Team>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value((contentType != null) ? contentType.value() : null).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Team[].class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtectionRestrictionsTeams422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Lists the people who have push access to this branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the List of SimpleUser response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<SimpleUser> reposGetUsersWithAccessToProtectedBranch(
            final String owner,
            final String repo,
            final String branch) throws ApiException, IOException {
        return prepareReposGetUsersWithAccessToProtectedBranchRequest(owner, repo,
                branch).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Lists the people who have push access to this branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @return    Returns the List of SimpleUser response from the API call
     */
    public CompletableFuture<List<SimpleUser>> reposGetUsersWithAccessToProtectedBranchAsync(
            final String owner,
            final String repo,
            final String branch) {
        try { 
            return prepareReposGetUsersWithAccessToProtectedBranchRequest(owner, repo,
            branch).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetUsersWithAccessToProtectedBranch.
     */
    private ApiCall<List<SimpleUser>, ApiException> prepareReposGetUsersWithAccessToProtectedBranchRequest(
            final String owner,
            final String repo,
            final String branch) throws IOException {
        return new ApiCall.Builder<List<SimpleUser>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        SimpleUser[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchProtectionRestrictionsUsers404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Grants the specified people push access for this branch. | Type |
     * Description | | ------- |
     * -----------------------------------------------------------------------------------------------------------------------------
     * | | `array` | Usernames for people who can have push access. **Note**: The list of users,
     * apps, and teams in total is limited to 100 items. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of SimpleUser response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<SimpleUser> reposAddUserAccessRestrictions(
            final String owner,
            final String repo,
            final String branch,
            final ReposAddUserAccessRestrictionsBody body) throws ApiException, IOException {
        return prepareReposAddUserAccessRestrictionsRequest(owner, repo, branch, body).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Grants the specified people push access for this branch. | Type |
     * Description | | ------- |
     * -----------------------------------------------------------------------------------------------------------------------------
     * | | `array` | Usernames for people who can have push access. **Note**: The list of users,
     * apps, and teams in total is limited to 100 items. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of SimpleUser response from the API call
     */
    public CompletableFuture<List<SimpleUser>> reposAddUserAccessRestrictionsAsync(
            final String owner,
            final String repo,
            final String branch,
            final ReposAddUserAccessRestrictionsBody body) {
        try { 
            return prepareReposAddUserAccessRestrictionsRequest(owner, repo, branch, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposAddUserAccessRestrictions.
     */
    private ApiCall<List<SimpleUser>, ApiException> prepareReposAddUserAccessRestrictionsRequest(
            final String owner,
            final String repo,
            final String branch,
            final ReposAddUserAccessRestrictionsBody body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<List<SimpleUser>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serializeTypeCombinator(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        SimpleUser[].class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtectionRestrictionsUsers422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Replaces the list of people that have push access to this branch.
     * This removes all people that previously had push access and grants push access to the new
     * list of people. | Type | Description | | ------- |
     * -----------------------------------------------------------------------------------------------------------------------------
     * | | `array` | Usernames for people who can have push access. **Note**: The list of users,
     * apps, and teams in total is limited to 100 items. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of SimpleUser response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<SimpleUser> reposSetUserAccessRestrictions(
            final String owner,
            final String repo,
            final String branch,
            final ReposSetUserAccessRestrictionsBody body) throws ApiException, IOException {
        return prepareReposSetUserAccessRestrictionsRequest(owner, repo, branch, body).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Replaces the list of people that have push access to this branch.
     * This removes all people that previously had push access and grants push access to the new
     * list of people. | Type | Description | | ------- |
     * -----------------------------------------------------------------------------------------------------------------------------
     * | | `array` | Usernames for people who can have push access. **Note**: The list of users,
     * apps, and teams in total is limited to 100 items. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of SimpleUser response from the API call
     */
    public CompletableFuture<List<SimpleUser>> reposSetUserAccessRestrictionsAsync(
            final String owner,
            final String repo,
            final String branch,
            final ReposSetUserAccessRestrictionsBody body) {
        try { 
            return prepareReposSetUserAccessRestrictionsRequest(owner, repo, branch, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposSetUserAccessRestrictions.
     */
    private ApiCall<List<SimpleUser>, ApiException> prepareReposSetUserAccessRestrictionsRequest(
            final String owner,
            final String repo,
            final String branch,
            final ReposSetUserAccessRestrictionsBody body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<List<SimpleUser>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serializeTypeCombinator(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        SimpleUser[].class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtectionRestrictionsUsers422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Removes the ability of a user to push to this branch. | Type |
     * Description | | ------- |
     * ---------------------------------------------------------------------------------------------------------------------------------------------
     * | | `array` | Usernames of the people who should no longer have push access. **Note**: The
     * list of users, apps, and teams in total is limited to 100 items. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  contentType  Required parameter: Example:
     * @return    Returns the List of SimpleUser response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<SimpleUser> reposRemoveUserAccessRestrictions(
            final String owner,
            final String repo,
            final String branch,
            final ContentType3Enum contentType) throws ApiException, IOException {
        return prepareReposRemoveUserAccessRestrictionsRequest(owner, repo, branch,
                contentType).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Removes the ability of a user to push to this branch. | Type |
     * Description | | ------- |
     * ---------------------------------------------------------------------------------------------------------------------------------------------
     * | | `array` | Usernames of the people who should no longer have push access. **Note**: The
     * list of users, apps, and teams in total is limited to 100 items. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  contentType  Required parameter: Example:
     * @return    Returns the List of SimpleUser response from the API call
     */
    public CompletableFuture<List<SimpleUser>> reposRemoveUserAccessRestrictionsAsync(
            final String owner,
            final String repo,
            final String branch,
            final ContentType3Enum contentType) {
        try { 
            return prepareReposRemoveUserAccessRestrictionsRequest(owner, repo, branch,
            contentType).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposRemoveUserAccessRestrictions.
     */
    private ApiCall<List<SimpleUser>, ApiException> prepareReposRemoveUserAccessRestrictionsRequest(
            final String owner,
            final String repo,
            final String branch,
            final ContentType3Enum contentType) throws IOException {
        return new ApiCall.Builder<List<SimpleUser>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value((contentType != null) ? contentType.value() : null).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        SimpleUser[].class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchProtectionRestrictionsUsers422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Renames a branch in a repository. **Note:** Although the API responds immediately, the branch
     * rename process might take some extra time to complete in the background. You won't be able to
     * push to the old branch name while the rename process is in progress. For more information,
     * see "[Renaming a
     * branch](https://docs.github.com/github/administering-a-repository/renaming-a-branch)". The
     * permissions required to use this endpoint depends on whether you are renaming the default
     * branch. To rename a non-default branch: * Users must have push access. * GitHub Apps must
     * have the `contents:write` repository permission. To rename the default branch: * Users must
     * have admin or owner permissions. * GitHub Apps must have the `administration:write`
     * repository permission.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposBranchesBranchRenameResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposBranchesBranchRenameResponse reposRenameBranch(
            final String owner,
            final String repo,
            final String branch,
            final ReposBranchesBranchRenameRequest body) throws ApiException, IOException {
        return prepareReposRenameBranchRequest(owner, repo, branch, body).execute();
    }

    /**
     * Renames a branch in a repository. **Note:** Although the API responds immediately, the branch
     * rename process might take some extra time to complete in the background. You won't be able to
     * push to the old branch name while the rename process is in progress. For more information,
     * see "[Renaming a
     * branch](https://docs.github.com/github/administering-a-repository/renaming-a-branch)". The
     * permissions required to use this endpoint depends on whether you are renaming the default
     * branch. To rename a non-default branch: * Users must have push access. * GitHub Apps must
     * have the `contents:write` repository permission. To rename the default branch: * Users must
     * have admin or owner permissions. * GitHub Apps must have the `administration:write`
     * repository permission.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  branch  Required parameter: The name of the branch. Cannot contain wildcard
     *         characters. To use wildcard characters in branch names, use [the GraphQL
     *         API](https://docs.github.com/graphql).
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposBranchesBranchRenameResponse response from the API call
     */
    public CompletableFuture<ReposBranchesBranchRenameResponse> reposRenameBranchAsync(
            final String owner,
            final String repo,
            final String branch,
            final ReposBranchesBranchRenameRequest body) {
        try { 
            return prepareReposRenameBranchRequest(owner, repo, branch, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposRenameBranch.
     */
    private ApiCall<ReposBranchesBranchRenameResponse, ApiException> prepareReposRenameBranchRequest(
            final String owner,
            final String repo,
            final String branch,
            final ReposBranchesBranchRenameRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposBranchesBranchRenameResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/branches/{branch}/rename")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch").value(branch)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposBranchesBranchRenameResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposBranchesBranchRename403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposBranchesBranchRename404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposBranchesBranchRename422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List any syntax errors that are detected in the CODEOWNERS file. For more information about
     * the correct CODEOWNERS syntax, see "[About code
     * owners](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Optional parameter: A branch, tag or commit name used to determine which version
     *         of the CODEOWNERS file to use. Default: the repository's default branch (e.g. `main`)
     * @return    Returns the ReposCodeownersErrorsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCodeownersErrorsResponse reposCodeownersErrors(
            final String owner,
            final String repo,
            final String ref) throws ApiException, IOException {
        return prepareReposCodeownersErrorsRequest(owner, repo, ref).execute();
    }

    /**
     * List any syntax errors that are detected in the CODEOWNERS file. For more information about
     * the correct CODEOWNERS syntax, see "[About code
     * owners](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Optional parameter: A branch, tag or commit name used to determine which version
     *         of the CODEOWNERS file to use. Default: the repository's default branch (e.g. `main`)
     * @return    Returns the ReposCodeownersErrorsResponse response from the API call
     */
    public CompletableFuture<ReposCodeownersErrorsResponse> reposCodeownersErrorsAsync(
            final String owner,
            final String repo,
            final String ref) {
        try { 
            return prepareReposCodeownersErrorsRequest(owner, repo, ref).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCodeownersErrors.
     */
    private ApiCall<ReposCodeownersErrorsResponse, ApiException> prepareReposCodeownersErrorsRequest(
            final String owner,
            final String repo,
            final String ref) throws IOException {
        return new ApiCall.Builder<ReposCodeownersErrorsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/codeowners/errors")
                        .queryParam(param -> param.key("ref")
                                .value(ref).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCodeownersErrorsResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * For organization-owned repositories, the list of collaborators includes outside
     * collaborators, organization members that are direct collaborators, organization members with
     * access through team memberships, organization members with access through default
     * organization permissions, and organization owners. Organization members with write, maintain,
     * or admin privileges on the organization-owned repository can use this endpoint. Team members
     * will include the members of child teams. You must authenticate using an access token with the
     * `read:org` and `repo` scopes with push access to use this endpoint. GitHub Apps must have the
     * `members` organization permission and `metadata` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  affiliation  Optional parameter: Filter collaborators returned by their affiliation.
     *         `outside` means all outside collaborators of an organization-owned repository.
     *         `direct` means all collaborators with permissions to an organization-owned
     *         repository, regardless of organization membership status. `all` means all
     *         collaborators the authenticated user can see.
     * @param  permission  Optional parameter: Filter collaborators by the permissions they have on
     *         the repository. If not specified, all collaborators will be returned.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Collaborator response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Collaborator> reposListCollaborators(
            final String owner,
            final String repo,
            final Affiliation2Enum affiliation,
            final Permission61Enum permission,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListCollaboratorsRequest(owner, repo, affiliation, permission, perPage,
                page).execute();
    }

    /**
     * For organization-owned repositories, the list of collaborators includes outside
     * collaborators, organization members that are direct collaborators, organization members with
     * access through team memberships, organization members with access through default
     * organization permissions, and organization owners. Organization members with write, maintain,
     * or admin privileges on the organization-owned repository can use this endpoint. Team members
     * will include the members of child teams. You must authenticate using an access token with the
     * `read:org` and `repo` scopes with push access to use this endpoint. GitHub Apps must have the
     * `members` organization permission and `metadata` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  affiliation  Optional parameter: Filter collaborators returned by their affiliation.
     *         `outside` means all outside collaborators of an organization-owned repository.
     *         `direct` means all collaborators with permissions to an organization-owned
     *         repository, regardless of organization membership status. `all` means all
     *         collaborators the authenticated user can see.
     * @param  permission  Optional parameter: Filter collaborators by the permissions they have on
     *         the repository. If not specified, all collaborators will be returned.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Collaborator response from the API call
     */
    public CompletableFuture<List<Collaborator>> reposListCollaboratorsAsync(
            final String owner,
            final String repo,
            final Affiliation2Enum affiliation,
            final Permission61Enum permission,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListCollaboratorsRequest(owner, repo, affiliation, permission, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListCollaborators.
     */
    private ApiCall<List<Collaborator>, ApiException> prepareReposListCollaboratorsRequest(
            final String owner,
            final String repo,
            final Affiliation2Enum affiliation,
            final Permission61Enum permission,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Collaborator>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/collaborators")
                        .queryParam(param -> param.key("affiliation")
                                .value((affiliation != null) ? affiliation.value() : null).isRequired(false))
                        .queryParam(param -> param.key("permission")
                                .value((permission != null) ? permission.value() : null).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Collaborator[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposCollaborators404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * For organization-owned repositories, the list of collaborators includes outside
     * collaborators, organization members that are direct collaborators, organization members with
     * access through team memberships, organization members with access through default
     * organization permissions, and organization owners. Team members will include the members of
     * child teams. You must authenticate using an access token with the `read:org` and `repo`
     * scopes with push access to use this endpoint. GitHub Apps must have the `members`
     * organization permission and `metadata` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposCheckCollaborator(
            final String owner,
            final String repo,
            final String username) throws ApiException, IOException {
        prepareReposCheckCollaboratorRequest(owner, repo, username).execute();
    }

    /**
     * For organization-owned repositories, the list of collaborators includes outside
     * collaborators, organization members that are direct collaborators, organization members with
     * access through team memberships, organization members with access through default
     * organization permissions, and organization owners. Team members will include the members of
     * child teams. You must authenticate using an access token with the `read:org` and `repo`
     * scopes with push access to use this endpoint. GitHub Apps must have the `members`
     * organization permission and `metadata` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposCheckCollaboratorAsync(
            final String owner,
            final String repo,
            final String username) {
        try { 
            return prepareReposCheckCollaboratorRequest(owner, repo, username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCheckCollaborator.
     */
    private ApiCall<Void, ApiException> prepareReposCheckCollaboratorRequest(
            final String owner,
            final String repo,
            final String username) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/collaborators/{username}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Not Found if user is not a collaborator",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This endpoint triggers
     * [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
     * Creating content too quickly using this endpoint may result in secondary rate limiting. See
     * "[Secondary rate
     * limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
     * and "[Dealing with secondary rate
     * limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)"
     * for details. Adding an outside collaborator may be restricted by enterprise administrators.
     * For more information, see "[Enforcing repository management policies in your
     * enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)."
     * For more information on permission levels, see "[Repository permission levels for an
     * organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
     * There are restrictions on which permissions can be granted to organization members when an
     * organization base role is in place. In this case, the permission being given must be equal to
     * or higher than the org base permission. Otherwise, the request will fail with: ``` Cannot
     * assign {member} permission of {role name} ``` Note that, if you choose not to pass any
     * parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint.
     * For more information, see "[HTTP
     * verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)." The
     * invitee will receive a notification that they have been invited to the repository, which they
     * must accept or decline. They may do this via the notifications page, the email they receive,
     * or by using the [repository invitations API
     * endpoints](https://docs.github.com/rest/reference/repos#invitations). **Updating an existing
     * collaborator's permission level** The endpoint can also be used to change the permissions of
     * an existing collaborator without first removing and re-adding the collaborator. To change the
     * permissions, use the same endpoint and pass a different `permission` parameter. The response
     * will be a `204`, with no other indication that the permission level changed. **Rate limits**
     * You are limited to sending 50 invitations to a repository per 24 hour period. Note there is
     * no limit if you are inviting organization members to an organization repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposCollaboratorsUsernameResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCollaboratorsUsernameResponse reposAddCollaborator(
            final String owner,
            final String repo,
            final String username,
            final ReposCollaboratorsUsernameRequest body) throws ApiException, IOException {
        return prepareReposAddCollaboratorRequest(owner, repo, username, body).execute();
    }

    /**
     * This endpoint triggers
     * [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
     * Creating content too quickly using this endpoint may result in secondary rate limiting. See
     * "[Secondary rate
     * limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
     * and "[Dealing with secondary rate
     * limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)"
     * for details. Adding an outside collaborator may be restricted by enterprise administrators.
     * For more information, see "[Enforcing repository management policies in your
     * enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)."
     * For more information on permission levels, see "[Repository permission levels for an
     * organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
     * There are restrictions on which permissions can be granted to organization members when an
     * organization base role is in place. In this case, the permission being given must be equal to
     * or higher than the org base permission. Otherwise, the request will fail with: ``` Cannot
     * assign {member} permission of {role name} ``` Note that, if you choose not to pass any
     * parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint.
     * For more information, see "[HTTP
     * verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)." The
     * invitee will receive a notification that they have been invited to the repository, which they
     * must accept or decline. They may do this via the notifications page, the email they receive,
     * or by using the [repository invitations API
     * endpoints](https://docs.github.com/rest/reference/repos#invitations). **Updating an existing
     * collaborator's permission level** The endpoint can also be used to change the permissions of
     * an existing collaborator without first removing and re-adding the collaborator. To change the
     * permissions, use the same endpoint and pass a different `permission` parameter. The response
     * will be a `204`, with no other indication that the permission level changed. **Rate limits**
     * You are limited to sending 50 invitations to a repository per 24 hour period. Note there is
     * no limit if you are inviting organization members to an organization repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposCollaboratorsUsernameResponse response from the API call
     */
    public CompletableFuture<ReposCollaboratorsUsernameResponse> reposAddCollaboratorAsync(
            final String owner,
            final String repo,
            final String username,
            final ReposCollaboratorsUsernameRequest body) {
        try { 
            return prepareReposAddCollaboratorRequest(owner, repo, username, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposAddCollaborator.
     */
    private ApiCall<ReposCollaboratorsUsernameResponse, ApiException> prepareReposAddCollaboratorRequest(
            final String owner,
            final String repo,
            final String username,
            final ReposCollaboratorsUsernameRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposCollaboratorsUsernameResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/collaborators/{username}")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCollaboratorsUsernameResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposCollaboratorsUsername403ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposCollaboratorsUsername422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Remove a repository collaborator.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposRemoveCollaborator(
            final String owner,
            final String repo,
            final String username) throws ApiException, IOException {
        prepareReposRemoveCollaboratorRequest(owner, repo, username).execute();
    }

    /**
     * Remove a repository collaborator.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposRemoveCollaboratorAsync(
            final String owner,
            final String repo,
            final String username) {
        try { 
            return prepareReposRemoveCollaboratorRequest(owner, repo, username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposRemoveCollaborator.
     */
    private ApiCall<Void, ApiException> prepareReposRemoveCollaboratorRequest(
            final String owner,
            final String repo,
            final String username) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/collaborators/{username}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Checks the repository permission of a collaborator. The possible repository permissions are
     * `admin`, `write`, `read`, and `none`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the ReposCollaboratorsUsernamePermissionResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCollaboratorsUsernamePermissionResponse reposGetCollaboratorPermissionLevel(
            final String owner,
            final String repo,
            final String username) throws ApiException, IOException {
        return prepareReposGetCollaboratorPermissionLevelRequest(owner, repo, username).execute();
    }

    /**
     * Checks the repository permission of a collaborator. The possible repository permissions are
     * `admin`, `write`, `read`, and `none`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the ReposCollaboratorsUsernamePermissionResponse response from the API call
     */
    public CompletableFuture<ReposCollaboratorsUsernamePermissionResponse> reposGetCollaboratorPermissionLevelAsync(
            final String owner,
            final String repo,
            final String username) {
        try { 
            return prepareReposGetCollaboratorPermissionLevelRequest(owner, repo, username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetCollaboratorPermissionLevel.
     */
    private ApiCall<ReposCollaboratorsUsernamePermissionResponse, ApiException> prepareReposGetCollaboratorPermissionLevelRequest(
            final String owner,
            final String repo,
            final String username) throws IOException {
        return new ApiCall.Builder<ReposCollaboratorsUsernamePermissionResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/collaborators/{username}/permission")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCollaboratorsUsernamePermissionResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposCollaboratorsUsernamePermission404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Commit Comments use [these custom media
     * types](https://docs.github.com/rest/reference/repos#custom-media-types). You can read more
     * about the use of media types in the API
     * [here](https://docs.github.com/rest/overview/media-types/). Comments are ordered by ascending
     * ID.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of CommitComment response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<CommitComment> reposListCommitCommentsForRepo(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListCommitCommentsForRepoRequest(owner, repo, perPage, page).execute();
    }

    /**
     * Commit Comments use [these custom media
     * types](https://docs.github.com/rest/reference/repos#custom-media-types). You can read more
     * about the use of media types in the API
     * [here](https://docs.github.com/rest/overview/media-types/). Comments are ordered by ascending
     * ID.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of CommitComment response from the API call
     */
    public CompletableFuture<List<CommitComment>> reposListCommitCommentsForRepoAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListCommitCommentsForRepoRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListCommitCommentsForRepo.
     */
    private ApiCall<List<CommitComment>, ApiException> prepareReposListCommitCommentsForRepoRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<CommitComment>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/comments")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        CommitComment[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get a commit comment.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commentId  Required parameter: The unique identifier of the comment.
     * @return    Returns the ReposCommentsCommentIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCommentsCommentIdResponse reposGetCommitComment(
            final String owner,
            final String repo,
            final int commentId) throws ApiException, IOException {
        return prepareReposGetCommitCommentRequest(owner, repo, commentId).execute();
    }

    /**
     * Get a commit comment.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commentId  Required parameter: The unique identifier of the comment.
     * @return    Returns the ReposCommentsCommentIdResponse response from the API call
     */
    public CompletableFuture<ReposCommentsCommentIdResponse> reposGetCommitCommentAsync(
            final String owner,
            final String repo,
            final int commentId) {
        try { 
            return prepareReposGetCommitCommentRequest(owner, repo, commentId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetCommitComment.
     */
    private ApiCall<ReposCommentsCommentIdResponse, ApiException> prepareReposGetCommitCommentRequest(
            final String owner,
            final String repo,
            final int commentId) throws IOException {
        return new ApiCall.Builder<ReposCommentsCommentIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/comments/{comment_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("comment_id").value(commentId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCommentsCommentIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposCommentsCommentId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Update a commit comment.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commentId  Required parameter: The unique identifier of the comment.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposCommentsCommentIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCommentsCommentIdResponse reposUpdateCommitComment(
            final String owner,
            final String repo,
            final int commentId,
            final ReposCommentsCommentIdRequest body) throws ApiException, IOException {
        return prepareReposUpdateCommitCommentRequest(owner, repo, commentId, body).execute();
    }

    /**
     * Update a commit comment.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commentId  Required parameter: The unique identifier of the comment.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposCommentsCommentIdResponse response from the API call
     */
    public CompletableFuture<ReposCommentsCommentIdResponse> reposUpdateCommitCommentAsync(
            final String owner,
            final String repo,
            final int commentId,
            final ReposCommentsCommentIdRequest body) {
        try { 
            return prepareReposUpdateCommitCommentRequest(owner, repo, commentId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposUpdateCommitComment.
     */
    private ApiCall<ReposCommentsCommentIdResponse, ApiException> prepareReposUpdateCommitCommentRequest(
            final String owner,
            final String repo,
            final int commentId,
            final ReposCommentsCommentIdRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposCommentsCommentIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/comments/{comment_id}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("comment_id").value(commentId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCommentsCommentIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposCommentsCommentId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Delete a commit comment.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commentId  Required parameter: The unique identifier of the comment.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteCommitComment(
            final String owner,
            final String repo,
            final int commentId) throws ApiException, IOException {
        prepareReposDeleteCommitCommentRequest(owner, repo, commentId).execute();
    }

    /**
     * Delete a commit comment.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commentId  Required parameter: The unique identifier of the comment.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteCommitCommentAsync(
            final String owner,
            final String repo,
            final int commentId) {
        try { 
            return prepareReposDeleteCommitCommentRequest(owner, repo, commentId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteCommitComment.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteCommitCommentRequest(
            final String owner,
            final String repo,
            final int commentId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/comments/{comment_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("comment_id").value(commentId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposCommentsCommentId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * **Signature verification object** The response will include a `verification` object that
     * describes the result of verifying the commit's signature. The following fields are included
     * in the `verification` object: | Name | Type | Description | | ---- | ---- | ----------- | |
     * `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to
     * be verified. | | `reason` | `string` | The reason for verified value. Possible values and
     * their meanings are enumerated in table below. | | `signature` | `string` | The signature that
     * was extracted from the commit. | | `payload` | `string` | The value that was signed. | These
     * are the possible values for `reason` in the `verification` object: | Value | Description | |
     * ----- | ----------- | | `expired_key` | The key that made the signature is expired. | |
     * `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made
     * the signature. | | `gpgverify_error` | There was an error communicating with the signature
     * verification service. | | `gpgverify_unavailable` | The signature verification service is
     * currently unavailable. | | `unsigned` | The object does not include a signature. | |
     * `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No
     * user was associated with the `committer` email address in the commit. | | `unverified_email`
     * | The `committer` email address in the commit was associated with a user, but the email
     * address is not verified on her/his account. | | `bad_email` | The `committer` email address
     * in the commit is not included in the identities of the PGP key that made the signature. | |
     * `unknown_key` | The key that made the signature has not been registered with any user's
     * account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid`
     * | The signature could not be cryptographically verified using the key whose key-id was found
     * in the signature. | | `valid` | None of the above errors applied, so the signature is
     * considered to be verified. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  sha  Optional parameter: SHA or branch to start listing commits from. Default: the
     *         repositorys default branch (usually `main`).
     * @param  path  Optional parameter: Only commits containing this file path will be returned.
     * @param  author  Optional parameter: GitHub login or email address by which to filter by
     *         commit author.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  until  Optional parameter: Only commits before this date will be returned. This is a
     *         timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Commit response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Commit> reposListCommits(
            final String owner,
            final String repo,
            final String sha,
            final String path,
            final String author,
            final LocalDateTime since,
            final LocalDateTime until,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListCommitsRequest(owner, repo, sha, path, author, since, until, perPage,
                page).execute();
    }

    /**
     * **Signature verification object** The response will include a `verification` object that
     * describes the result of verifying the commit's signature. The following fields are included
     * in the `verification` object: | Name | Type | Description | | ---- | ---- | ----------- | |
     * `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to
     * be verified. | | `reason` | `string` | The reason for verified value. Possible values and
     * their meanings are enumerated in table below. | | `signature` | `string` | The signature that
     * was extracted from the commit. | | `payload` | `string` | The value that was signed. | These
     * are the possible values for `reason` in the `verification` object: | Value | Description | |
     * ----- | ----------- | | `expired_key` | The key that made the signature is expired. | |
     * `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made
     * the signature. | | `gpgverify_error` | There was an error communicating with the signature
     * verification service. | | `gpgverify_unavailable` | The signature verification service is
     * currently unavailable. | | `unsigned` | The object does not include a signature. | |
     * `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No
     * user was associated with the `committer` email address in the commit. | | `unverified_email`
     * | The `committer` email address in the commit was associated with a user, but the email
     * address is not verified on her/his account. | | `bad_email` | The `committer` email address
     * in the commit is not included in the identities of the PGP key that made the signature. | |
     * `unknown_key` | The key that made the signature has not been registered with any user's
     * account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid`
     * | The signature could not be cryptographically verified using the key whose key-id was found
     * in the signature. | | `valid` | None of the above errors applied, so the signature is
     * considered to be verified. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  sha  Optional parameter: SHA or branch to start listing commits from. Default: the
     *         repositorys default branch (usually `main`).
     * @param  path  Optional parameter: Only commits containing this file path will be returned.
     * @param  author  Optional parameter: GitHub login or email address by which to filter by
     *         commit author.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  until  Optional parameter: Only commits before this date will be returned. This is a
     *         timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Commit response from the API call
     */
    public CompletableFuture<List<Commit>> reposListCommitsAsync(
            final String owner,
            final String repo,
            final String sha,
            final String path,
            final String author,
            final LocalDateTime since,
            final LocalDateTime until,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListCommitsRequest(owner, repo, sha, path, author, since, until, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListCommits.
     */
    private ApiCall<List<Commit>, ApiException> prepareReposListCommitsRequest(
            final String owner,
            final String repo,
            final String sha,
            final String path,
            final String author,
            final LocalDateTime since,
            final LocalDateTime until,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Commit>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/commits")
                        .queryParam(param -> param.key("sha")
                                .value(sha).isRequired(false))
                        .queryParam(param -> param.key("path")
                                .value(path).isRequired(false))
                        .queryParam(param -> param.key("author")
                                .value(author).isRequired(false))
                        .queryParam(param -> param.key("since")
                                .value(DateTimeHelper.toRfc8601DateTime(since)).isRequired(false))
                        .queryParam(param -> param.key("until")
                                .value(DateTimeHelper.toRfc8601DateTime(until)).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Commit[].class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new ReposCommits400ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposCommits404ErrorException(reason, context)))
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict",
                                (reason, context) -> new ReposCommits409ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new ReposCommits500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Returns all branches where the given commit SHA is the HEAD, or
     * latest commit for the branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commitSha  Required parameter: The SHA of the commit.
     * @return    Returns the List of BranchShort response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<BranchShort> reposListBranchesForHeadCommit(
            final String owner,
            final String repo,
            final String commitSha) throws ApiException, IOException {
        return prepareReposListBranchesForHeadCommitRequest(owner, repo, commitSha).execute();
    }

    /**
     * Protected branches are available in public repositories with GitHub Free and GitHub Free for
     * organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub
     * Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's
     * products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the
     * GitHub Help documentation. Returns all branches where the given commit SHA is the HEAD, or
     * latest commit for the branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commitSha  Required parameter: The SHA of the commit.
     * @return    Returns the List of BranchShort response from the API call
     */
    public CompletableFuture<List<BranchShort>> reposListBranchesForHeadCommitAsync(
            final String owner,
            final String repo,
            final String commitSha) {
        try { 
            return prepareReposListBranchesForHeadCommitRequest(owner, repo, commitSha).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListBranchesForHeadCommit.
     */
    private ApiCall<List<BranchShort>, ApiException> prepareReposListBranchesForHeadCommitRequest(
            final String owner,
            final String repo,
            final String commitSha) throws IOException {
        return new ApiCall.Builder<List<BranchShort>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("commit_sha").value(commitSha)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        BranchShort[].class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposCommitsCommitShaBranchesWhereHead422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Use the `:commit_sha` to specify the commit that will have its comments listed.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commitSha  Required parameter: The SHA of the commit.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of CommitComment response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<CommitComment> reposListCommentsForCommit(
            final String owner,
            final String repo,
            final String commitSha,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListCommentsForCommitRequest(owner, repo, commitSha, perPage,
                page).execute();
    }

    /**
     * Use the `:commit_sha` to specify the commit that will have its comments listed.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commitSha  Required parameter: The SHA of the commit.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of CommitComment response from the API call
     */
    public CompletableFuture<List<CommitComment>> reposListCommentsForCommitAsync(
            final String owner,
            final String repo,
            final String commitSha,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListCommentsForCommitRequest(owner, repo, commitSha, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListCommentsForCommit.
     */
    private ApiCall<List<CommitComment>, ApiException> prepareReposListCommentsForCommitRequest(
            final String owner,
            final String repo,
            final String commitSha,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<CommitComment>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/commits/{commit_sha}/comments")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("commit_sha").value(commitSha)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        CommitComment[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Create a comment for a commit using its `:commit_sha`. This endpoint triggers
     * [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
     * Creating content too quickly using this endpoint may result in secondary rate limiting. See
     * "[Secondary rate
     * limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
     * and "[Dealing with secondary rate
     * limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)"
     * for details.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commitSha  Required parameter: The SHA of the commit.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposCommitsCommitShaCommentsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCommitsCommitShaCommentsResponse reposCreateCommitComment(
            final String owner,
            final String repo,
            final String commitSha,
            final ReposCommitsCommitShaCommentsRequest body) throws ApiException, IOException {
        return prepareReposCreateCommitCommentRequest(owner, repo, commitSha, body).execute();
    }

    /**
     * Create a comment for a commit using its `:commit_sha`. This endpoint triggers
     * [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
     * Creating content too quickly using this endpoint may result in secondary rate limiting. See
     * "[Secondary rate
     * limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
     * and "[Dealing with secondary rate
     * limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)"
     * for details.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commitSha  Required parameter: The SHA of the commit.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposCommitsCommitShaCommentsResponse response from the API call
     */
    public CompletableFuture<ReposCommitsCommitShaCommentsResponse> reposCreateCommitCommentAsync(
            final String owner,
            final String repo,
            final String commitSha,
            final ReposCommitsCommitShaCommentsRequest body) {
        try { 
            return prepareReposCreateCommitCommentRequest(owner, repo, commitSha, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateCommitComment.
     */
    private ApiCall<ReposCommitsCommitShaCommentsResponse, ApiException> prepareReposCreateCommitCommentRequest(
            final String owner,
            final String repo,
            final String commitSha,
            final ReposCommitsCommitShaCommentsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposCommitsCommitShaCommentsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/commits/{commit_sha}/comments")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("commit_sha").value(commitSha)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCommitsCommitShaCommentsResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposCommitsCommitShaComments403ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposCommitsCommitShaComments422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the merged pull request that introduced the commit to the repository. If the commit is
     * not present in the default branch, will only return open pull requests associated with the
     * commit.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commitSha  Required parameter: The SHA of the commit.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of PullRequestSimple response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<PullRequestSimple> reposListPullRequestsAssociatedWithCommit(
            final String owner,
            final String repo,
            final String commitSha,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListPullRequestsAssociatedWithCommitRequest(owner, repo, commitSha,
                perPage, page).execute();
    }

    /**
     * Lists the merged pull request that introduced the commit to the repository. If the commit is
     * not present in the default branch, will only return open pull requests associated with the
     * commit.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commitSha  Required parameter: The SHA of the commit.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of PullRequestSimple response from the API call
     */
    public CompletableFuture<List<PullRequestSimple>> reposListPullRequestsAssociatedWithCommitAsync(
            final String owner,
            final String repo,
            final String commitSha,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListPullRequestsAssociatedWithCommitRequest(owner, repo, commitSha, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListPullRequestsAssociatedWithCommit.
     */
    private ApiCall<List<PullRequestSimple>, ApiException> prepareReposListPullRequestsAssociatedWithCommitRequest(
            final String owner,
            final String repo,
            final String commitSha,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<PullRequestSimple>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/commits/{commit_sha}/pulls")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("commit_sha").value(commitSha)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        PullRequestSimple[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns the contents of a single commit reference. You must have `read` access for the
     * repository to use this endpoint. **Note:** If there are more than 300 files in the commit
     * diff, the response will include pagination link headers for the remaining files, up to a
     * limit of 3000 files. Each page contains the static commit information, and the only changes
     * are to the file listing. You can pass the appropriate [media
     * type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests)
     * to fetch `diff` and `patch` formats. Diffs with binary data will have no `patch` property. To
     * return only the SHA-1 hash of the commit reference, you can provide the `sha` custom [media
     * type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests)
     * in the `Accept` header. You can use this endpoint to check if a remote reference's SHA-1 hash
     * is the same as your local reference's SHA-1 hash by providing the local SHA-1 reference as
     * the ETag. **Signature verification object** The response will include a `verification` object
     * that describes the result of verifying the commit's signature. The following fields are
     * included in the `verification` object: | Name | Type | Description | | ---- | ---- |
     * ----------- | | `verified` | `boolean` | Indicates whether GitHub considers the signature in
     * this commit to be verified. | | `reason` | `string` | The reason for verified value. Possible
     * values and their meanings are enumerated in table below. | | `signature` | `string` | The
     * signature that was extracted from the commit. | | `payload` | `string` | The value that was
     * signed. | These are the possible values for `reason` in the `verification` object: | Value |
     * Description | | ----- | ----------- | | `expired_key` | The key that made the signature is
     * expired. | | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG
     * key that made the signature. | | `gpgverify_error` | There was an error communicating with
     * the signature verification service. | | `gpgverify_unavailable` | The signature verification
     * service is currently unavailable. | | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No
     * user was associated with the `committer` email address in the commit. | | `unverified_email`
     * | The `committer` email address in the commit was associated with a user, but the email
     * address is not verified on her/his account. | | `bad_email` | The `committer` email address
     * in the commit is not included in the identities of the PGP key that made the signature. | |
     * `unknown_key` | The key that made the signature has not been registered with any user's
     * account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid`
     * | The signature could not be cryptographically verified using the key whose key-id was found
     * in the signature. | | `valid` | None of the above errors applied, so the signature is
     * considered to be verified. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: ref parameter
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the ReposCommitsRefResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCommitsRefResponse reposGetCommit(
            final String owner,
            final String repo,
            final String ref,
            final Integer page,
            final Integer perPage) throws ApiException, IOException {
        return prepareReposGetCommitRequest(owner, repo, ref, page, perPage).execute();
    }

    /**
     * Returns the contents of a single commit reference. You must have `read` access for the
     * repository to use this endpoint. **Note:** If there are more than 300 files in the commit
     * diff, the response will include pagination link headers for the remaining files, up to a
     * limit of 3000 files. Each page contains the static commit information, and the only changes
     * are to the file listing. You can pass the appropriate [media
     * type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests)
     * to fetch `diff` and `patch` formats. Diffs with binary data will have no `patch` property. To
     * return only the SHA-1 hash of the commit reference, you can provide the `sha` custom [media
     * type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests)
     * in the `Accept` header. You can use this endpoint to check if a remote reference's SHA-1 hash
     * is the same as your local reference's SHA-1 hash by providing the local SHA-1 reference as
     * the ETag. **Signature verification object** The response will include a `verification` object
     * that describes the result of verifying the commit's signature. The following fields are
     * included in the `verification` object: | Name | Type | Description | | ---- | ---- |
     * ----------- | | `verified` | `boolean` | Indicates whether GitHub considers the signature in
     * this commit to be verified. | | `reason` | `string` | The reason for verified value. Possible
     * values and their meanings are enumerated in table below. | | `signature` | `string` | The
     * signature that was extracted from the commit. | | `payload` | `string` | The value that was
     * signed. | These are the possible values for `reason` in the `verification` object: | Value |
     * Description | | ----- | ----------- | | `expired_key` | The key that made the signature is
     * expired. | | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG
     * key that made the signature. | | `gpgverify_error` | There was an error communicating with
     * the signature verification service. | | `gpgverify_unavailable` | The signature verification
     * service is currently unavailable. | | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No
     * user was associated with the `committer` email address in the commit. | | `unverified_email`
     * | The `committer` email address in the commit was associated with a user, but the email
     * address is not verified on her/his account. | | `bad_email` | The `committer` email address
     * in the commit is not included in the identities of the PGP key that made the signature. | |
     * `unknown_key` | The key that made the signature has not been registered with any user's
     * account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid`
     * | The signature could not be cryptographically verified using the key whose key-id was found
     * in the signature. | | `valid` | None of the above errors applied, so the signature is
     * considered to be verified. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: ref parameter
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the ReposCommitsRefResponse response from the API call
     */
    public CompletableFuture<ReposCommitsRefResponse> reposGetCommitAsync(
            final String owner,
            final String repo,
            final String ref,
            final Integer page,
            final Integer perPage) {
        try { 
            return prepareReposGetCommitRequest(owner, repo, ref, page, perPage).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetCommit.
     */
    private ApiCall<ReposCommitsRefResponse, ApiException> prepareReposGetCommitRequest(
            final String owner,
            final String repo,
            final String ref,
            final Integer page,
            final Integer perPage) throws IOException {
        return new ApiCall.Builder<ReposCommitsRefResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/commits/{ref}")
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("ref").value(ref)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCommitsRefResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposCommitsRef404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposCommitsRef422ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new ReposCommitsRef500ErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.create("Service unavailable",
                                (reason, context) -> new ServiceUnavailable1Exception(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Users with pull access in a repository can access a combined view of commit statuses for a
     * given ref. The ref can be a SHA, a branch name, or a tag name. Additionally, a combined
     * `state` is returned. The `state` is one of: * **failure** if any of the contexts report as
     * `error` or `failure` * **pending** if there are no statuses or a context is `pending` *
     * **success** if the latest status for all contexts is `success`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: ref parameter
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposCommitsRefStatusResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCommitsRefStatusResponse reposGetCombinedStatusForRef(
            final String owner,
            final String repo,
            final String ref,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposGetCombinedStatusForRefRequest(owner, repo, ref, perPage,
                page).execute();
    }

    /**
     * Users with pull access in a repository can access a combined view of commit statuses for a
     * given ref. The ref can be a SHA, a branch name, or a tag name. Additionally, a combined
     * `state` is returned. The `state` is one of: * **failure** if any of the contexts report as
     * `error` or `failure` * **pending** if there are no statuses or a context is `pending` *
     * **success** if the latest status for all contexts is `success`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: ref parameter
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposCommitsRefStatusResponse response from the API call
     */
    public CompletableFuture<ReposCommitsRefStatusResponse> reposGetCombinedStatusForRefAsync(
            final String owner,
            final String repo,
            final String ref,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposGetCombinedStatusForRefRequest(owner, repo, ref, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetCombinedStatusForRef.
     */
    private ApiCall<ReposCommitsRefStatusResponse, ApiException> prepareReposGetCombinedStatusForRefRequest(
            final String owner,
            final String repo,
            final String ref,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposCommitsRefStatusResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/commits/{ref}/status")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("ref").value(ref)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCommitsRefStatusResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposCommitsRefStatus404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Users with pull access in a repository can view commit statuses for a given ref. The ref can
     * be a SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order.
     * The first status in the list will be the latest one. This resource is also available via a
     * legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: ref parameter
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Status response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Status> reposListCommitStatusesForRef(
            final String owner,
            final String repo,
            final String ref,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListCommitStatusesForRefRequest(owner, repo, ref, perPage,
                page).execute();
    }

    /**
     * Users with pull access in a repository can view commit statuses for a given ref. The ref can
     * be a SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order.
     * The first status in the list will be the latest one. This resource is also available via a
     * legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: ref parameter
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Status response from the API call
     */
    public CompletableFuture<List<Status>> reposListCommitStatusesForRefAsync(
            final String owner,
            final String repo,
            final String ref,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListCommitStatusesForRefRequest(owner, repo, ref, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListCommitStatusesForRef.
     */
    private ApiCall<List<Status>, ApiException> prepareReposListCommitStatusesForRefRequest(
            final String owner,
            final String repo,
            final String ref,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Status>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/commits/{ref}/statuses")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("ref").value(ref)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Status[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns all community profile metrics for a repository. The repository cannot be a fork. The
     * returned metrics include an overall health score, the repository description, the presence of
     * documentation, the detected code of conduct, the detected license, and the presence of
     * ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE, README, and CONTRIBUTING files. The
     * `health_percentage` score is defined as a percentage of how many of these four documents are
     * present: README, CONTRIBUTING, LICENSE, and CODE_OF_CONDUCT. For example, if all four
     * documents are present, then the `health_percentage` is `100`. If only one is present, then
     * the `health_percentage` is `25`. `content_reports_enabled` is only returned for
     * organization-owned repositories.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposCommunityProfileResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCommunityProfileResponse reposGetCommunityProfileMetrics(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposGetCommunityProfileMetricsRequest(owner, repo).execute();
    }

    /**
     * Returns all community profile metrics for a repository. The repository cannot be a fork. The
     * returned metrics include an overall health score, the repository description, the presence of
     * documentation, the detected code of conduct, the detected license, and the presence of
     * ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE, README, and CONTRIBUTING files. The
     * `health_percentage` score is defined as a percentage of how many of these four documents are
     * present: README, CONTRIBUTING, LICENSE, and CODE_OF_CONDUCT. For example, if all four
     * documents are present, then the `health_percentage` is `100`. If only one is present, then
     * the `health_percentage` is `25`. `content_reports_enabled` is only returned for
     * organization-owned repositories.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposCommunityProfileResponse response from the API call
     */
    public CompletableFuture<ReposCommunityProfileResponse> reposGetCommunityProfileMetricsAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposGetCommunityProfileMetricsRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetCommunityProfileMetrics.
     */
    private ApiCall<ReposCommunityProfileResponse, ApiException> prepareReposGetCommunityProfileMetricsRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposCommunityProfileResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/community/profile")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCommunityProfileResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Compares two commits against one another. You can compare branches in the same repository, or
     * you can compare branches that exist in different repositories within the same repository
     * network, including fork branches. For more information about how to view a repository's
     * network, see "[Understanding connections between
     * repositories](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository/understanding-connections-between-repositories)."
     * This endpoint is equivalent to running the `git log BASE...HEAD` command, but it returns
     * commits in a different order. The `git log BASE...HEAD` command returns commits in reverse
     * chronological order, whereas the API returns commits in chronological order. You can pass the
     * appropriate [media
     * type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests)
     * to fetch diff and patch formats. The API response includes details about the files that were
     * changed between the two commits. This includes the status of the change (if a file was added,
     * removed, modified, or renamed), and details of the change itself. For example, files with a
     * `renamed` status have a `previous_filename` field showing the previous filename of the file,
     * and files with a `modified` status have a `patch` field showing the changes made to the file.
     * When calling this endpoint without any paging parameter (`per_page` or `page`), the returned
     * list is limited to 250 commits, and the last commit in the list is the most recent of the
     * entire comparison. **Working with large comparisons** To process a response with a large
     * number of commits, use a query parameter (`per_page` or `page`) to paginate the results. When
     * using pagination: - The list of changed files is only shown on the first page of results, but
     * it includes all changed files for the entire comparison. - The results are returned in
     * chronological order, but the last commit in the returned list may not be the most recent one
     * in the entire set if there are more pages of results. For more information on working with
     * pagination, see "[Using pagination in the REST
     * API](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api)." **Signature
     * verification object** The response will include a `verification` object that describes the
     * result of verifying the commit's signature. The `verification` object includes the following
     * fields: | Name | Type | Description | | ---- | ---- | ----------- | | `verified` | `boolean`
     * | Indicates whether GitHub considers the signature in this commit to be verified. | |
     * `reason` | `string` | The reason for verified value. Possible values and their meanings are
     * enumerated in table below. | | `signature` | `string` | The signature that was extracted from
     * the commit. | | `payload` | `string` | The value that was signed. | These are the possible
     * values for `reason` in the `verification` object: | Value | Description | | ----- |
     * ----------- | | `expired_key` | The key that made the signature is expired. | |
     * `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made
     * the signature. | | `gpgverify_error` | There was an error communicating with the signature
     * verification service. | | `gpgverify_unavailable` | The signature verification service is
     * currently unavailable. | | `unsigned` | The object does not include a signature. | |
     * `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No
     * user was associated with the `committer` email address in the commit. | | `unverified_email`
     * | The `committer` email address in the commit was associated with a user, but the email
     * address is not verified on her/his account. | | `bad_email` | The `committer` email address
     * in the commit is not included in the identities of the PGP key that made the signature. | |
     * `unknown_key` | The key that made the signature has not been registered with any user's
     * account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid`
     * | The signature could not be cryptographically verified using the key whose key-id was found
     * in the signature. | | `valid` | None of the above errors applied, so the signature is
     * considered to be verified. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  basehead  Required parameter: The base branch and head branch to compare. This
     *         parameter expects the format `BASE...HEAD`. Both must be branch names in `repo`. To
     *         compare with a branch that exists in a different repository in the same network as
     *         `repo`, the `basehead` parameter expects the format `USERNAME:BASE...USERNAME:HEAD`.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the ReposCompareBaseheadResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposCompareBaseheadResponse reposCompareCommits(
            final String owner,
            final String repo,
            final String basehead,
            final Integer page,
            final Integer perPage) throws ApiException, IOException {
        return prepareReposCompareCommitsRequest(owner, repo, basehead, page, perPage).execute();
    }

    /**
     * Compares two commits against one another. You can compare branches in the same repository, or
     * you can compare branches that exist in different repositories within the same repository
     * network, including fork branches. For more information about how to view a repository's
     * network, see "[Understanding connections between
     * repositories](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository/understanding-connections-between-repositories)."
     * This endpoint is equivalent to running the `git log BASE...HEAD` command, but it returns
     * commits in a different order. The `git log BASE...HEAD` command returns commits in reverse
     * chronological order, whereas the API returns commits in chronological order. You can pass the
     * appropriate [media
     * type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests)
     * to fetch diff and patch formats. The API response includes details about the files that were
     * changed between the two commits. This includes the status of the change (if a file was added,
     * removed, modified, or renamed), and details of the change itself. For example, files with a
     * `renamed` status have a `previous_filename` field showing the previous filename of the file,
     * and files with a `modified` status have a `patch` field showing the changes made to the file.
     * When calling this endpoint without any paging parameter (`per_page` or `page`), the returned
     * list is limited to 250 commits, and the last commit in the list is the most recent of the
     * entire comparison. **Working with large comparisons** To process a response with a large
     * number of commits, use a query parameter (`per_page` or `page`) to paginate the results. When
     * using pagination: - The list of changed files is only shown on the first page of results, but
     * it includes all changed files for the entire comparison. - The results are returned in
     * chronological order, but the last commit in the returned list may not be the most recent one
     * in the entire set if there are more pages of results. For more information on working with
     * pagination, see "[Using pagination in the REST
     * API](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api)." **Signature
     * verification object** The response will include a `verification` object that describes the
     * result of verifying the commit's signature. The `verification` object includes the following
     * fields: | Name | Type | Description | | ---- | ---- | ----------- | | `verified` | `boolean`
     * | Indicates whether GitHub considers the signature in this commit to be verified. | |
     * `reason` | `string` | The reason for verified value. Possible values and their meanings are
     * enumerated in table below. | | `signature` | `string` | The signature that was extracted from
     * the commit. | | `payload` | `string` | The value that was signed. | These are the possible
     * values for `reason` in the `verification` object: | Value | Description | | ----- |
     * ----------- | | `expired_key` | The key that made the signature is expired. | |
     * `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made
     * the signature. | | `gpgverify_error` | There was an error communicating with the signature
     * verification service. | | `gpgverify_unavailable` | The signature verification service is
     * currently unavailable. | | `unsigned` | The object does not include a signature. | |
     * `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No
     * user was associated with the `committer` email address in the commit. | | `unverified_email`
     * | The `committer` email address in the commit was associated with a user, but the email
     * address is not verified on her/his account. | | `bad_email` | The `committer` email address
     * in the commit is not included in the identities of the PGP key that made the signature. | |
     * `unknown_key` | The key that made the signature has not been registered with any user's
     * account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid`
     * | The signature could not be cryptographically verified using the key whose key-id was found
     * in the signature. | | `valid` | None of the above errors applied, so the signature is
     * considered to be verified. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  basehead  Required parameter: The base branch and head branch to compare. This
     *         parameter expects the format `BASE...HEAD`. Both must be branch names in `repo`. To
     *         compare with a branch that exists in a different repository in the same network as
     *         `repo`, the `basehead` parameter expects the format `USERNAME:BASE...USERNAME:HEAD`.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the ReposCompareBaseheadResponse response from the API call
     */
    public CompletableFuture<ReposCompareBaseheadResponse> reposCompareCommitsAsync(
            final String owner,
            final String repo,
            final String basehead,
            final Integer page,
            final Integer perPage) {
        try { 
            return prepareReposCompareCommitsRequest(owner, repo, basehead, page, perPage).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCompareCommits.
     */
    private ApiCall<ReposCompareBaseheadResponse, ApiException> prepareReposCompareCommitsRequest(
            final String owner,
            final String repo,
            final String basehead,
            final Integer page,
            final Integer perPage) throws IOException {
        return new ApiCall.Builder<ReposCompareBaseheadResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/compare/{basehead}")
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("basehead").value(basehead)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposCompareBaseheadResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposCompareBasehead404ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new ReposCompareBasehead500ErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.create("Service unavailable",
                                (reason, context) -> new ServiceUnavailable1Exception(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the contents of a file or directory in a repository. Specify the file path or directory
     * in `:path`. If you omit `:path`, you will receive the contents of the repository's root
     * directory. See the description below regarding what the API response includes for
     * directories. Files and symlinks support [a custom media
     * type](https://docs.github.com/rest/reference/repos#custom-media-types) for retrieving the raw
     * content or rendered HTML (when supported). All content types support [a custom media
     * type](https://docs.github.com/rest/reference/repos#custom-media-types) to ensure the content
     * is returned in a consistent object format. **Notes**: * To get a repository's contents
     * recursively, you can [recursively get the
     * tree](https://docs.github.com/rest/reference/git#trees). * This API has an upper limit of
     * 1,000 files for a directory. If you need to retrieve more files, use the [Git Trees
     * API](https://docs.github.com/rest/reference/git#get-a-tree). * Download URLs expire and are
     * meant to be used just once. To ensure the download URL does not expire, please use the
     * contents API to obtain a fresh download URL for each download. #### Size limits If the
     * requested file's size is: * 1 MB or smaller: All features of this endpoint are supported. *
     * Between 1-100 MB: Only the `raw` or `object` [custom media
     * types](https://docs.github.com/rest/repos/contents#custom-media-types-for-repository-contents)
     * are supported. Both will work as normal, except that when using the `object` media type, the
     * `content` field will be an empty string and the `encoding` field will be `"none"`. To get the
     * contents of these larger files, use the `raw` media type. * Greater than 100 MB: This
     * endpoint is not supported. #### If the content is a directory The response will be an array
     * of objects, one object for each item in the directory. When listing the contents of a
     * directory, submodules have their "type" specified as "file". Logically, the value _should_ be
     * "submodule". This behavior exists in API v3 [for backwards compatibility
     * purposes](https://git.io/v1YCW). In the next major version of the API, the type will be
     * returned as "submodule". #### If the content is a symlink If the requested `:path` points to
     * a symlink, and the symlink's target is a normal file in the repository, then the API responds
     * with the content of the file (in the format shown in the example. Otherwise, the API responds
     * with an object describing the symlink itself. #### If the content is a submodule The
     * `submodule_git_url` identifies the location of the submodule repository, and the `sha`
     * identifies a specific commit within the submodule repository. Git uses the given URL when
     * cloning the submodule repository, and checks out the submodule at that specific commit. If
     * the submodule repository is not hosted on github.com, the Git URLs (`git_url` and
     * `_links["git"]`) and the github.com URLs (`html_url` and `_links["html"]`) will have null
     * values.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  path  Required parameter: path parameter
     * @param  ref  Optional parameter: The name of the commit/branch/tag. Default: the repositorys
     *         default branch (usually `master`)
     * @return    Returns the ReposGetContentResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposGetContentResponse reposGetContent(
            final String owner,
            final String repo,
            final String path,
            final String ref) throws ApiException, IOException {
        return prepareReposGetContentRequest(owner, repo, path, ref).execute();
    }

    /**
     * Gets the contents of a file or directory in a repository. Specify the file path or directory
     * in `:path`. If you omit `:path`, you will receive the contents of the repository's root
     * directory. See the description below regarding what the API response includes for
     * directories. Files and symlinks support [a custom media
     * type](https://docs.github.com/rest/reference/repos#custom-media-types) for retrieving the raw
     * content or rendered HTML (when supported). All content types support [a custom media
     * type](https://docs.github.com/rest/reference/repos#custom-media-types) to ensure the content
     * is returned in a consistent object format. **Notes**: * To get a repository's contents
     * recursively, you can [recursively get the
     * tree](https://docs.github.com/rest/reference/git#trees). * This API has an upper limit of
     * 1,000 files for a directory. If you need to retrieve more files, use the [Git Trees
     * API](https://docs.github.com/rest/reference/git#get-a-tree). * Download URLs expire and are
     * meant to be used just once. To ensure the download URL does not expire, please use the
     * contents API to obtain a fresh download URL for each download. #### Size limits If the
     * requested file's size is: * 1 MB or smaller: All features of this endpoint are supported. *
     * Between 1-100 MB: Only the `raw` or `object` [custom media
     * types](https://docs.github.com/rest/repos/contents#custom-media-types-for-repository-contents)
     * are supported. Both will work as normal, except that when using the `object` media type, the
     * `content` field will be an empty string and the `encoding` field will be `"none"`. To get the
     * contents of these larger files, use the `raw` media type. * Greater than 100 MB: This
     * endpoint is not supported. #### If the content is a directory The response will be an array
     * of objects, one object for each item in the directory. When listing the contents of a
     * directory, submodules have their "type" specified as "file". Logically, the value _should_ be
     * "submodule". This behavior exists in API v3 [for backwards compatibility
     * purposes](https://git.io/v1YCW). In the next major version of the API, the type will be
     * returned as "submodule". #### If the content is a symlink If the requested `:path` points to
     * a symlink, and the symlink's target is a normal file in the repository, then the API responds
     * with the content of the file (in the format shown in the example. Otherwise, the API responds
     * with an object describing the symlink itself. #### If the content is a submodule The
     * `submodule_git_url` identifies the location of the submodule repository, and the `sha`
     * identifies a specific commit within the submodule repository. Git uses the given URL when
     * cloning the submodule repository, and checks out the submodule at that specific commit. If
     * the submodule repository is not hosted on github.com, the Git URLs (`git_url` and
     * `_links["git"]`) and the github.com URLs (`html_url` and `_links["html"]`) will have null
     * values.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  path  Required parameter: path parameter
     * @param  ref  Optional parameter: The name of the commit/branch/tag. Default: the repositorys
     *         default branch (usually `master`)
     * @return    Returns the ReposGetContentResponse response from the API call
     */
    public CompletableFuture<ReposGetContentResponse> reposGetContentAsync(
            final String owner,
            final String repo,
            final String path,
            final String ref) {
        try { 
            return prepareReposGetContentRequest(owner, repo, path, ref).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetContent.
     */
    private ApiCall<ReposGetContentResponse, ApiException> prepareReposGetContentRequest(
            final String owner,
            final String repo,
            final String path,
            final String ref) throws IOException {
        return new ApiCall.Builder<ReposGetContentResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/contents/{path}")
                        .queryParam(param -> param.key("ref")
                                .value(ref).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("path").value(path)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposGetContentResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposContentsPath403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposContentsPath404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates a new file or replaces an existing file in a repository. You must authenticate using
     * an access token with the `workflow` scope to use this endpoint. **Note:** If you use this
     * endpoint and the "[Delete a file](https://docs.github.com/rest/reference/repos/#delete-file)"
     * endpoint in parallel, the concurrent requests will conflict and you will receive errors. You
     * must use these endpoints serially instead.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  path  Required parameter: path parameter
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposContentsPathResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposContentsPathResponse reposCreateOrUpdateFileContents(
            final String owner,
            final String repo,
            final String path,
            final ReposContentsPathRequest body) throws ApiException, IOException {
        return prepareReposCreateOrUpdateFileContentsRequest(owner, repo, path, body).execute();
    }

    /**
     * Creates a new file or replaces an existing file in a repository. You must authenticate using
     * an access token with the `workflow` scope to use this endpoint. **Note:** If you use this
     * endpoint and the "[Delete a file](https://docs.github.com/rest/reference/repos/#delete-file)"
     * endpoint in parallel, the concurrent requests will conflict and you will receive errors. You
     * must use these endpoints serially instead.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  path  Required parameter: path parameter
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposContentsPathResponse response from the API call
     */
    public CompletableFuture<ReposContentsPathResponse> reposCreateOrUpdateFileContentsAsync(
            final String owner,
            final String repo,
            final String path,
            final ReposContentsPathRequest body) {
        try { 
            return prepareReposCreateOrUpdateFileContentsRequest(owner, repo, path, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateOrUpdateFileContents.
     */
    private ApiCall<ReposContentsPathResponse, ApiException> prepareReposCreateOrUpdateFileContentsRequest(
            final String owner,
            final String repo,
            final String path,
            final ReposContentsPathRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposContentsPathResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/contents/{path}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("path").value(path)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposContentsPathResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposContentsPath404ErrorException(reason, context)))
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict",
                                (reason, context) -> new ReposContentsPath409ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposContentsPath422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a file in a repository. You can provide an additional `committer` parameter, which is
     * an object containing information about the committer. Or, you can provide an `author`
     * parameter, which is an object containing information about the author. The `author` section
     * is optional and is filled in with the `committer` information if omitted. If the `committer`
     * information is omitted, the authenticated user's information is used. You must provide values
     * for both `name` and `email`, whether you choose to use `author` or `committer`. Otherwise,
     * you'll receive a `422` status code. **Note:** If you use this endpoint and the "[Create or
     * update file
     * contents](https://docs.github.com/rest/reference/repos/#create-or-update-file-contents)"
     * endpoint in parallel, the concurrent requests will conflict and you will receive errors. You
     * must use these endpoints serially instead.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  path  Required parameter: path parameter
     * @param  contentType  Required parameter: Example:
     * @return    Returns the ReposContentsPathResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposContentsPathResponse reposDeleteFile(
            final String owner,
            final String repo,
            final String path,
            final ContentType3Enum contentType) throws ApiException, IOException {
        return prepareReposDeleteFileRequest(owner, repo, path, contentType).execute();
    }

    /**
     * Deletes a file in a repository. You can provide an additional `committer` parameter, which is
     * an object containing information about the committer. Or, you can provide an `author`
     * parameter, which is an object containing information about the author. The `author` section
     * is optional and is filled in with the `committer` information if omitted. If the `committer`
     * information is omitted, the authenticated user's information is used. You must provide values
     * for both `name` and `email`, whether you choose to use `author` or `committer`. Otherwise,
     * you'll receive a `422` status code. **Note:** If you use this endpoint and the "[Create or
     * update file
     * contents](https://docs.github.com/rest/reference/repos/#create-or-update-file-contents)"
     * endpoint in parallel, the concurrent requests will conflict and you will receive errors. You
     * must use these endpoints serially instead.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  path  Required parameter: path parameter
     * @param  contentType  Required parameter: Example:
     * @return    Returns the ReposContentsPathResponse response from the API call
     */
    public CompletableFuture<ReposContentsPathResponse> reposDeleteFileAsync(
            final String owner,
            final String repo,
            final String path,
            final ContentType3Enum contentType) {
        try { 
            return prepareReposDeleteFileRequest(owner, repo, path, contentType).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteFile.
     */
    private ApiCall<ReposContentsPathResponse, ApiException> prepareReposDeleteFileRequest(
            final String owner,
            final String repo,
            final String path,
            final ContentType3Enum contentType) throws IOException {
        return new ApiCall.Builder<ReposContentsPathResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/contents/{path}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("path").value(path)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value((contentType != null) ? contentType.value() : null).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposContentsPathResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposContentsPath404ErrorException(reason, context)))
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict",
                                (reason, context) -> new ReposContentsPath409ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposContentsPath422ErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.create("Service unavailable",
                                (reason, context) -> new ServiceUnavailable1Exception(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists contributors to the specified repository and sorts them by the number of commits per
     * contributor in descending order. This endpoint may return information that is a few hours old
     * because the GitHub REST API caches contributor data to improve performance. GitHub identifies
     * contributors by author email address. This endpoint groups contribution counts by GitHub
     * user, which includes all associated email addresses. To improve performance, only the first
     * 500 author email addresses in the repository link to GitHub users. The rest will appear as
     * anonymous contributors without associated GitHub user information.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  anon  Optional parameter: Set to `1` or `true` to include anonymous contributors in
     *         results.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Contributor response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Contributor> reposListContributors(
            final String owner,
            final String repo,
            final String anon,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListContributorsRequest(owner, repo, anon, perPage, page).execute();
    }

    /**
     * Lists contributors to the specified repository and sorts them by the number of commits per
     * contributor in descending order. This endpoint may return information that is a few hours old
     * because the GitHub REST API caches contributor data to improve performance. GitHub identifies
     * contributors by author email address. This endpoint groups contribution counts by GitHub
     * user, which includes all associated email addresses. To improve performance, only the first
     * 500 author email addresses in the repository link to GitHub users. The rest will appear as
     * anonymous contributors without associated GitHub user information.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  anon  Optional parameter: Set to `1` or `true` to include anonymous contributors in
     *         results.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Contributor response from the API call
     */
    public CompletableFuture<List<Contributor>> reposListContributorsAsync(
            final String owner,
            final String repo,
            final String anon,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListContributorsRequest(owner, repo, anon, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListContributors.
     */
    private ApiCall<List<Contributor>, ApiException> prepareReposListContributorsRequest(
            final String owner,
            final String repo,
            final String anon,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Contributor>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/contributors")
                        .queryParam(param -> param.key("anon")
                                .value(anon).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Contributor[].class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposContributors403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposContributors404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Simple filtering of deployments is available via query parameters:.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  sha  Optional parameter: The SHA recorded at creation time.
     * @param  ref  Optional parameter: The name of the ref. This can be a branch, tag, or SHA.
     * @param  task  Optional parameter: The name of the task for the deployment (e.g., `deploy` or
     *         `deploy:migrations`).
     * @param  environment  Optional parameter: The name of the environment that was deployed to
     *         (e.g., `staging` or `production`).
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Deployment response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Deployment> reposListDeployments(
            final String owner,
            final String repo,
            final String sha,
            final String ref,
            final String task,
            final String environment,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListDeploymentsRequest(owner, repo, sha, ref, task, environment, perPage,
                page).execute();
    }

    /**
     * Simple filtering of deployments is available via query parameters:.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  sha  Optional parameter: The SHA recorded at creation time.
     * @param  ref  Optional parameter: The name of the ref. This can be a branch, tag, or SHA.
     * @param  task  Optional parameter: The name of the task for the deployment (e.g., `deploy` or
     *         `deploy:migrations`).
     * @param  environment  Optional parameter: The name of the environment that was deployed to
     *         (e.g., `staging` or `production`).
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Deployment response from the API call
     */
    public CompletableFuture<List<Deployment>> reposListDeploymentsAsync(
            final String owner,
            final String repo,
            final String sha,
            final String ref,
            final String task,
            final String environment,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListDeploymentsRequest(owner, repo, sha, ref, task, environment, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListDeployments.
     */
    private ApiCall<List<Deployment>, ApiException> prepareReposListDeploymentsRequest(
            final String owner,
            final String repo,
            final String sha,
            final String ref,
            final String task,
            final String environment,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Deployment>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/deployments")
                        .queryParam(param -> param.key("sha")
                                .value((sha != null) ? sha : "none").isRequired(false))
                        .queryParam(param -> param.key("ref")
                                .value((ref != null) ? ref : "none").isRequired(false))
                        .queryParam(param -> param.key("task")
                                .value((task != null) ? task : "none").isRequired(false))
                        .queryParam(param -> param.key("environment")
                                .value((environment != null) ? environment : "none").isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Deployment[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deployments offer a few configurable parameters with certain defaults. The `ref` parameter
     * can be any named branch, tag, or SHA. At GitHub we often deploy branches and verify them
     * before we merge a pull request. The `environment` parameter allows deployments to be issued
     * to different runtime environments. Teams often have multiple environments for verifying their
     * applications, such as `production`, `staging`, and `qa`. This parameter makes it easier to
     * track which environments have requested deployments. The default environment is `production`.
     * The `auto_merge` parameter is used to ensure that the requested ref is not behind the
     * repository's default branch. If the ref _is_ behind the default branch for the repository, we
     * will attempt to merge it for you. If the merge succeeds, the API will return a successful
     * merge commit. If merge conflicts prevent the merge from succeeding, the API will return a
     * failure response. By default, [commit
     * statuses](https://docs.github.com/rest/commits/statuses) for every submitted context must be
     * in a `success` state. The `required_contexts` parameter allows you to specify a subset of
     * contexts that must be `success`, or to specify contexts that have not yet been submitted. You
     * are not required to use commit statuses to deploy. If you do not require any contexts or
     * create any commit statuses, the deployment will always succeed. The `payload` parameter is
     * available for any extra information that a deployment system might need. It is a JSON text
     * field that will be passed on when a deployment event is dispatched. The `task` parameter is
     * used by the deployment system to allow different execution paths. In the web world this might
     * be `deploy:migrations` to run schema changes on the system. In the compiled world this could
     * be a flag to compile an application with debugging enabled. Users with `repo` or
     * `repo_deployment` scopes can create a deployment for a given ref. #### Merged branch response
     * You will see this response when GitHub automatically merges the base branch into the topic
     * branch instead of creating a deployment. This auto-merge happens when: * Auto-merge option is
     * enabled in the repository * Topic branch does not include the latest changes on the base
     * branch, which is `master` in the response example * There are no merge conflicts If there are
     * no new commits in the base branch, a new request to create a deployment should give a
     * successful response. #### Merge conflict response This error happens when the `auto_merge`
     * option is enabled and when the default branch (in this case `master`), can't be merged into
     * the branch that's being deployed (in this case `topic-branch`), due to merge conflicts. ####
     * Failed commit status checks This error happens when the `required_contexts` parameter
     * indicates that one or more contexts need to have a `success` status for the commit to be
     * deployed, but one or more of the required contexts do not have a state of `success`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposDeploymentsResponse1 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposDeploymentsResponse1 reposCreateDeployment(
            final String owner,
            final String repo,
            final ReposDeploymentsRequest body) throws ApiException, IOException {
        return prepareReposCreateDeploymentRequest(owner, repo, body).execute();
    }

    /**
     * Deployments offer a few configurable parameters with certain defaults. The `ref` parameter
     * can be any named branch, tag, or SHA. At GitHub we often deploy branches and verify them
     * before we merge a pull request. The `environment` parameter allows deployments to be issued
     * to different runtime environments. Teams often have multiple environments for verifying their
     * applications, such as `production`, `staging`, and `qa`. This parameter makes it easier to
     * track which environments have requested deployments. The default environment is `production`.
     * The `auto_merge` parameter is used to ensure that the requested ref is not behind the
     * repository's default branch. If the ref _is_ behind the default branch for the repository, we
     * will attempt to merge it for you. If the merge succeeds, the API will return a successful
     * merge commit. If merge conflicts prevent the merge from succeeding, the API will return a
     * failure response. By default, [commit
     * statuses](https://docs.github.com/rest/commits/statuses) for every submitted context must be
     * in a `success` state. The `required_contexts` parameter allows you to specify a subset of
     * contexts that must be `success`, or to specify contexts that have not yet been submitted. You
     * are not required to use commit statuses to deploy. If you do not require any contexts or
     * create any commit statuses, the deployment will always succeed. The `payload` parameter is
     * available for any extra information that a deployment system might need. It is a JSON text
     * field that will be passed on when a deployment event is dispatched. The `task` parameter is
     * used by the deployment system to allow different execution paths. In the web world this might
     * be `deploy:migrations` to run schema changes on the system. In the compiled world this could
     * be a flag to compile an application with debugging enabled. Users with `repo` or
     * `repo_deployment` scopes can create a deployment for a given ref. #### Merged branch response
     * You will see this response when GitHub automatically merges the base branch into the topic
     * branch instead of creating a deployment. This auto-merge happens when: * Auto-merge option is
     * enabled in the repository * Topic branch does not include the latest changes on the base
     * branch, which is `master` in the response example * There are no merge conflicts If there are
     * no new commits in the base branch, a new request to create a deployment should give a
     * successful response. #### Merge conflict response This error happens when the `auto_merge`
     * option is enabled and when the default branch (in this case `master`), can't be merged into
     * the branch that's being deployed (in this case `topic-branch`), due to merge conflicts. ####
     * Failed commit status checks This error happens when the `required_contexts` parameter
     * indicates that one or more contexts need to have a `success` status for the commit to be
     * deployed, but one or more of the required contexts do not have a state of `success`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposDeploymentsResponse1 response from the API call
     */
    public CompletableFuture<ReposDeploymentsResponse1> reposCreateDeploymentAsync(
            final String owner,
            final String repo,
            final ReposDeploymentsRequest body) {
        try { 
            return prepareReposCreateDeploymentRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateDeployment.
     */
    private ApiCall<ReposDeploymentsResponse1, ApiException> prepareReposCreateDeploymentRequest(
            final String owner,
            final String repo,
            final ReposDeploymentsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposDeploymentsResponse1, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/deployments")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposDeploymentsResponse1.class))
                        .nullify404(false)
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict when there is a merge conflict or the commit's status checks failed",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposDeployments422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get a deployment.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  deploymentId  Required parameter: deployment_id parameter
     * @return    Returns the ReposDeploymentsDeploymentIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposDeploymentsDeploymentIdResponse reposGetDeployment(
            final String owner,
            final String repo,
            final int deploymentId) throws ApiException, IOException {
        return prepareReposGetDeploymentRequest(owner, repo, deploymentId).execute();
    }

    /**
     * Get a deployment.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  deploymentId  Required parameter: deployment_id parameter
     * @return    Returns the ReposDeploymentsDeploymentIdResponse response from the API call
     */
    public CompletableFuture<ReposDeploymentsDeploymentIdResponse> reposGetDeploymentAsync(
            final String owner,
            final String repo,
            final int deploymentId) {
        try { 
            return prepareReposGetDeploymentRequest(owner, repo, deploymentId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetDeployment.
     */
    private ApiCall<ReposDeploymentsDeploymentIdResponse, ApiException> prepareReposGetDeploymentRequest(
            final String owner,
            final String repo,
            final int deploymentId) throws IOException {
        return new ApiCall.Builder<ReposDeploymentsDeploymentIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/deployments/{deployment_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("deployment_id").value(deploymentId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposDeploymentsDeploymentIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposDeploymentsDeploymentId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * If the repository only has one deployment, you can delete the deployment regardless of its
     * status. If the repository has more than one deployment, you can only delete inactive
     * deployments. This ensures that repositories with multiple deployments will always have an
     * active deployment. Anyone with `repo` or `repo_deployment` scopes can delete a deployment. To
     * set a deployment as inactive, you must: * Create a new deployment that is active so that the
     * system has a record of the current state, then delete the previously active deployment. *
     * Mark the active deployment as inactive by adding any non-successful deployment status. For
     * more information, see "[Create a
     * deployment](https://docs.github.com/rest/deployments/deployments/#create-a-deployment)" and
     * "[Create a deployment
     * status](https://docs.github.com/rest/deployments/deployment-statuses#create-a-deployment-status).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  deploymentId  Required parameter: deployment_id parameter
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteDeployment(
            final String owner,
            final String repo,
            final int deploymentId) throws ApiException, IOException {
        prepareReposDeleteDeploymentRequest(owner, repo, deploymentId).execute();
    }

    /**
     * If the repository only has one deployment, you can delete the deployment regardless of its
     * status. If the repository has more than one deployment, you can only delete inactive
     * deployments. This ensures that repositories with multiple deployments will always have an
     * active deployment. Anyone with `repo` or `repo_deployment` scopes can delete a deployment. To
     * set a deployment as inactive, you must: * Create a new deployment that is active so that the
     * system has a record of the current state, then delete the previously active deployment. *
     * Mark the active deployment as inactive by adding any non-successful deployment status. For
     * more information, see "[Create a
     * deployment](https://docs.github.com/rest/deployments/deployments/#create-a-deployment)" and
     * "[Create a deployment
     * status](https://docs.github.com/rest/deployments/deployment-statuses#create-a-deployment-status).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  deploymentId  Required parameter: deployment_id parameter
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteDeploymentAsync(
            final String owner,
            final String repo,
            final int deploymentId) {
        try { 
            return prepareReposDeleteDeploymentRequest(owner, repo, deploymentId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteDeployment.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteDeploymentRequest(
            final String owner,
            final String repo,
            final int deploymentId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/deployments/{deployment_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("deployment_id").value(deploymentId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposDeploymentsDeploymentId404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposDeploymentsDeploymentId422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Users with pull access can view deployment statuses for a deployment:.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  deploymentId  Required parameter: deployment_id parameter
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of DeploymentStatus response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<DeploymentStatus> reposListDeploymentStatuses(
            final String owner,
            final String repo,
            final int deploymentId,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListDeploymentStatusesRequest(owner, repo, deploymentId, perPage,
                page).execute();
    }

    /**
     * Users with pull access can view deployment statuses for a deployment:.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  deploymentId  Required parameter: deployment_id parameter
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of DeploymentStatus response from the API call
     */
    public CompletableFuture<List<DeploymentStatus>> reposListDeploymentStatusesAsync(
            final String owner,
            final String repo,
            final int deploymentId,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListDeploymentStatusesRequest(owner, repo, deploymentId, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListDeploymentStatuses.
     */
    private ApiCall<List<DeploymentStatus>, ApiException> prepareReposListDeploymentStatusesRequest(
            final String owner,
            final String repo,
            final int deploymentId,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<DeploymentStatus>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/deployments/{deployment_id}/statuses")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("deployment_id").value(deploymentId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        DeploymentStatus[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposDeploymentsDeploymentIdStatuses404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Users with `push` access can create deployment statuses for a given deployment. GitHub Apps
     * require `read & write` access to "Deployments" and `read-only` access to "Repo contents" (for
     * private repos). OAuth Apps require the `repo_deployment` scope.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  deploymentId  Required parameter: deployment_id parameter
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposDeploymentsDeploymentIdStatusesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposDeploymentsDeploymentIdStatusesResponse reposCreateDeploymentStatus(
            final String owner,
            final String repo,
            final int deploymentId,
            final ReposDeploymentsDeploymentIdStatusesRequest body) throws ApiException, IOException {
        return prepareReposCreateDeploymentStatusRequest(owner, repo, deploymentId, body).execute();
    }

    /**
     * Users with `push` access can create deployment statuses for a given deployment. GitHub Apps
     * require `read & write` access to "Deployments" and `read-only` access to "Repo contents" (for
     * private repos). OAuth Apps require the `repo_deployment` scope.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  deploymentId  Required parameter: deployment_id parameter
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposDeploymentsDeploymentIdStatusesResponse response from the API call
     */
    public CompletableFuture<ReposDeploymentsDeploymentIdStatusesResponse> reposCreateDeploymentStatusAsync(
            final String owner,
            final String repo,
            final int deploymentId,
            final ReposDeploymentsDeploymentIdStatusesRequest body) {
        try { 
            return prepareReposCreateDeploymentStatusRequest(owner, repo, deploymentId,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateDeploymentStatus.
     */
    private ApiCall<ReposDeploymentsDeploymentIdStatusesResponse, ApiException> prepareReposCreateDeploymentStatusRequest(
            final String owner,
            final String repo,
            final int deploymentId,
            final ReposDeploymentsDeploymentIdStatusesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposDeploymentsDeploymentIdStatusesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/deployments/{deployment_id}/statuses")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("deployment_id").value(deploymentId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposDeploymentsDeploymentIdStatusesResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposDeploymentsDeploymentIdStatuses422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Users with pull access can view a deployment status for a deployment:.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  deploymentId  Required parameter: deployment_id parameter
     * @param  statusId  Required parameter: Example:
     * @return    Returns the ReposDeploymentsDeploymentIdStatusesStatusIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposDeploymentsDeploymentIdStatusesStatusIdResponse reposGetDeploymentStatus(
            final String owner,
            final String repo,
            final int deploymentId,
            final int statusId) throws ApiException, IOException {
        return prepareReposGetDeploymentStatusRequest(owner, repo, deploymentId,
                statusId).execute();
    }

    /**
     * Users with pull access can view a deployment status for a deployment:.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  deploymentId  Required parameter: deployment_id parameter
     * @param  statusId  Required parameter: Example:
     * @return    Returns the ReposDeploymentsDeploymentIdStatusesStatusIdResponse response from the API call
     */
    public CompletableFuture<ReposDeploymentsDeploymentIdStatusesStatusIdResponse> reposGetDeploymentStatusAsync(
            final String owner,
            final String repo,
            final int deploymentId,
            final int statusId) {
        try { 
            return prepareReposGetDeploymentStatusRequest(owner, repo, deploymentId,
            statusId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetDeploymentStatus.
     */
    private ApiCall<ReposDeploymentsDeploymentIdStatusesStatusIdResponse, ApiException> prepareReposGetDeploymentStatusRequest(
            final String owner,
            final String repo,
            final int deploymentId,
            final int statusId) throws IOException {
        return new ApiCall.Builder<ReposDeploymentsDeploymentIdStatusesStatusIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("deployment_id").value(deploymentId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("status_id").value(statusId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposDeploymentsDeploymentIdStatusesStatusIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposDeploymentsDeploymentIdStatusesStatusId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * You can use this endpoint to trigger a webhook event called `repository_dispatch` when you
     * want activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub
     * App webhook. You must configure your GitHub Actions workflow or GitHub App to run when the
     * `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see
     * "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."
     * The `client_payload` parameter is available for any extra information that your workflow
     * might need. This parameter is a JSON payload that will be passed on when the webhook event is
     * dispatched. For example, the `client_payload` can include a message that a user would like to
     * send using a GitHub Actions workflow. Or the `client_payload` can be used as a test to debug
     * your workflow. This endpoint requires write access to the repository by providing either: -
     * Personal access tokens with `repo` scope. For more information, see "[Creating a personal
     * access token for the command
     * line](https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line)"
     * in the GitHub Help documentation. - GitHub Apps with both `metadata:read` and
     * `contents:read&write` permissions. This input example shows how you can use the
     * `client_payload` as a test to debug your workflow.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposCreateDispatchEvent(
            final String owner,
            final String repo,
            final ReposDispatchesRequest body) throws ApiException, IOException {
        prepareReposCreateDispatchEventRequest(owner, repo, body).execute();
    }

    /**
     * You can use this endpoint to trigger a webhook event called `repository_dispatch` when you
     * want activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub
     * App webhook. You must configure your GitHub Actions workflow or GitHub App to run when the
     * `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see
     * "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."
     * The `client_payload` parameter is available for any extra information that your workflow
     * might need. This parameter is a JSON payload that will be passed on when the webhook event is
     * dispatched. For example, the `client_payload` can include a message that a user would like to
     * send using a GitHub Actions workflow. Or the `client_payload` can be used as a test to debug
     * your workflow. This endpoint requires write access to the repository by providing either: -
     * Personal access tokens with `repo` scope. For more information, see "[Creating a personal
     * access token for the command
     * line](https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line)"
     * in the GitHub Help documentation. - GitHub Apps with both `metadata:read` and
     * `contents:read&write` permissions. This input example shows how you can use the
     * `client_payload` as a test to debug your workflow.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposCreateDispatchEventAsync(
            final String owner,
            final String repo,
            final ReposDispatchesRequest body) {
        try { 
            return prepareReposCreateDispatchEventRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateDispatchEvent.
     */
    private ApiCall<Void, ApiException> prepareReposCreateDispatchEventRequest(
            final String owner,
            final String repo,
            final ReposDispatchesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/dispatches")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposDispatches422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the environments for a repository. Anyone with read access to the repository can use
     * this endpoint. If the repository is private, you must use an access token with the `repo`
     * scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposEnvironmentsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposEnvironmentsResponse reposGetAllEnvironments(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposGetAllEnvironmentsRequest(owner, repo, perPage, page).execute();
    }

    /**
     * Lists the environments for a repository. Anyone with read access to the repository can use
     * this endpoint. If the repository is private, you must use an access token with the `repo`
     * scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposEnvironmentsResponse response from the API call
     */
    public CompletableFuture<ReposEnvironmentsResponse> reposGetAllEnvironmentsAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposGetAllEnvironmentsRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetAllEnvironments.
     */
    private ApiCall<ReposEnvironmentsResponse, ApiException> prepareReposGetAllEnvironmentsRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposEnvironmentsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/environments")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposEnvironmentsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * **Note:** To get information about name patterns that branches must match in order to deploy
     * to this environment, see "[Get a deployment branch
     * policy](/rest/deployments/branch-policies#get-a-deployment-branch-policy)." Anyone with read
     * access to the repository can use this endpoint. If the repository is private, you must use an
     * access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to
     * use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @return    Returns the ReposEnvironmentsEnvironmentNameResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposEnvironmentsEnvironmentNameResponse reposGetEnvironment(
            final String owner,
            final String repo,
            final String environmentName) throws ApiException, IOException {
        return prepareReposGetEnvironmentRequest(owner, repo, environmentName).execute();
    }

    /**
     * **Note:** To get information about name patterns that branches must match in order to deploy
     * to this environment, see "[Get a deployment branch
     * policy](/rest/deployments/branch-policies#get-a-deployment-branch-policy)." Anyone with read
     * access to the repository can use this endpoint. If the repository is private, you must use an
     * access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to
     * use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @return    Returns the ReposEnvironmentsEnvironmentNameResponse response from the API call
     */
    public CompletableFuture<ReposEnvironmentsEnvironmentNameResponse> reposGetEnvironmentAsync(
            final String owner,
            final String repo,
            final String environmentName) {
        try { 
            return prepareReposGetEnvironmentRequest(owner, repo, environmentName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetEnvironment.
     */
    private ApiCall<ReposEnvironmentsEnvironmentNameResponse, ApiException> prepareReposGetEnvironmentRequest(
            final String owner,
            final String repo,
            final String environmentName) throws IOException {
        return new ApiCall.Builder<ReposEnvironmentsEnvironmentNameResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/environments/{environment_name}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposEnvironmentsEnvironmentNameResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Create or update an environment with protection rules, such as required reviewers. For more
     * information about environment protection rules, see
     * "[Environments](/actions/reference/environments#environment-protection-rules)." **Note:** To
     * create or update name patterns that branches must match in order to deploy to this
     * environment, see "[Deployment branch policies](/rest/deployments/branch-policies)." **Note:**
     * To create or update secrets for an environment, see
     * "[Secrets](/rest/reference/actions#secrets)." You must authenticate using an access token
     * with the `repo` scope to use this endpoint. GitHub Apps must have the `administration:write`
     * permission for the repository to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposEnvironmentsEnvironmentNameResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposEnvironmentsEnvironmentNameResponse reposCreateOrUpdateEnvironment(
            final String owner,
            final String repo,
            final String environmentName,
            final Object body) throws ApiException, IOException {
        return prepareReposCreateOrUpdateEnvironmentRequest(owner, repo, environmentName,
                body).execute();
    }

    /**
     * Create or update an environment with protection rules, such as required reviewers. For more
     * information about environment protection rules, see
     * "[Environments](/actions/reference/environments#environment-protection-rules)." **Note:** To
     * create or update name patterns that branches must match in order to deploy to this
     * environment, see "[Deployment branch policies](/rest/deployments/branch-policies)." **Note:**
     * To create or update secrets for an environment, see
     * "[Secrets](/rest/reference/actions#secrets)." You must authenticate using an access token
     * with the `repo` scope to use this endpoint. GitHub Apps must have the `administration:write`
     * permission for the repository to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposEnvironmentsEnvironmentNameResponse response from the API call
     */
    public CompletableFuture<ReposEnvironmentsEnvironmentNameResponse> reposCreateOrUpdateEnvironmentAsync(
            final String owner,
            final String repo,
            final String environmentName,
            final Object body) {
        try { 
            return prepareReposCreateOrUpdateEnvironmentRequest(owner, repo, environmentName,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateOrUpdateEnvironment.
     */
    private ApiCall<ReposEnvironmentsEnvironmentNameResponse, ApiException> prepareReposCreateOrUpdateEnvironmentRequest(
            final String owner,
            final String repo,
            final String environmentName,
            final Object body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposEnvironmentsEnvironmentNameResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/environments/{environment_name}")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposEnvironmentsEnvironmentNameResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation error when the environment name is invalid or when `protected_branches` and `custom_branch_policies` in `deployment_branch_policy` are set to the same value",
                                (reason, context) -> new ReposEnvironmentsEnvironmentName422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * You must authenticate using an access token with the repo scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteAnEnvironment(
            final String owner,
            final String repo,
            final String environmentName) throws ApiException, IOException {
        prepareReposDeleteAnEnvironmentRequest(owner, repo, environmentName).execute();
    }

    /**
     * You must authenticate using an access token with the repo scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteAnEnvironmentAsync(
            final String owner,
            final String repo,
            final String environmentName) {
        try { 
            return prepareReposDeleteAnEnvironmentRequest(owner, repo, environmentName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteAnEnvironment.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteAnEnvironmentRequest(
            final String owner,
            final String repo,
            final String environmentName) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/environments/{environment_name}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the deployment branch policies for an environment. Anyone with read access to the
     * repository can use this endpoint. If the repository is private, you must use an access token
     * with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesResponse reposListDeploymentBranchPolicies(
            final String owner,
            final String repo,
            final String environmentName,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListDeploymentBranchPoliciesRequest(owner, repo, environmentName,
                perPage, page).execute();
    }

    /**
     * Lists the deployment branch policies for an environment. Anyone with read access to the
     * repository can use this endpoint. If the repository is private, you must use an access token
     * with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesResponse response from the API call
     */
    public CompletableFuture<ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesResponse> reposListDeploymentBranchPoliciesAsync(
            final String owner,
            final String repo,
            final String environmentName,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListDeploymentBranchPoliciesRequest(owner, repo, environmentName, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListDeploymentBranchPolicies.
     */
    private ApiCall<ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesResponse, ApiException> prepareReposListDeploymentBranchPoliciesRequest(
            final String owner,
            final String repo,
            final String environmentName,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates a deployment branch policy for an environment. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `administration:write` permission for the repository to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesResponse2 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesResponse2 reposCreateDeploymentBranchPolicy(
            final String owner,
            final String repo,
            final String environmentName,
            final Deploymentbranchpolicynamepattern body) throws ApiException, IOException {
        return prepareReposCreateDeploymentBranchPolicyRequest(owner, repo, environmentName,
                body).execute();
    }

    /**
     * Creates a deployment branch policy for an environment. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `administration:write` permission for the repository to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesResponse2 response from the API call
     */
    public CompletableFuture<ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesResponse2> reposCreateDeploymentBranchPolicyAsync(
            final String owner,
            final String repo,
            final String environmentName,
            final Deploymentbranchpolicynamepattern body) {
        try { 
            return prepareReposCreateDeploymentBranchPolicyRequest(owner, repo, environmentName,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateDeploymentBranchPolicy.
     */
    private ApiCall<ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesResponse2, ApiException> prepareReposCreateDeploymentBranchPolicyRequest(
            final String owner,
            final String repo,
            final String environmentName,
            final Deploymentbranchpolicynamepattern body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesResponse2, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesResponse2.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Not Found or `deployment_branch_policy.custom_branch_policies` property for the environment is set to false",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a deployment branch policy for an environment. Anyone with read access to the repository
     * can use this endpoint. If the repository is private, you must use an access token with the
     * `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  branchPolicyId  Required parameter: The unique identifier of the branch policy.
     * @return    Returns the ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesBranchPolicyIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesBranchPolicyIdResponse reposGetDeploymentBranchPolicy(
            final String owner,
            final String repo,
            final String environmentName,
            final int branchPolicyId) throws ApiException, IOException {
        return prepareReposGetDeploymentBranchPolicyRequest(owner, repo, environmentName,
                branchPolicyId).execute();
    }

    /**
     * Gets a deployment branch policy for an environment. Anyone with read access to the repository
     * can use this endpoint. If the repository is private, you must use an access token with the
     * `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  branchPolicyId  Required parameter: The unique identifier of the branch policy.
     * @return    Returns the ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesBranchPolicyIdResponse response from the API call
     */
    public CompletableFuture<ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesBranchPolicyIdResponse> reposGetDeploymentBranchPolicyAsync(
            final String owner,
            final String repo,
            final String environmentName,
            final int branchPolicyId) {
        try { 
            return prepareReposGetDeploymentBranchPolicyRequest(owner, repo, environmentName,
            branchPolicyId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetDeploymentBranchPolicy.
     */
    private ApiCall<ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesBranchPolicyIdResponse, ApiException> prepareReposGetDeploymentBranchPolicyRequest(
            final String owner,
            final String repo,
            final String environmentName,
            final int branchPolicyId) throws IOException {
        return new ApiCall.Builder<ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesBranchPolicyIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch_policy_id").value(branchPolicyId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesBranchPolicyIdResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates a deployment branch policy for an environment. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `administration:write` permission for the repository to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  branchPolicyId  Required parameter: The unique identifier of the branch policy.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesBranchPolicyIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesBranchPolicyIdResponse reposUpdateDeploymentBranchPolicy(
            final String owner,
            final String repo,
            final String environmentName,
            final int branchPolicyId,
            final Deploymentbranchpolicynamepattern body) throws ApiException, IOException {
        return prepareReposUpdateDeploymentBranchPolicyRequest(owner, repo, environmentName,
                branchPolicyId, body).execute();
    }

    /**
     * Updates a deployment branch policy for an environment. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `administration:write` permission for the repository to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  branchPolicyId  Required parameter: The unique identifier of the branch policy.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesBranchPolicyIdResponse response from the API call
     */
    public CompletableFuture<ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesBranchPolicyIdResponse> reposUpdateDeploymentBranchPolicyAsync(
            final String owner,
            final String repo,
            final String environmentName,
            final int branchPolicyId,
            final Deploymentbranchpolicynamepattern body) {
        try { 
            return prepareReposUpdateDeploymentBranchPolicyRequest(owner, repo, environmentName,
            branchPolicyId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposUpdateDeploymentBranchPolicy.
     */
    private ApiCall<ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesBranchPolicyIdResponse, ApiException> prepareReposUpdateDeploymentBranchPolicyRequest(
            final String owner,
            final String repo,
            final String environmentName,
            final int branchPolicyId,
            final Deploymentbranchpolicynamepattern body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesBranchPolicyIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch_policy_id").value(branchPolicyId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposEnvironmentsEnvironmentNameDeploymentBranchPoliciesBranchPolicyIdResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a deployment branch policy for an environment. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `administration:write` permission for the repository to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  branchPolicyId  Required parameter: The unique identifier of the branch policy.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteDeploymentBranchPolicy(
            final String owner,
            final String repo,
            final String environmentName,
            final int branchPolicyId) throws ApiException, IOException {
        prepareReposDeleteDeploymentBranchPolicyRequest(owner, repo, environmentName,
                branchPolicyId).execute();
    }

    /**
     * Deletes a deployment branch policy for an environment. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `administration:write` permission for the repository to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  branchPolicyId  Required parameter: The unique identifier of the branch policy.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteDeploymentBranchPolicyAsync(
            final String owner,
            final String repo,
            final String environmentName,
            final int branchPolicyId) {
        try { 
            return prepareReposDeleteDeploymentBranchPolicyRequest(owner, repo, environmentName,
            branchPolicyId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteDeploymentBranchPolicy.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteDeploymentBranchPolicyRequest(
            final String owner,
            final String repo,
            final String environmentName,
            final int branchPolicyId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("branch_policy_id").value(branchPolicyId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List forks.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  sort  Optional parameter: The sort order. `stargazers` will sort by star count.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MinimalRepository response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<MinimalRepository> reposListForks(
            final String owner,
            final String repo,
            final Sort101Enum sort,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListForksRequest(owner, repo, sort, perPage, page).execute();
    }

    /**
     * List forks.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  sort  Optional parameter: The sort order. `stargazers` will sort by star count.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MinimalRepository response from the API call
     */
    public CompletableFuture<List<MinimalRepository>> reposListForksAsync(
            final String owner,
            final String repo,
            final Sort101Enum sort,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListForksRequest(owner, repo, sort, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListForks.
     */
    private ApiCall<List<MinimalRepository>, ApiException> prepareReposListForksRequest(
            final String owner,
            final String repo,
            final Sort101Enum sort,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<MinimalRepository>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/forks")
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        MinimalRepository[].class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new ReposForks400ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Create a fork for the authenticated user. **Note**: Forking a Repository happens
     * asynchronously. You may have to wait a short period of time before you can access the git
     * objects. If this takes longer than 5 minutes, be sure to contact [GitHub
     * Support](https://support.github.com/contact?tags=dotcom-rest-api).
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposForksResponse1 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposForksResponse1 reposCreateFork(
            final String owner,
            final String repo,
            final Object body) throws ApiException, IOException {
        return prepareReposCreateForkRequest(owner, repo, body).execute();
    }

    /**
     * Create a fork for the authenticated user. **Note**: Forking a Repository happens
     * asynchronously. You may have to wait a short period of time before you can access the git
     * objects. If this takes longer than 5 minutes, be sure to contact [GitHub
     * Support](https://support.github.com/contact?tags=dotcom-rest-api).
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposForksResponse1 response from the API call
     */
    public CompletableFuture<ReposForksResponse1> reposCreateForkAsync(
            final String owner,
            final String repo,
            final Object body) {
        try { 
            return prepareReposCreateForkRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateFork.
     */
    private ApiCall<ReposForksResponse1, ApiException> prepareReposCreateForkRequest(
            final String owner,
            final String repo,
            final Object body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposForksResponse1, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/forks")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposForksResponse1.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new ReposForks400ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposForks403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposForks404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposForks422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists webhooks for a repository. `last response` may return null if there have not been any
     * deliveries within 30 days.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Webhook response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Webhook> reposListWebhooks(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListWebhooksRequest(owner, repo, perPage, page).execute();
    }

    /**
     * Lists webhooks for a repository. `last response` may return null if there have not been any
     * deliveries within 30 days.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Webhook response from the API call
     */
    public CompletableFuture<List<Webhook>> reposListWebhooksAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListWebhooksRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListWebhooks.
     */
    private ApiCall<List<Webhook>, ApiException> prepareReposListWebhooksRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Webhook>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/hooks")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Webhook[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposHooks404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Repositories can have multiple webhooks installed. Each webhook should have a unique
     * `config`. Multiple webhooks can share the same `config` as long as those webhooks do not have
     * any `events` that overlap.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposHooksResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposHooksResponse reposCreateWebhook(
            final String owner,
            final String repo,
            final Object body) throws ApiException, IOException {
        return prepareReposCreateWebhookRequest(owner, repo, body).execute();
    }

    /**
     * Repositories can have multiple webhooks installed. Each webhook should have a unique
     * `config`. Multiple webhooks can share the same `config` as long as those webhooks do not have
     * any `events` that overlap.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposHooksResponse response from the API call
     */
    public CompletableFuture<ReposHooksResponse> reposCreateWebhookAsync(
            final String owner,
            final String repo,
            final Object body) {
        try { 
            return prepareReposCreateWebhookRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateWebhook.
     */
    private ApiCall<ReposHooksResponse, ApiException> prepareReposCreateWebhookRequest(
            final String owner,
            final String repo,
            final Object body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposHooksResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/hooks")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposHooksResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposHooks403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposHooks404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposHooks422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns a webhook configured in a repository. To get only the webhook `config` properties,
     * see "[Get a webhook configuration for a
     * repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @return    Returns the ReposHooksHookIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposHooksHookIdResponse reposGetWebhook(
            final String owner,
            final String repo,
            final int hookId) throws ApiException, IOException {
        return prepareReposGetWebhookRequest(owner, repo, hookId).execute();
    }

    /**
     * Returns a webhook configured in a repository. To get only the webhook `config` properties,
     * see "[Get a webhook configuration for a
     * repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @return    Returns the ReposHooksHookIdResponse response from the API call
     */
    public CompletableFuture<ReposHooksHookIdResponse> reposGetWebhookAsync(
            final String owner,
            final String repo,
            final int hookId) {
        try { 
            return prepareReposGetWebhookRequest(owner, repo, hookId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetWebhook.
     */
    private ApiCall<ReposHooksHookIdResponse, ApiException> prepareReposGetWebhookRequest(
            final String owner,
            final String repo,
            final int hookId) throws IOException {
        return new ApiCall.Builder<ReposHooksHookIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/hooks/{hook_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("hook_id").value(hookId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposHooksHookIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposHooksHookId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates a webhook configured in a repository. If you previously had a `secret` set, you must
     * provide the same `secret` or set a new `secret` or the secret will be removed. If you are
     * only updating individual webhook `config` properties, use "[Update a webhook configuration
     * for a repository](/rest/reference/repos#update-a-webhook-configuration-for-a-repository).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposHooksHookIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposHooksHookIdResponse reposUpdateWebhook(
            final String owner,
            final String repo,
            final int hookId,
            final ReposHooksHookIdRequest body) throws ApiException, IOException {
        return prepareReposUpdateWebhookRequest(owner, repo, hookId, body).execute();
    }

    /**
     * Updates a webhook configured in a repository. If you previously had a `secret` set, you must
     * provide the same `secret` or set a new `secret` or the secret will be removed. If you are
     * only updating individual webhook `config` properties, use "[Update a webhook configuration
     * for a repository](/rest/reference/repos#update-a-webhook-configuration-for-a-repository).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposHooksHookIdResponse response from the API call
     */
    public CompletableFuture<ReposHooksHookIdResponse> reposUpdateWebhookAsync(
            final String owner,
            final String repo,
            final int hookId,
            final ReposHooksHookIdRequest body) {
        try { 
            return prepareReposUpdateWebhookRequest(owner, repo, hookId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposUpdateWebhook.
     */
    private ApiCall<ReposHooksHookIdResponse, ApiException> prepareReposUpdateWebhookRequest(
            final String owner,
            final String repo,
            final int hookId,
            final ReposHooksHookIdRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposHooksHookIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/hooks/{hook_id}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("hook_id").value(hookId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposHooksHookIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposHooksHookId404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposHooksHookId422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Delete a repository webhook.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteWebhook(
            final String owner,
            final String repo,
            final int hookId) throws ApiException, IOException {
        prepareReposDeleteWebhookRequest(owner, repo, hookId).execute();
    }

    /**
     * Delete a repository webhook.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteWebhookAsync(
            final String owner,
            final String repo,
            final int hookId) {
        try { 
            return prepareReposDeleteWebhookRequest(owner, repo, hookId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteWebhook.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteWebhookRequest(
            final String owner,
            final String repo,
            final int hookId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/hooks/{hook_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("hook_id").value(hookId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposHooksHookId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns the webhook configuration for a repository. To get more information about the
     * webhook, including the `active` state and `events`, use "[Get a repository
     * webhook](/rest/reference/orgs#get-a-repository-webhook)." Access tokens must have the
     * `read:repo_hook` or `repo` scope, and GitHub Apps must have the `repository_hooks:read`
     * permission.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @return    Returns the AppHookConfigRequest response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AppHookConfigRequest reposGetWebhookConfigForRepo(
            final String owner,
            final String repo,
            final int hookId) throws ApiException, IOException {
        return prepareReposGetWebhookConfigForRepoRequest(owner, repo, hookId).execute();
    }

    /**
     * Returns the webhook configuration for a repository. To get more information about the
     * webhook, including the `active` state and `events`, use "[Get a repository
     * webhook](/rest/reference/orgs#get-a-repository-webhook)." Access tokens must have the
     * `read:repo_hook` or `repo` scope, and GitHub Apps must have the `repository_hooks:read`
     * permission.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @return    Returns the AppHookConfigRequest response from the API call
     */
    public CompletableFuture<AppHookConfigRequest> reposGetWebhookConfigForRepoAsync(
            final String owner,
            final String repo,
            final int hookId) {
        try { 
            return prepareReposGetWebhookConfigForRepoRequest(owner, repo, hookId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetWebhookConfigForRepo.
     */
    private ApiCall<AppHookConfigRequest, ApiException> prepareReposGetWebhookConfigForRepoRequest(
            final String owner,
            final String repo,
            final int hookId) throws IOException {
        return new ApiCall.Builder<AppHookConfigRequest, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/hooks/{hook_id}/config")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("hook_id").value(hookId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, AppHookConfigRequest.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates the webhook configuration for a repository. To update more information about the
     * webhook, including the `active` state and `events`, use "[Update a repository
     * webhook](/rest/reference/orgs#update-a-repository-webhook)." Access tokens must have the
     * `write:repo_hook` or `repo` scope, and GitHub Apps must have the `repository_hooks:write`
     * permission.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @param  body  Optional parameter: Example:
     * @return    Returns the AppHookConfigRequest response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public AppHookConfigRequest reposUpdateWebhookConfigForRepo(
            final String owner,
            final String repo,
            final int hookId,
            final AppHookConfigRequest body) throws ApiException, IOException {
        return prepareReposUpdateWebhookConfigForRepoRequest(owner, repo, hookId, body).execute();
    }

    /**
     * Updates the webhook configuration for a repository. To update more information about the
     * webhook, including the `active` state and `events`, use "[Update a repository
     * webhook](/rest/reference/orgs#update-a-repository-webhook)." Access tokens must have the
     * `write:repo_hook` or `repo` scope, and GitHub Apps must have the `repository_hooks:write`
     * permission.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @param  body  Optional parameter: Example:
     * @return    Returns the AppHookConfigRequest response from the API call
     */
    public CompletableFuture<AppHookConfigRequest> reposUpdateWebhookConfigForRepoAsync(
            final String owner,
            final String repo,
            final int hookId,
            final AppHookConfigRequest body) {
        try { 
            return prepareReposUpdateWebhookConfigForRepoRequest(owner, repo, hookId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposUpdateWebhookConfigForRepo.
     */
    private ApiCall<AppHookConfigRequest, ApiException> prepareReposUpdateWebhookConfigForRepoRequest(
            final String owner,
            final String repo,
            final int hookId,
            final AppHookConfigRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<AppHookConfigRequest, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/hooks/{hook_id}/config")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("hook_id").value(hookId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, AppHookConfigRequest.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns a list of webhook deliveries for a webhook configured in a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  cursor  Optional parameter: Used for pagination: the starting delivery from which the
     *         page of deliveries is fetched. Refer to the `link` header for the next and previous
     *         page cursors.
     * @param  redelivery  Optional parameter: Example:
     * @return    Returns the List of Simplewebhookdelivery response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Simplewebhookdelivery> reposListWebhookDeliveries(
            final String owner,
            final String repo,
            final int hookId,
            final Integer perPage,
            final String cursor,
            final Boolean redelivery) throws ApiException, IOException {
        return prepareReposListWebhookDeliveriesRequest(owner, repo, hookId, perPage, cursor,
                redelivery).execute();
    }

    /**
     * Returns a list of webhook deliveries for a webhook configured in a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  cursor  Optional parameter: Used for pagination: the starting delivery from which the
     *         page of deliveries is fetched. Refer to the `link` header for the next and previous
     *         page cursors.
     * @param  redelivery  Optional parameter: Example:
     * @return    Returns the List of Simplewebhookdelivery response from the API call
     */
    public CompletableFuture<List<Simplewebhookdelivery>> reposListWebhookDeliveriesAsync(
            final String owner,
            final String repo,
            final int hookId,
            final Integer perPage,
            final String cursor,
            final Boolean redelivery) {
        try { 
            return prepareReposListWebhookDeliveriesRequest(owner, repo, hookId, perPage, cursor,
            redelivery).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListWebhookDeliveries.
     */
    private ApiCall<List<Simplewebhookdelivery>, ApiException> prepareReposListWebhookDeliveriesRequest(
            final String owner,
            final String repo,
            final int hookId,
            final Integer perPage,
            final String cursor,
            final Boolean redelivery) throws IOException {
        return new ApiCall.Builder<List<Simplewebhookdelivery>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/hooks/{hook_id}/deliveries")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("cursor")
                                .value(cursor).isRequired(false))
                        .queryParam(param -> param.key("redelivery")
                                .value(redelivery).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("hook_id").value(hookId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Simplewebhookdelivery[].class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new ReposHooksHookIdDeliveries400ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposHooksHookIdDeliveries422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns a delivery for a webhook configured in a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @param  deliveryId  Required parameter: Example:
     * @return    Returns the ReposHooksHookIdDeliveriesDeliveryIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposHooksHookIdDeliveriesDeliveryIdResponse reposGetWebhookDelivery(
            final String owner,
            final String repo,
            final int hookId,
            final int deliveryId) throws ApiException, IOException {
        return prepareReposGetWebhookDeliveryRequest(owner, repo, hookId, deliveryId).execute();
    }

    /**
     * Returns a delivery for a webhook configured in a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @param  deliveryId  Required parameter: Example:
     * @return    Returns the ReposHooksHookIdDeliveriesDeliveryIdResponse response from the API call
     */
    public CompletableFuture<ReposHooksHookIdDeliveriesDeliveryIdResponse> reposGetWebhookDeliveryAsync(
            final String owner,
            final String repo,
            final int hookId,
            final int deliveryId) {
        try { 
            return prepareReposGetWebhookDeliveryRequest(owner, repo, hookId, deliveryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetWebhookDelivery.
     */
    private ApiCall<ReposHooksHookIdDeliveriesDeliveryIdResponse, ApiException> prepareReposGetWebhookDeliveryRequest(
            final String owner,
            final String repo,
            final int hookId,
            final int deliveryId) throws IOException {
        return new ApiCall.Builder<ReposHooksHookIdDeliveriesDeliveryIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("hook_id").value(hookId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("delivery_id").value(deliveryId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposHooksHookIdDeliveriesDeliveryIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new ReposHooksHookIdDeliveriesDeliveryId400ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposHooksHookIdDeliveriesDeliveryId422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Redeliver a webhook delivery for a webhook configured in a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @param  deliveryId  Required parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object reposRedeliverWebhookDelivery(
            final String owner,
            final String repo,
            final int hookId,
            final int deliveryId) throws ApiException, IOException {
        return prepareReposRedeliverWebhookDeliveryRequest(owner, repo, hookId,
                deliveryId).execute();
    }

    /**
     * Redeliver a webhook delivery for a webhook configured in a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @param  deliveryId  Required parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> reposRedeliverWebhookDeliveryAsync(
            final String owner,
            final String repo,
            final int hookId,
            final int deliveryId) {
        try { 
            return prepareReposRedeliverWebhookDeliveryRequest(owner, repo, hookId,
            deliveryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposRedeliverWebhookDelivery.
     */
    private ApiCall<Object, ApiException> prepareReposRedeliverWebhookDeliveryRequest(
            final String owner,
            final String repo,
            final int hookId,
            final int deliveryId) throws IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("hook_id").value(hookId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("delivery_id").value(deliveryId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new ReposHooksHookIdDeliveriesDeliveryIdAttempts400ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposHooksHookIdDeliveriesDeliveryIdAttempts422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to
     * the hook.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposPingWebhook(
            final String owner,
            final String repo,
            final int hookId) throws ApiException, IOException {
        prepareReposPingWebhookRequest(owner, repo, hookId).execute();
    }

    /**
     * This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to
     * the hook.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposPingWebhookAsync(
            final String owner,
            final String repo,
            final int hookId) {
        try { 
            return prepareReposPingWebhookRequest(owner, repo, hookId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposPingWebhook.
     */
    private ApiCall<Void, ApiException> prepareReposPingWebhookRequest(
            final String owner,
            final String repo,
            final int hookId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/hooks/{hook_id}/pings")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("hook_id").value(hookId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposHooksHookIdPings404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This will trigger the hook with the latest push to the current repository if the hook is
     * subscribed to `push` events. If the hook is not subscribed to `push` events, the server will
     * respond with 204 but no test POST will be generated. **Note**: Previously
     * `/repos/:owner/:repo/hooks/:hook_id/test`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposTestPushWebhook(
            final String owner,
            final String repo,
            final int hookId) throws ApiException, IOException {
        prepareReposTestPushWebhookRequest(owner, repo, hookId).execute();
    }

    /**
     * This will trigger the hook with the latest push to the current repository if the hook is
     * subscribed to `push` events. If the hook is not subscribed to `push` events, the server will
     * respond with 204 but no test POST will be generated. **Note**: Previously
     * `/repos/:owner/:repo/hooks/:hook_id/test`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  hookId  Required parameter: The unique identifier of the hook.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposTestPushWebhookAsync(
            final String owner,
            final String repo,
            final int hookId) {
        try { 
            return prepareReposTestPushWebhookRequest(owner, repo, hookId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposTestPushWebhook.
     */
    private ApiCall<Void, ApiException> prepareReposTestPushWebhookRequest(
            final String owner,
            final String repo,
            final int hookId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/hooks/{hook_id}/tests")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("hook_id").value(hookId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposHooksHookIdTests404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * When authenticating as a user with admin rights to a repository, this endpoint will list all
     * currently open repository invitations.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of RepositoryInvitation response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<RepositoryInvitation> reposListInvitations(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListInvitationsRequest(owner, repo, perPage, page).execute();
    }

    /**
     * When authenticating as a user with admin rights to a repository, this endpoint will list all
     * currently open repository invitations.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of RepositoryInvitation response from the API call
     */
    public CompletableFuture<List<RepositoryInvitation>> reposListInvitationsAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListInvitationsRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListInvitations.
     */
    private ApiCall<List<RepositoryInvitation>, ApiException> prepareReposListInvitationsRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<RepositoryInvitation>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/invitations")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        RepositoryInvitation[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Update a repository invitation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  invitationId  Required parameter: The unique identifier of the invitation.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposInvitationsInvitationIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposInvitationsInvitationIdResponse reposUpdateInvitation(
            final String owner,
            final String repo,
            final int invitationId,
            final ReposInvitationsInvitationIdRequest body) throws ApiException, IOException {
        return prepareReposUpdateInvitationRequest(owner, repo, invitationId, body).execute();
    }

    /**
     * Update a repository invitation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  invitationId  Required parameter: The unique identifier of the invitation.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposInvitationsInvitationIdResponse response from the API call
     */
    public CompletableFuture<ReposInvitationsInvitationIdResponse> reposUpdateInvitationAsync(
            final String owner,
            final String repo,
            final int invitationId,
            final ReposInvitationsInvitationIdRequest body) {
        try { 
            return prepareReposUpdateInvitationRequest(owner, repo, invitationId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposUpdateInvitation.
     */
    private ApiCall<ReposInvitationsInvitationIdResponse, ApiException> prepareReposUpdateInvitationRequest(
            final String owner,
            final String repo,
            final int invitationId,
            final ReposInvitationsInvitationIdRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposInvitationsInvitationIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/invitations/{invitation_id}")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("invitation_id").value(invitationId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposInvitationsInvitationIdResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Delete a repository invitation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  invitationId  Required parameter: The unique identifier of the invitation.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteInvitation(
            final String owner,
            final String repo,
            final int invitationId) throws ApiException, IOException {
        prepareReposDeleteInvitationRequest(owner, repo, invitationId).execute();
    }

    /**
     * Delete a repository invitation.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  invitationId  Required parameter: The unique identifier of the invitation.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteInvitationAsync(
            final String owner,
            final String repo,
            final int invitationId) {
        try { 
            return prepareReposDeleteInvitationRequest(owner, repo, invitationId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteInvitation.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteInvitationRequest(
            final String owner,
            final String repo,
            final int invitationId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/invitations/{invitation_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("invitation_id").value(invitationId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List deploy keys.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of DeployKey response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<DeployKey> reposListDeployKeys(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListDeployKeysRequest(owner, repo, perPage, page).execute();
    }

    /**
     * List deploy keys.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of DeployKey response from the API call
     */
    public CompletableFuture<List<DeployKey>> reposListDeployKeysAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListDeployKeysRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListDeployKeys.
     */
    private ApiCall<List<DeployKey>, ApiException> prepareReposListDeployKeysRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<DeployKey>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/keys")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        DeployKey[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * You can create a read-only deploy key.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposKeysResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposKeysResponse reposCreateDeployKey(
            final String owner,
            final String repo,
            final ReposKeysRequest body) throws ApiException, IOException {
        return prepareReposCreateDeployKeyRequest(owner, repo, body).execute();
    }

    /**
     * You can create a read-only deploy key.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposKeysResponse response from the API call
     */
    public CompletableFuture<ReposKeysResponse> reposCreateDeployKeyAsync(
            final String owner,
            final String repo,
            final ReposKeysRequest body) {
        try { 
            return prepareReposCreateDeployKeyRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateDeployKey.
     */
    private ApiCall<ReposKeysResponse, ApiException> prepareReposCreateDeployKeyRequest(
            final String owner,
            final String repo,
            final ReposKeysRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposKeysResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/keys")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposKeysResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposKeys422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get a deploy key.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  keyId  Required parameter: The unique identifier of the key.
     * @return    Returns the ReposKeysKeyIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposKeysKeyIdResponse reposGetDeployKey(
            final String owner,
            final String repo,
            final int keyId) throws ApiException, IOException {
        return prepareReposGetDeployKeyRequest(owner, repo, keyId).execute();
    }

    /**
     * Get a deploy key.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  keyId  Required parameter: The unique identifier of the key.
     * @return    Returns the ReposKeysKeyIdResponse response from the API call
     */
    public CompletableFuture<ReposKeysKeyIdResponse> reposGetDeployKeyAsync(
            final String owner,
            final String repo,
            final int keyId) {
        try { 
            return prepareReposGetDeployKeyRequest(owner, repo, keyId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetDeployKey.
     */
    private ApiCall<ReposKeysKeyIdResponse, ApiException> prepareReposGetDeployKeyRequest(
            final String owner,
            final String repo,
            final int keyId) throws IOException {
        return new ApiCall.Builder<ReposKeysKeyIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/keys/{key_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("key_id").value(keyId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposKeysKeyIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposKeysKeyId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deploy keys are immutable. If you need to update a key, remove the key and create a new one
     * instead.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  keyId  Required parameter: The unique identifier of the key.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteDeployKey(
            final String owner,
            final String repo,
            final int keyId) throws ApiException, IOException {
        prepareReposDeleteDeployKeyRequest(owner, repo, keyId).execute();
    }

    /**
     * Deploy keys are immutable. If you need to update a key, remove the key and create a new one
     * instead.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  keyId  Required parameter: The unique identifier of the key.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteDeployKeyAsync(
            final String owner,
            final String repo,
            final int keyId) {
        try { 
            return prepareReposDeleteDeployKeyRequest(owner, repo, keyId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteDeployKey.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteDeployKeyRequest(
            final String owner,
            final String repo,
            final int keyId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/keys/{key_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("key_id").value(keyId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists languages for the specified repository. The value shown for each language is the number
     * of bytes of code written in that language.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the Map of String, Integer response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Map<String, Integer> reposListLanguages(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposListLanguagesRequest(owner, repo).execute();
    }

    /**
     * Lists languages for the specified repository. The value shown for each language is the number
     * of bytes of code written in that language.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the Map of String, Integer response from the API call
     */
    public CompletableFuture<Map<String, Integer>> reposListLanguagesAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposListLanguagesRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListLanguages.
     */
    private ApiCall<Map<String, Integer>, ApiException> prepareReposListLanguagesRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Map<String, Integer>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/languages")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response,
                                        new TypeReference<Map<String, Integer>>(){}))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Enables Git LFS for a repository. Access tokens must have the `admin:enterprise` scope.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object reposEnableLfsForRepo(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposEnableLfsForRepoRequest(owner, repo).execute();
    }

    /**
     * Enables Git LFS for a repository. Access tokens must have the `admin:enterprise` scope.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> reposEnableLfsForRepoAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposEnableLfsForRepoRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposEnableLfsForRepo.
     */
    private ApiCall<Object, ApiException> prepareReposEnableLfsForRepoRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/lfs")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("We will return a 403 with one of the following messages:\n\n- Git LFS support not enabled because Git LFS is globally disabled.\n- Git LFS support not enabled because Git LFS is disabled for the root repository in the network.\n- Git LFS support not enabled because Git LFS is disabled for <owner>.",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Disables Git LFS for a repository. Access tokens must have the `admin:enterprise` scope.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDisableLfsForRepo(
            final String owner,
            final String repo) throws ApiException, IOException {
        prepareReposDisableLfsForRepoRequest(owner, repo).execute();
    }

    /**
     * Disables Git LFS for a repository. Access tokens must have the `admin:enterprise` scope.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDisableLfsForRepoAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposDisableLfsForRepoRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDisableLfsForRepo.
     */
    private ApiCall<Void, ApiException> prepareReposDisableLfsForRepoRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/lfs")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sync a branch of a forked repository to keep it up-to-date with the upstream repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposMergeUpstreamResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposMergeUpstreamResponse reposMergeUpstream(
            final String owner,
            final String repo,
            final ReposMergeUpstreamRequest body) throws ApiException, IOException {
        return prepareReposMergeUpstreamRequest(owner, repo, body).execute();
    }

    /**
     * Sync a branch of a forked repository to keep it up-to-date with the upstream repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposMergeUpstreamResponse response from the API call
     */
    public CompletableFuture<ReposMergeUpstreamResponse> reposMergeUpstreamAsync(
            final String owner,
            final String repo,
            final ReposMergeUpstreamRequest body) {
        try { 
            return prepareReposMergeUpstreamRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposMergeUpstream.
     */
    private ApiCall<ReposMergeUpstreamResponse, ApiException> prepareReposMergeUpstreamRequest(
            final String owner,
            final String repo,
            final ReposMergeUpstreamRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposMergeUpstreamResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/merge-upstream")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposMergeUpstreamResponse.class))
                        .nullify404(false)
                        .localErrorCase("409",
                                 ErrorCase.create("The branch could not be synced because of a merge conflict",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("The branch could not be synced for some other reason",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Merge a branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposMergesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposMergesResponse reposMerge(
            final String owner,
            final String repo,
            final ReposMergesRequest body) throws ApiException, IOException {
        return prepareReposMergeRequest(owner, repo, body).execute();
    }

    /**
     * Merge a branch.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposMergesResponse response from the API call
     */
    public CompletableFuture<ReposMergesResponse> reposMergeAsync(
            final String owner,
            final String repo,
            final ReposMergesRequest body) {
        try { 
            return prepareReposMergeRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposMerge.
     */
    private ApiCall<ReposMergesResponse, ApiException> prepareReposMergeRequest(
            final String owner,
            final String repo,
            final ReposMergesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposMergesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/merges")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposMergesResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposMerges403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Not Found when the base or head does not exist",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict when there is a merge conflict",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposMerges422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get a GitHub Pages site.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposPagesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposPagesResponse reposGetPages(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposGetPagesRequest(owner, repo).execute();
    }

    /**
     * Get a GitHub Pages site.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposPagesResponse response from the API call
     */
    public CompletableFuture<ReposPagesResponse> reposGetPagesAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposGetPagesRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetPages.
     */
    private ApiCall<ReposPagesResponse, ApiException> prepareReposGetPagesRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposPagesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/pages")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposPagesResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposPages404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Configures a GitHub Pages site. For more information, see "[About GitHub
     * Pages](/github/working-with-github-pages/about-github-pages)." To use this endpoint, you must
     * be a repository administrator, maintainer, or have the 'manage GitHub Pages settings'
     * permission. A token with the `repo` scope or Pages write permission is required. GitHub Apps
     * must have the `administrative:write` and `pages:write` permissions.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposPagesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposPagesResponse reposCreatePagesSite(
            final String owner,
            final String repo,
            final ReposPagesRequest4 body) throws ApiException, IOException {
        return prepareReposCreatePagesSiteRequest(owner, repo, body).execute();
    }

    /**
     * Configures a GitHub Pages site. For more information, see "[About GitHub
     * Pages](/github/working-with-github-pages/about-github-pages)." To use this endpoint, you must
     * be a repository administrator, maintainer, or have the 'manage GitHub Pages settings'
     * permission. A token with the `repo` scope or Pages write permission is required. GitHub Apps
     * must have the `administrative:write` and `pages:write` permissions.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposPagesResponse response from the API call
     */
    public CompletableFuture<ReposPagesResponse> reposCreatePagesSiteAsync(
            final String owner,
            final String repo,
            final ReposPagesRequest4 body) {
        try { 
            return prepareReposCreatePagesSiteRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreatePagesSite.
     */
    private ApiCall<ReposPagesResponse, ApiException> prepareReposCreatePagesSiteRequest(
            final String owner,
            final String repo,
            final ReposPagesRequest4 body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposPagesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/pages")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serializeTypeCombinator(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposPagesResponse.class))
                        .nullify404(false)
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict",
                                (reason, context) -> new ReposPages409ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposPages422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates information for a GitHub Pages site. For more information, see "[About GitHub
     * Pages](/github/working-with-github-pages/about-github-pages). To use this endpoint, you must
     * be a repository administrator, maintainer, or have the 'manage GitHub Pages settings'
     * permission. A token with the `repo` scope or Pages write permission is required. GitHub Apps
     * must have the `administrative:write` and `pages:write` permissions.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposUpdateInformationAboutPagesSite(
            final String owner,
            final String repo,
            final ReposPagesRequest5 body) throws ApiException, IOException {
        prepareReposUpdateInformationAboutPagesSiteRequest(owner, repo, body).execute();
    }

    /**
     * Updates information for a GitHub Pages site. For more information, see "[About GitHub
     * Pages](/github/working-with-github-pages/about-github-pages). To use this endpoint, you must
     * be a repository administrator, maintainer, or have the 'manage GitHub Pages settings'
     * permission. A token with the `repo` scope or Pages write permission is required. GitHub Apps
     * must have the `administrative:write` and `pages:write` permissions.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposUpdateInformationAboutPagesSiteAsync(
            final String owner,
            final String repo,
            final ReposPagesRequest5 body) {
        try { 
            return prepareReposUpdateInformationAboutPagesSiteRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposUpdateInformationAboutPagesSite.
     */
    private ApiCall<Void, ApiException> prepareReposUpdateInformationAboutPagesSiteRequest(
            final String owner,
            final String repo,
            final ReposPagesRequest5 body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/pages")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serializeTypeCombinator(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new ReposPages400ErrorException(reason, context)))
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict",
                                (reason, context) -> new ReposPages409ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposPages422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a a GitHub Pages site. For more information, see "[About GitHub
     * Pages](/github/working-with-github-pages/about-github-pages). To use this endpoint, you must
     * be a repository administrator, maintainer, or have the 'manage GitHub Pages settings'
     * permission. A token with the `repo` scope or Pages write permission is required. GitHub Apps
     * must have the `administrative:write` and `pages:write` permissions.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeletePagesSite(
            final String owner,
            final String repo) throws ApiException, IOException {
        prepareReposDeletePagesSiteRequest(owner, repo).execute();
    }

    /**
     * Deletes a a GitHub Pages site. For more information, see "[About GitHub
     * Pages](/github/working-with-github-pages/about-github-pages). To use this endpoint, you must
     * be a repository administrator, maintainer, or have the 'manage GitHub Pages settings'
     * permission. A token with the `repo` scope or Pages write permission is required. GitHub Apps
     * must have the `administrative:write` and `pages:write` permissions.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeletePagesSiteAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposDeletePagesSiteRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeletePagesSite.
     */
    private ApiCall<Void, ApiException> prepareReposDeletePagesSiteRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/pages")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposPages404ErrorException(reason, context)))
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict",
                                (reason, context) -> new ReposPages409ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposPages422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List GitHub Pages builds.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of PageBuild response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<PageBuild> reposListPagesBuilds(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListPagesBuildsRequest(owner, repo, perPage, page).execute();
    }

    /**
     * List GitHub Pages builds.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of PageBuild response from the API call
     */
    public CompletableFuture<List<PageBuild>> reposListPagesBuildsAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListPagesBuildsRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListPagesBuilds.
     */
    private ApiCall<List<PageBuild>, ApiException> prepareReposListPagesBuildsRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<PageBuild>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/pages/builds")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        PageBuild[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * You can request that your site be built from the latest revision on the default branch. This
     * has the same effect as pushing a commit to your default branch, but does not require an
     * additional commit. Manually triggering page builds can be helpful when diagnosing build
     * warnings and failures. Build requests are limited to one concurrent build per repository and
     * one concurrent build per requester. If you request a build while another is still in
     * progress, the second request will be queued until the first completes.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposPagesBuildsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposPagesBuildsResponse reposRequestPagesBuild(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposRequestPagesBuildRequest(owner, repo).execute();
    }

    /**
     * You can request that your site be built from the latest revision on the default branch. This
     * has the same effect as pushing a commit to your default branch, but does not require an
     * additional commit. Manually triggering page builds can be helpful when diagnosing build
     * warnings and failures. Build requests are limited to one concurrent build per repository and
     * one concurrent build per requester. If you request a build while another is still in
     * progress, the second request will be queued until the first completes.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposPagesBuildsResponse response from the API call
     */
    public CompletableFuture<ReposPagesBuildsResponse> reposRequestPagesBuildAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposRequestPagesBuildRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposRequestPagesBuild.
     */
    private ApiCall<ReposPagesBuildsResponse, ApiException> prepareReposRequestPagesBuildRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposPagesBuildsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/pages/builds")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposPagesBuildsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get latest Pages build.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposPagesBuildsLatestResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposPagesBuildsLatestResponse reposGetLatestPagesBuild(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposGetLatestPagesBuildRequest(owner, repo).execute();
    }

    /**
     * Get latest Pages build.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposPagesBuildsLatestResponse response from the API call
     */
    public CompletableFuture<ReposPagesBuildsLatestResponse> reposGetLatestPagesBuildAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposGetLatestPagesBuildRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetLatestPagesBuild.
     */
    private ApiCall<ReposPagesBuildsLatestResponse, ApiException> prepareReposGetLatestPagesBuildRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposPagesBuildsLatestResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/pages/builds/latest")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposPagesBuildsLatestResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get GitHub Pages build.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  buildId  Required parameter: Example:
     * @return    Returns the ReposPagesBuildsBuildIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposPagesBuildsBuildIdResponse reposGetPagesBuild(
            final String owner,
            final String repo,
            final int buildId) throws ApiException, IOException {
        return prepareReposGetPagesBuildRequest(owner, repo, buildId).execute();
    }

    /**
     * Get GitHub Pages build.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  buildId  Required parameter: Example:
     * @return    Returns the ReposPagesBuildsBuildIdResponse response from the API call
     */
    public CompletableFuture<ReposPagesBuildsBuildIdResponse> reposGetPagesBuildAsync(
            final String owner,
            final String repo,
            final int buildId) {
        try { 
            return prepareReposGetPagesBuildRequest(owner, repo, buildId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetPagesBuild.
     */
    private ApiCall<ReposPagesBuildsBuildIdResponse, ApiException> prepareReposGetPagesBuildRequest(
            final String owner,
            final String repo,
            final int buildId) throws IOException {
        return new ApiCall.Builder<ReposPagesBuildsBuildIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/pages/builds/{build_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("build_id").value(buildId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposPagesBuildsBuildIdResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Create a GitHub Pages deployment for a repository. Users must have write permissions. GitHub
     * Apps must have the `pages:write` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposPagesDeploymentResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposPagesDeploymentResponse reposCreatePagesDeployment(
            final String owner,
            final String repo,
            final ReposPagesDeploymentRequest1 body) throws ApiException, IOException {
        return prepareReposCreatePagesDeploymentRequest(owner, repo, body).execute();
    }

    /**
     * Create a GitHub Pages deployment for a repository. Users must have write permissions. GitHub
     * Apps must have the `pages:write` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposPagesDeploymentResponse response from the API call
     */
    public CompletableFuture<ReposPagesDeploymentResponse> reposCreatePagesDeploymentAsync(
            final String owner,
            final String repo,
            final ReposPagesDeploymentRequest1 body) {
        try { 
            return prepareReposCreatePagesDeploymentRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreatePagesDeployment.
     */
    private ApiCall<ReposPagesDeploymentResponse, ApiException> prepareReposCreatePagesDeploymentRequest(
            final String owner,
            final String repo,
            final ReposPagesDeploymentRequest1 body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposPagesDeploymentResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/pages/deployment")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposPagesDeploymentResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new ReposPagesDeployment400ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposPagesDeployment404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposPagesDeployment422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a health check of the DNS settings for the `CNAME` record configured for a repository's
     * GitHub Pages. The first request to this endpoint returns a `202 Accepted` status and starts
     * an asynchronous background task to get the results for the domain. After the background task
     * completes, subsequent requests to this endpoint return a `200 OK` status with the health
     * check results in the response. To use this endpoint, you must be a repository administrator,
     * maintainer, or have the 'manage GitHub Pages settings' permission. A token with the `repo`
     * scope or Pages write permission is required. GitHub Apps must have the `administrative:write`
     * and `pages:write` permissions.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposPagesHealthResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposPagesHealthResponse reposGetPagesHealthCheck(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposGetPagesHealthCheckRequest(owner, repo).execute();
    }

    /**
     * Gets a health check of the DNS settings for the `CNAME` record configured for a repository's
     * GitHub Pages. The first request to this endpoint returns a `202 Accepted` status and starts
     * an asynchronous background task to get the results for the domain. After the background task
     * completes, subsequent requests to this endpoint return a `200 OK` status with the health
     * check results in the response. To use this endpoint, you must be a repository administrator,
     * maintainer, or have the 'manage GitHub Pages settings' permission. A token with the `repo`
     * scope or Pages write permission is required. GitHub Apps must have the `administrative:write`
     * and `pages:write` permissions.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposPagesHealthResponse response from the API call
     */
    public CompletableFuture<ReposPagesHealthResponse> reposGetPagesHealthCheckAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposGetPagesHealthCheckRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetPagesHealthCheck.
     */
    private ApiCall<ReposPagesHealthResponse, ApiException> prepareReposGetPagesHealthCheckRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposPagesHealthResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/pages/health")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposPagesHealthResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Custom domains are not available for GitHub Pages",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposPagesHealth404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("There isn't a CNAME for this page",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the preferred README for a repository. READMEs support [custom media
     * types](https://docs.github.com/rest/reference/repos#custom-media-types) for retrieving the
     * raw content or rendered HTML.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Optional parameter: The name of the commit/branch/tag. Default: the repositorys
     *         default branch (usually `master`)
     * @return    Returns the ReposReadmeResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposReadmeResponse reposGetReadme(
            final String owner,
            final String repo,
            final String ref) throws ApiException, IOException {
        return prepareReposGetReadmeRequest(owner, repo, ref).execute();
    }

    /**
     * Gets the preferred README for a repository. READMEs support [custom media
     * types](https://docs.github.com/rest/reference/repos#custom-media-types) for retrieving the
     * raw content or rendered HTML.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Optional parameter: The name of the commit/branch/tag. Default: the repositorys
     *         default branch (usually `master`)
     * @return    Returns the ReposReadmeResponse response from the API call
     */
    public CompletableFuture<ReposReadmeResponse> reposGetReadmeAsync(
            final String owner,
            final String repo,
            final String ref) {
        try { 
            return prepareReposGetReadmeRequest(owner, repo, ref).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetReadme.
     */
    private ApiCall<ReposReadmeResponse, ApiException> prepareReposGetReadmeRequest(
            final String owner,
            final String repo,
            final String ref) throws IOException {
        return new ApiCall.Builder<ReposReadmeResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/readme")
                        .queryParam(param -> param.key("ref")
                                .value(ref).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposReadmeResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposReadme404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposReadme422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the README from a repository directory. READMEs support [custom media
     * types](https://docs.github.com/rest/reference/repos#custom-media-types) for retrieving the
     * raw content or rendered HTML.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  dir  Required parameter: The alternate path to look for a README file
     * @param  ref  Optional parameter: The name of the commit/branch/tag. Default: the repositorys
     *         default branch (usually `master`)
     * @return    Returns the ReposReadmeDirResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposReadmeDirResponse reposGetReadmeInDirectory(
            final String owner,
            final String repo,
            final String dir,
            final String ref) throws ApiException, IOException {
        return prepareReposGetReadmeInDirectoryRequest(owner, repo, dir, ref).execute();
    }

    /**
     * Gets the README from a repository directory. READMEs support [custom media
     * types](https://docs.github.com/rest/reference/repos#custom-media-types) for retrieving the
     * raw content or rendered HTML.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  dir  Required parameter: The alternate path to look for a README file
     * @param  ref  Optional parameter: The name of the commit/branch/tag. Default: the repositorys
     *         default branch (usually `master`)
     * @return    Returns the ReposReadmeDirResponse response from the API call
     */
    public CompletableFuture<ReposReadmeDirResponse> reposGetReadmeInDirectoryAsync(
            final String owner,
            final String repo,
            final String dir,
            final String ref) {
        try { 
            return prepareReposGetReadmeInDirectoryRequest(owner, repo, dir, ref).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetReadmeInDirectory.
     */
    private ApiCall<ReposReadmeDirResponse, ApiException> prepareReposGetReadmeInDirectoryRequest(
            final String owner,
            final String repo,
            final String dir,
            final String ref) throws IOException {
        return new ApiCall.Builder<ReposReadmeDirResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/readme/{dir}")
                        .queryParam(param -> param.key("ref")
                                .value(ref).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("dir").value(dir)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposReadmeDirResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposReadmeDir404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposReadmeDir422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This returns a list of releases, which does not include regular Git tags that have not been
     * associated with a release. To get a list of Git tags, use the [Repository Tags
     * API](https://docs.github.com/rest/reference/repos#list-repository-tags). Information about
     * published releases are available to everyone. Only users with push access will receive
     * listings for draft releases.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Release response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Release> reposListReleases(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListReleasesRequest(owner, repo, perPage, page).execute();
    }

    /**
     * This returns a list of releases, which does not include regular Git tags that have not been
     * associated with a release. To get a list of Git tags, use the [Repository Tags
     * API](https://docs.github.com/rest/reference/repos#list-repository-tags). Information about
     * published releases are available to everyone. Only users with push access will receive
     * listings for draft releases.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Release response from the API call
     */
    public CompletableFuture<List<Release>> reposListReleasesAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListReleasesRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListReleases.
     */
    private ApiCall<List<Release>, ApiException> prepareReposListReleasesRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Release>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/releases")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Release[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposReleases404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Users with push access to the repository can create a release. This endpoint triggers
     * [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
     * Creating content too quickly using this endpoint may result in secondary rate limiting. See
     * "[Secondary rate
     * limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
     * and "[Dealing with secondary rate
     * limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)"
     * for details.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposReleasesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposReleasesResponse reposCreateRelease(
            final String owner,
            final String repo,
            final ReposReleasesRequest body) throws ApiException, IOException {
        return prepareReposCreateReleaseRequest(owner, repo, body).execute();
    }

    /**
     * Users with push access to the repository can create a release. This endpoint triggers
     * [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
     * Creating content too quickly using this endpoint may result in secondary rate limiting. See
     * "[Secondary rate
     * limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
     * and "[Dealing with secondary rate
     * limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)"
     * for details.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposReleasesResponse response from the API call
     */
    public CompletableFuture<ReposReleasesResponse> reposCreateReleaseAsync(
            final String owner,
            final String repo,
            final ReposReleasesRequest body) {
        try { 
            return prepareReposCreateReleaseRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateRelease.
     */
    private ApiCall<ReposReleasesResponse, ApiException> prepareReposCreateReleaseRequest(
            final String owner,
            final String repo,
            final ReposReleasesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposReleasesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/releases")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposReleasesResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Not Found if the discussion category name is invalid",
                                (reason, context) -> new ReposReleases404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposReleases422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * To download the asset's binary content, set the `Accept` header of the request to
     * [`application/octet-stream`](https://docs.github.com/rest/overview/media-types). The API will
     * either redirect the client to the location, or stream it directly if possible. API clients
     * should handle both a `200` or `302` response.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  assetId  Required parameter: The unique identifier of the asset.
     * @return    Returns the ReposReleasesAssetsAssetIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposReleasesAssetsAssetIdResponse reposGetReleaseAsset(
            final String owner,
            final String repo,
            final int assetId) throws ApiException, IOException {
        return prepareReposGetReleaseAssetRequest(owner, repo, assetId).execute();
    }

    /**
     * To download the asset's binary content, set the `Accept` header of the request to
     * [`application/octet-stream`](https://docs.github.com/rest/overview/media-types). The API will
     * either redirect the client to the location, or stream it directly if possible. API clients
     * should handle both a `200` or `302` response.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  assetId  Required parameter: The unique identifier of the asset.
     * @return    Returns the ReposReleasesAssetsAssetIdResponse response from the API call
     */
    public CompletableFuture<ReposReleasesAssetsAssetIdResponse> reposGetReleaseAssetAsync(
            final String owner,
            final String repo,
            final int assetId) {
        try { 
            return prepareReposGetReleaseAssetRequest(owner, repo, assetId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetReleaseAsset.
     */
    private ApiCall<ReposReleasesAssetsAssetIdResponse, ApiException> prepareReposGetReleaseAssetRequest(
            final String owner,
            final String repo,
            final int assetId) throws IOException {
        return new ApiCall.Builder<ReposReleasesAssetsAssetIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/releases/assets/{asset_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("asset_id").value(assetId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposReleasesAssetsAssetIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposReleasesAssetsAssetId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Users with push access to the repository can edit a release asset.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  assetId  Required parameter: The unique identifier of the asset.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposReleasesAssetsAssetIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposReleasesAssetsAssetIdResponse reposUpdateReleaseAsset(
            final String owner,
            final String repo,
            final int assetId,
            final ReposReleasesAssetsAssetIdRequest body) throws ApiException, IOException {
        return prepareReposUpdateReleaseAssetRequest(owner, repo, assetId, body).execute();
    }

    /**
     * Users with push access to the repository can edit a release asset.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  assetId  Required parameter: The unique identifier of the asset.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposReleasesAssetsAssetIdResponse response from the API call
     */
    public CompletableFuture<ReposReleasesAssetsAssetIdResponse> reposUpdateReleaseAssetAsync(
            final String owner,
            final String repo,
            final int assetId,
            final ReposReleasesAssetsAssetIdRequest body) {
        try { 
            return prepareReposUpdateReleaseAssetRequest(owner, repo, assetId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposUpdateReleaseAsset.
     */
    private ApiCall<ReposReleasesAssetsAssetIdResponse, ApiException> prepareReposUpdateReleaseAssetRequest(
            final String owner,
            final String repo,
            final int assetId,
            final ReposReleasesAssetsAssetIdRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposReleasesAssetsAssetIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/releases/assets/{asset_id}")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("asset_id").value(assetId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposReleasesAssetsAssetIdResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Delete a release asset.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  assetId  Required parameter: The unique identifier of the asset.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteReleaseAsset(
            final String owner,
            final String repo,
            final int assetId) throws ApiException, IOException {
        prepareReposDeleteReleaseAssetRequest(owner, repo, assetId).execute();
    }

    /**
     * Delete a release asset.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  assetId  Required parameter: The unique identifier of the asset.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteReleaseAssetAsync(
            final String owner,
            final String repo,
            final int assetId) {
        try { 
            return prepareReposDeleteReleaseAssetRequest(owner, repo, assetId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteReleaseAsset.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteReleaseAssetRequest(
            final String owner,
            final String repo,
            final int assetId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/releases/assets/{asset_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("asset_id").value(assetId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Generate a name and body describing a
     * [release](https://docs.github.com/rest/reference/repos#releases). The body content will be
     * markdown formatted and contain information like the changes since last release and users who
     * contributed. The generated release notes are not saved anywhere. They are intended to be
     * generated and used when creating a new release.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposReleasesGenerateNotesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposReleasesGenerateNotesResponse reposGenerateReleaseNotes(
            final String owner,
            final String repo,
            final ReposReleasesGenerateNotesRequest body) throws ApiException, IOException {
        return prepareReposGenerateReleaseNotesRequest(owner, repo, body).execute();
    }

    /**
     * Generate a name and body describing a
     * [release](https://docs.github.com/rest/reference/repos#releases). The body content will be
     * markdown formatted and contain information like the changes since last release and users who
     * contributed. The generated release notes are not saved anywhere. They are intended to be
     * generated and used when creating a new release.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposReleasesGenerateNotesResponse response from the API call
     */
    public CompletableFuture<ReposReleasesGenerateNotesResponse> reposGenerateReleaseNotesAsync(
            final String owner,
            final String repo,
            final ReposReleasesGenerateNotesRequest body) {
        try { 
            return prepareReposGenerateReleaseNotesRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGenerateReleaseNotes.
     */
    private ApiCall<ReposReleasesGenerateNotesResponse, ApiException> prepareReposGenerateReleaseNotesRequest(
            final String owner,
            final String repo,
            final ReposReleasesGenerateNotesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposReleasesGenerateNotesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/releases/generate-notes")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposReleasesGenerateNotesResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposReleasesGenerateNotes404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * View the latest published full release for the repository. The latest release is the most
     * recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The
     * `created_at` attribute is the date of the commit used for the release, and not the date when
     * the release was drafted or published.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposReleasesLatestResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposReleasesLatestResponse reposGetLatestRelease(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposGetLatestReleaseRequest(owner, repo).execute();
    }

    /**
     * View the latest published full release for the repository. The latest release is the most
     * recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The
     * `created_at` attribute is the date of the commit used for the release, and not the date when
     * the release was drafted or published.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposReleasesLatestResponse response from the API call
     */
    public CompletableFuture<ReposReleasesLatestResponse> reposGetLatestReleaseAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposGetLatestReleaseRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetLatestRelease.
     */
    private ApiCall<ReposReleasesLatestResponse, ApiException> prepareReposGetLatestReleaseRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposReleasesLatestResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/releases/latest")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposReleasesLatestResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get a published release with the specified tag.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  tag  Required parameter: tag parameter
     * @return    Returns the ReposReleasesTagsTagResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposReleasesTagsTagResponse reposGetReleaseByTag(
            final String owner,
            final String repo,
            final String tag) throws ApiException, IOException {
        return prepareReposGetReleaseByTagRequest(owner, repo, tag).execute();
    }

    /**
     * Get a published release with the specified tag.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  tag  Required parameter: tag parameter
     * @return    Returns the ReposReleasesTagsTagResponse response from the API call
     */
    public CompletableFuture<ReposReleasesTagsTagResponse> reposGetReleaseByTagAsync(
            final String owner,
            final String repo,
            final String tag) {
        try { 
            return prepareReposGetReleaseByTagRequest(owner, repo, tag).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetReleaseByTag.
     */
    private ApiCall<ReposReleasesTagsTagResponse, ApiException> prepareReposGetReleaseByTagRequest(
            final String owner,
            final String repo,
            final String tag) throws IOException {
        return new ApiCall.Builder<ReposReleasesTagsTagResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/releases/tags/{tag}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("tag").value(tag)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposReleasesTagsTagResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposReleasesTagsTag404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading
     * release assets. This key is a [hypermedia
     * resource](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia).
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  releaseId  Required parameter: The unique identifier of the release.
     * @return    Returns the ReposReleasesReleaseIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposReleasesReleaseIdResponse reposGetRelease(
            final String owner,
            final String repo,
            final int releaseId) throws ApiException, IOException {
        return prepareReposGetReleaseRequest(owner, repo, releaseId).execute();
    }

    /**
     * **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading
     * release assets. This key is a [hypermedia
     * resource](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia).
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  releaseId  Required parameter: The unique identifier of the release.
     * @return    Returns the ReposReleasesReleaseIdResponse response from the API call
     */
    public CompletableFuture<ReposReleasesReleaseIdResponse> reposGetReleaseAsync(
            final String owner,
            final String repo,
            final int releaseId) {
        try { 
            return prepareReposGetReleaseRequest(owner, repo, releaseId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetRelease.
     */
    private ApiCall<ReposReleasesReleaseIdResponse, ApiException> prepareReposGetReleaseRequest(
            final String owner,
            final String repo,
            final int releaseId) throws IOException {
        return new ApiCall.Builder<ReposReleasesReleaseIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/releases/{release_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("release_id").value(releaseId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposReleasesReleaseIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposReleasesReleaseId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Users with push access to the repository can edit a release.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  releaseId  Required parameter: The unique identifier of the release.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposReleasesReleaseIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposReleasesReleaseIdResponse reposUpdateRelease(
            final String owner,
            final String repo,
            final int releaseId,
            final ReposReleasesReleaseIdRequest body) throws ApiException, IOException {
        return prepareReposUpdateReleaseRequest(owner, repo, releaseId, body).execute();
    }

    /**
     * Users with push access to the repository can edit a release.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  releaseId  Required parameter: The unique identifier of the release.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposReleasesReleaseIdResponse response from the API call
     */
    public CompletableFuture<ReposReleasesReleaseIdResponse> reposUpdateReleaseAsync(
            final String owner,
            final String repo,
            final int releaseId,
            final ReposReleasesReleaseIdRequest body) {
        try { 
            return prepareReposUpdateReleaseRequest(owner, repo, releaseId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposUpdateRelease.
     */
    private ApiCall<ReposReleasesReleaseIdResponse, ApiException> prepareReposUpdateReleaseRequest(
            final String owner,
            final String repo,
            final int releaseId,
            final ReposReleasesReleaseIdRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposReleasesReleaseIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/releases/{release_id}")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("release_id").value(releaseId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposReleasesReleaseIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Not Found if the discussion category name is invalid",
                                (reason, context) -> new ReposReleasesReleaseId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Users with push access to the repository can delete a release.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  releaseId  Required parameter: The unique identifier of the release.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteRelease(
            final String owner,
            final String repo,
            final int releaseId) throws ApiException, IOException {
        prepareReposDeleteReleaseRequest(owner, repo, releaseId).execute();
    }

    /**
     * Users with push access to the repository can delete a release.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  releaseId  Required parameter: The unique identifier of the release.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteReleaseAsync(
            final String owner,
            final String repo,
            final int releaseId) {
        try { 
            return prepareReposDeleteReleaseRequest(owner, repo, releaseId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteRelease.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteReleaseRequest(
            final String owner,
            final String repo,
            final int releaseId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/releases/{release_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("release_id").value(releaseId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List release assets.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  releaseId  Required parameter: The unique identifier of the release.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of ReleaseAsset response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<ReleaseAsset> reposListReleaseAssets(
            final String owner,
            final String repo,
            final int releaseId,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListReleaseAssetsRequest(owner, repo, releaseId, perPage,
                page).execute();
    }

    /**
     * List release assets.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  releaseId  Required parameter: The unique identifier of the release.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of ReleaseAsset response from the API call
     */
    public CompletableFuture<List<ReleaseAsset>> reposListReleaseAssetsAsync(
            final String owner,
            final String repo,
            final int releaseId,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListReleaseAssetsRequest(owner, repo, releaseId, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListReleaseAssets.
     */
    private ApiCall<List<ReleaseAsset>, ApiException> prepareReposListReleaseAssetsRequest(
            final String owner,
            final String repo,
            final int releaseId,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<ReleaseAsset>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/releases/{release_id}/assets")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("release_id").value(releaseId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        ReleaseAsset[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This endpoint makes use of [a Hypermedia
     * relation](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia) to
     * determine which URL to access. The endpoint you call to upload release assets is specific to
     * your release. Use the `upload_url` returned in the response of the [Create a release
     * endpoint](https://docs.github.com/rest/reference/repos#create-a-release) to upload a release
     * asset. You need to use an HTTP client which supports
     * [SNI](http://en.wikipedia.org/wiki/Server_Name_Indication) to make calls to this endpoint.
     * Most libraries will set the required `Content-Length` header automatically. Use the required
     * `Content-Type` header to provide the media type of the asset. For a list of media types, see
     * [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example:
     * `application/zip` GitHub expects the asset data in its raw binary form, rather than JSON. You
     * will send the raw binary content of the asset as the request body. Everything else about the
     * endpoint is the same as the rest of the API. For example, you'll still need to pass your
     * authentication to be able to upload an asset. When an upstream failure occurs, you will
     * receive a `502 Bad Gateway` status. This may leave an empty asset with a state of `starter`.
     * It can be safely deleted. **Notes:** * GitHub renames asset filenames that have special
     * characters, non-alphanumeric characters, and leading or trailing periods. The "[List assets
     * for a release](https://docs.github.com/rest/reference/repos#list-assets-for-a-release)"
     * endpoint lists the renamed filenames. For more information and help, contact [GitHub
     * Support](https://support.github.com/contact?tags=dotcom-rest-api). * If you upload an asset
     * with the same filename as another uploaded asset, you'll receive an error and must delete the
     * old file before you can re-upload the new asset.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  releaseId  Required parameter: The unique identifier of the release.
     * @param  name  Required parameter: Example:
     * @param  label  Optional parameter: Example:
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposReleasesReleaseIdAssetsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposReleasesReleaseIdAssetsResponse reposUploadReleaseAsset(
            final String owner,
            final String repo,
            final int releaseId,
            final String name,
            final String label,
            final String body) throws ApiException, IOException {
        return prepareReposUploadReleaseAssetRequest(owner, repo, releaseId, name, label,
                body).execute();
    }

    /**
     * This endpoint makes use of [a Hypermedia
     * relation](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia) to
     * determine which URL to access. The endpoint you call to upload release assets is specific to
     * your release. Use the `upload_url` returned in the response of the [Create a release
     * endpoint](https://docs.github.com/rest/reference/repos#create-a-release) to upload a release
     * asset. You need to use an HTTP client which supports
     * [SNI](http://en.wikipedia.org/wiki/Server_Name_Indication) to make calls to this endpoint.
     * Most libraries will set the required `Content-Length` header automatically. Use the required
     * `Content-Type` header to provide the media type of the asset. For a list of media types, see
     * [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example:
     * `application/zip` GitHub expects the asset data in its raw binary form, rather than JSON. You
     * will send the raw binary content of the asset as the request body. Everything else about the
     * endpoint is the same as the rest of the API. For example, you'll still need to pass your
     * authentication to be able to upload an asset. When an upstream failure occurs, you will
     * receive a `502 Bad Gateway` status. This may leave an empty asset with a state of `starter`.
     * It can be safely deleted. **Notes:** * GitHub renames asset filenames that have special
     * characters, non-alphanumeric characters, and leading or trailing periods. The "[List assets
     * for a release](https://docs.github.com/rest/reference/repos#list-assets-for-a-release)"
     * endpoint lists the renamed filenames. For more information and help, contact [GitHub
     * Support](https://support.github.com/contact?tags=dotcom-rest-api). * If you upload an asset
     * with the same filename as another uploaded asset, you'll receive an error and must delete the
     * old file before you can re-upload the new asset.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  releaseId  Required parameter: The unique identifier of the release.
     * @param  name  Required parameter: Example:
     * @param  label  Optional parameter: Example:
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposReleasesReleaseIdAssetsResponse response from the API call
     */
    public CompletableFuture<ReposReleasesReleaseIdAssetsResponse> reposUploadReleaseAssetAsync(
            final String owner,
            final String repo,
            final int releaseId,
            final String name,
            final String label,
            final String body) {
        try { 
            return prepareReposUploadReleaseAssetRequest(owner, repo, releaseId, name, label,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposUploadReleaseAsset.
     */
    private ApiCall<ReposReleasesReleaseIdAssetsResponse, ApiException> prepareReposUploadReleaseAssetRequest(
            final String owner,
            final String repo,
            final int releaseId,
            final String name,
            final String label,
            final String body) throws IOException {
        return new ApiCall.Builder<ReposReleasesReleaseIdAssetsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/releases/{release_id}/assets")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .queryParam(param -> param.key("name")
                                .value(name))
                        .queryParam(param -> param.key("label")
                                .value(label).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("release_id").value(releaseId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("*/*").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposReleasesReleaseIdAssetsResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Response if you upload an asset with the same filename as another uploaded asset",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of Integer response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<List<Integer>> reposGetCodeFrequencyStats(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposGetCodeFrequencyStatsRequest(owner, repo).execute();
    }

    /**
     * Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of Integer response from the API call
     */
    public CompletableFuture<List<List<Integer>>> reposGetCodeFrequencyStatsAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposGetCodeFrequencyStatsRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetCodeFrequencyStats.
     */
    private ApiCall<List<List<Integer>>, ApiException> prepareReposGetCodeFrequencyStatsRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<List<List<Integer>>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/stats/code_frequency")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response,
                                        new TypeReference<List<List<Integer>>>(){}))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns the last year of commit activity grouped by week. The `days` array is a group of
     * commits per day, starting on `Sunday`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of CommitActivity response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<CommitActivity> reposGetCommitActivityStats(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposGetCommitActivityStatsRequest(owner, repo).execute();
    }

    /**
     * Returns the last year of commit activity grouped by week. The `days` array is a group of
     * commits per day, starting on `Sunday`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of CommitActivity response from the API call
     */
    public CompletableFuture<List<CommitActivity>> reposGetCommitActivityStatsAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposGetCommitActivityStatsRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetCommitActivityStats.
     */
    private ApiCall<List<CommitActivity>, ApiException> prepareReposGetCommitActivityStatsRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<List<CommitActivity>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/stats/commit_activity")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        CommitActivity[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns the `total` number of commits authored by the contributor. In addition, the response
     * includes a Weekly Hash (`weeks` array) with the following information: * `w` - Start of the
     * week, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time). * `a` - Number of
     * additions * `d` - Number of deletions * `c` - Number of commits.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of ContributorActivity response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<ContributorActivity> reposGetContributorsStats(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposGetContributorsStatsRequest(owner, repo).execute();
    }

    /**
     * Returns the `total` number of commits authored by the contributor. In addition, the response
     * includes a Weekly Hash (`weeks` array) with the following information: * `w` - Start of the
     * week, given as a [Unix timestamp](http://en.wikipedia.org/wiki/Unix_time). * `a` - Number of
     * additions * `d` - Number of deletions * `c` - Number of commits.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of ContributorActivity response from the API call
     */
    public CompletableFuture<List<ContributorActivity>> reposGetContributorsStatsAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposGetContributorsStatsRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetContributorsStats.
     */
    private ApiCall<List<ContributorActivity>, ApiException> prepareReposGetContributorsStatsRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<List<ContributorActivity>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/stats/contributors")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        ContributorActivity[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is
     * everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the
     * commit counts for non-owners, you can subtract `owner` from `all`. The array order is oldest
     * week (index 0) to most recent week.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ParticipationStats response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ParticipationStats reposGetParticipationStats(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposGetParticipationStatsRequest(owner, repo).execute();
    }

    /**
     * Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is
     * everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the
     * commit counts for non-owners, you can subtract `owner` from `all`. The array order is oldest
     * week (index 0) to most recent week.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ParticipationStats response from the API call
     */
    public CompletableFuture<ParticipationStats> reposGetParticipationStatsAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposGetParticipationStatsRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetParticipationStats.
     */
    private ApiCall<ParticipationStats, ApiException> prepareReposGetParticipationStatsRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ParticipationStats, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/stats/participation")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ParticipationStats.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposStatsParticipation404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Each array contains the day number, hour number, and number of commits: * `0-6`: Sunday -
     * Saturday * `0-23`: Hour of day * Number of commits For example, `[2, 14, 25]` indicates that
     * there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the
     * time zone of individual commits.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of Integer response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<List<Integer>> reposGetPunchCardStats(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposGetPunchCardStatsRequest(owner, repo).execute();
    }

    /**
     * Each array contains the day number, hour number, and number of commits: * `0-6`: Sunday -
     * Saturday * `0-23`: Hour of day * Number of commits For example, `[2, 14, 25]` indicates that
     * there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the
     * time zone of individual commits.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of Integer response from the API call
     */
    public CompletableFuture<List<List<Integer>>> reposGetPunchCardStatsAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposGetPunchCardStatsRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetPunchCardStats.
     */
    private ApiCall<List<List<Integer>>, ApiException> prepareReposGetPunchCardStatsRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<List<List<Integer>>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/stats/punch_card")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response,
                                        new TypeReference<List<List<Integer>>>(){}))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Users with push access in a repository can create commit statuses for a given SHA. Note:
     * there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to
     * create more than 1000 statuses will result in a validation error.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  sha  Required parameter: Example:
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposStatusesShaResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposStatusesShaResponse reposCreateCommitStatus(
            final String owner,
            final String repo,
            final String sha,
            final ReposStatusesShaRequest body) throws ApiException, IOException {
        return prepareReposCreateCommitStatusRequest(owner, repo, sha, body).execute();
    }

    /**
     * Users with push access in a repository can create commit statuses for a given SHA. Note:
     * there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to
     * create more than 1000 statuses will result in a validation error.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  sha  Required parameter: Example:
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposStatusesShaResponse response from the API call
     */
    public CompletableFuture<ReposStatusesShaResponse> reposCreateCommitStatusAsync(
            final String owner,
            final String repo,
            final String sha,
            final ReposStatusesShaRequest body) {
        try { 
            return prepareReposCreateCommitStatusRequest(owner, repo, sha, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateCommitStatus.
     */
    private ApiCall<ReposStatusesShaResponse, ApiException> prepareReposCreateCommitStatusRequest(
            final String owner,
            final String repo,
            final String sha,
            final ReposStatusesShaRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposStatusesShaResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/statuses/{sha}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("sha").value(sha)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposStatusesShaResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List repository tags.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Tag response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Tag> reposListTags(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListTagsRequest(owner, repo, perPage, page).execute();
    }

    /**
     * List repository tags.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Tag response from the API call
     */
    public CompletableFuture<List<Tag>> reposListTagsAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListTagsRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListTags.
     */
    private ApiCall<List<Tag>, ApiException> prepareReposListTagsRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Tag>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/tags")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Tag[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This returns the tag protection states of a repository. This information is only available to
     * repository administrators.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of Tagprotection response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Tagprotection> reposListTagProtection(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposListTagProtectionRequest(owner, repo).execute();
    }

    /**
     * This returns the tag protection states of a repository. This information is only available to
     * repository administrators.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of Tagprotection response from the API call
     */
    public CompletableFuture<List<Tagprotection>> reposListTagProtectionAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposListTagProtectionRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListTagProtection.
     */
    private ApiCall<List<Tagprotection>, ApiException> prepareReposListTagProtectionRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<List<Tagprotection>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/tags/protection")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Tagprotection[].class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposTagsProtection403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposTagsProtection404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This creates a tag protection state for a repository. This endpoint is only available to
     * repository administrators.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposTagsProtectionResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposTagsProtectionResponse reposCreateTagProtection(
            final String owner,
            final String repo,
            final ReposTagsProtectionRequest body) throws ApiException, IOException {
        return prepareReposCreateTagProtectionRequest(owner, repo, body).execute();
    }

    /**
     * This creates a tag protection state for a repository. This endpoint is only available to
     * repository administrators.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposTagsProtectionResponse response from the API call
     */
    public CompletableFuture<ReposTagsProtectionResponse> reposCreateTagProtectionAsync(
            final String owner,
            final String repo,
            final ReposTagsProtectionRequest body) {
        try { 
            return prepareReposCreateTagProtectionRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateTagProtection.
     */
    private ApiCall<ReposTagsProtectionResponse, ApiException> prepareReposCreateTagProtectionRequest(
            final String owner,
            final String repo,
            final ReposTagsProtectionRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposTagsProtectionResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/tags/protection")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposTagsProtectionResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposTagsProtection403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposTagsProtection404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This deletes a tag protection state for a repository. This endpoint is only available to
     * repository administrators.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  tagProtectionId  Required parameter: The unique identifier of the tag protection.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeleteTagProtection(
            final String owner,
            final String repo,
            final int tagProtectionId) throws ApiException, IOException {
        prepareReposDeleteTagProtectionRequest(owner, repo, tagProtectionId).execute();
    }

    /**
     * This deletes a tag protection state for a repository. This endpoint is only available to
     * repository administrators.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  tagProtectionId  Required parameter: The unique identifier of the tag protection.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeleteTagProtectionAsync(
            final String owner,
            final String repo,
            final int tagProtectionId) {
        try { 
            return prepareReposDeleteTagProtectionRequest(owner, repo, tagProtectionId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeleteTagProtection.
     */
    private ApiCall<Void, ApiException> prepareReposDeleteTagProtectionRequest(
            final String owner,
            final String repo,
            final int tagProtectionId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/tags/protection/{tag_protection_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("tag_protection_id").value(tagProtectionId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposTagsProtectionTagProtectionId403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposTagsProtectionTagProtectionId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the
     * repositorys default branch (usually `main`) will be used. Please make sure your HTTP
     * framework is configured to follow redirects or you will need to use the `Location` header to
     * make a second `GET` request. **Note**: For private repositories, these links are temporary
     * and expire after five minutes.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDownloadTarballArchive(
            final String owner,
            final String repo,
            final String ref) throws ApiException, IOException {
        prepareReposDownloadTarballArchiveRequest(owner, repo, ref).execute();
    }

    /**
     * Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the
     * repositorys default branch (usually `main`) will be used. Please make sure your HTTP
     * framework is configured to follow redirects or you will need to use the `Location` header to
     * make a second `GET` request. **Note**: For private repositories, these links are temporary
     * and expire after five minutes.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDownloadTarballArchiveAsync(
            final String owner,
            final String repo,
            final String ref) {
        try { 
            return prepareReposDownloadTarballArchiveRequest(owner, repo, ref).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDownloadTarballArchive.
     */
    private ApiCall<Void, ApiException> prepareReposDownloadTarballArchiveRequest(
            final String owner,
            final String repo,
            final String ref) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/tarball/{ref}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("ref").value(ref)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List repository teams.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Team response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Team> reposListTeams(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListTeamsRequest(owner, repo, perPage, page).execute();
    }

    /**
     * List repository teams.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Team response from the API call
     */
    public CompletableFuture<List<Team>> reposListTeamsAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListTeamsRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListTeams.
     */
    private ApiCall<List<Team>, ApiException> prepareReposListTeamsRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Team>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/teams")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Team[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get all repository topics.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the ReposTopicsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposTopicsResponse reposGetAllTopics(
            final String owner,
            final String repo,
            final Integer page,
            final Integer perPage) throws ApiException, IOException {
        return prepareReposGetAllTopicsRequest(owner, repo, page, perPage).execute();
    }

    /**
     * Get all repository topics.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the ReposTopicsResponse response from the API call
     */
    public CompletableFuture<ReposTopicsResponse> reposGetAllTopicsAsync(
            final String owner,
            final String repo,
            final Integer page,
            final Integer perPage) {
        try { 
            return prepareReposGetAllTopicsRequest(owner, repo, page, perPage).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetAllTopics.
     */
    private ApiCall<ReposTopicsResponse, ApiException> prepareReposGetAllTopicsRequest(
            final String owner,
            final String repo,
            final Integer page,
            final Integer perPage) throws IOException {
        return new ApiCall.Builder<ReposTopicsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/topics")
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposTopicsResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposTopics404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Replace all repository topics.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposTopicsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposTopicsResponse reposReplaceAllTopics(
            final String owner,
            final String repo,
            final ReposTopicsRequest body) throws ApiException, IOException {
        return prepareReposReplaceAllTopicsRequest(owner, repo, body).execute();
    }

    /**
     * Replace all repository topics.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposTopicsResponse response from the API call
     */
    public CompletableFuture<ReposTopicsResponse> reposReplaceAllTopicsAsync(
            final String owner,
            final String repo,
            final ReposTopicsRequest body) {
        try { 
            return prepareReposReplaceAllTopicsRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposReplaceAllTopics.
     */
    private ApiCall<ReposTopicsResponse, ApiException> prepareReposReplaceAllTopicsRequest(
            final String owner,
            final String repo,
            final ReposTopicsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposTopicsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/topics")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposTopicsResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposTopics404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposTopics422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps
     * are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  per  Optional parameter: The time frame to display results for.
     * @return    Returns the ReposTrafficClonesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposTrafficClonesResponse reposGetClones(
            final String owner,
            final String repo,
            final Per1Enum per) throws ApiException, IOException {
        return prepareReposGetClonesRequest(owner, repo, per).execute();
    }

    /**
     * Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps
     * are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  per  Optional parameter: The time frame to display results for.
     * @return    Returns the ReposTrafficClonesResponse response from the API call
     */
    public CompletableFuture<ReposTrafficClonesResponse> reposGetClonesAsync(
            final String owner,
            final String repo,
            final Per1Enum per) {
        try { 
            return prepareReposGetClonesRequest(owner, repo, per).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetClones.
     */
    private ApiCall<ReposTrafficClonesResponse, ApiException> prepareReposGetClonesRequest(
            final String owner,
            final String repo,
            final Per1Enum per) throws IOException {
        return new ApiCall.Builder<ReposTrafficClonesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/traffic/clones")
                        .queryParam(param -> param.key("per")
                                .value((per != null) ? per.value() : null).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposTrafficClonesResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposTrafficClones403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get the top 10 popular contents over the last 14 days.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of ContentTraffic response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<ContentTraffic> reposGetTopPaths(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposGetTopPathsRequest(owner, repo).execute();
    }

    /**
     * Get the top 10 popular contents over the last 14 days.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of ContentTraffic response from the API call
     */
    public CompletableFuture<List<ContentTraffic>> reposGetTopPathsAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposGetTopPathsRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetTopPaths.
     */
    private ApiCall<List<ContentTraffic>, ApiException> prepareReposGetTopPathsRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<List<ContentTraffic>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/traffic/popular/paths")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        ContentTraffic[].class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposTrafficPopularPaths403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get the top 10 referrers over the last 14 days.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of ReferrerTraffic response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<ReferrerTraffic> reposGetTopReferrers(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareReposGetTopReferrersRequest(owner, repo).execute();
    }

    /**
     * Get the top 10 referrers over the last 14 days.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of ReferrerTraffic response from the API call
     */
    public CompletableFuture<List<ReferrerTraffic>> reposGetTopReferrersAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposGetTopReferrersRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetTopReferrers.
     */
    private ApiCall<List<ReferrerTraffic>, ApiException> prepareReposGetTopReferrersRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<List<ReferrerTraffic>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/traffic/popular/referrers")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        ReferrerTraffic[].class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposTrafficPopularReferrers403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get the total number of views and breakdown per day or week for the last 14 days. Timestamps
     * are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  per  Optional parameter: The time frame to display results for.
     * @return    Returns the ReposTrafficViewsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposTrafficViewsResponse reposGetViews(
            final String owner,
            final String repo,
            final Per1Enum per) throws ApiException, IOException {
        return prepareReposGetViewsRequest(owner, repo, per).execute();
    }

    /**
     * Get the total number of views and breakdown per day or week for the last 14 days. Timestamps
     * are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  per  Optional parameter: The time frame to display results for.
     * @return    Returns the ReposTrafficViewsResponse response from the API call
     */
    public CompletableFuture<ReposTrafficViewsResponse> reposGetViewsAsync(
            final String owner,
            final String repo,
            final Per1Enum per) {
        try { 
            return prepareReposGetViewsRequest(owner, repo, per).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposGetViews.
     */
    private ApiCall<ReposTrafficViewsResponse, ApiException> prepareReposGetViewsRequest(
            final String owner,
            final String repo,
            final Per1Enum per) throws IOException {
        return new ApiCall.Builder<ReposTrafficViewsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/traffic/views")
                        .queryParam(param -> param.key("per")
                                .value((per != null) ? per.value() : null).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposTrafficViewsResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposTrafficViews403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * A transfer request will need to be accepted by the new owner when transferring a personal
     * repository to another user. The response will contain the original `owner`, and the transfer
     * will continue asynchronously. For more details on the requirements to transfer personal and
     * organization-owned repositories, see [about repository
     * transfers](https://docs.github.com/articles/about-repository-transfers/).
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposTransferResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposTransferResponse reposTransfer(
            final String owner,
            final String repo,
            final ReposTransferRequest body) throws ApiException, IOException {
        return prepareReposTransferRequest(owner, repo, body).execute();
    }

    /**
     * A transfer request will need to be accepted by the new owner when transferring a personal
     * repository to another user. The response will contain the original `owner`, and the transfer
     * will continue asynchronously. For more details on the requirements to transfer personal and
     * organization-owned repositories, see [about repository
     * transfers](https://docs.github.com/articles/about-repository-transfers/).
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposTransferResponse response from the API call
     */
    public CompletableFuture<ReposTransferResponse> reposTransferAsync(
            final String owner,
            final String repo,
            final ReposTransferRequest body) {
        try { 
            return prepareReposTransferRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposTransfer.
     */
    private ApiCall<ReposTransferResponse, ApiException> prepareReposTransferRequest(
            final String owner,
            final String repo,
            final ReposTransferRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposTransferResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/transfer")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposTransferResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Shows whether dependency alerts are enabled or disabled for a repository. The authenticated
     * user must have admin read access to the repository. For more information, see "[About
     * security alerts for vulnerable
     * dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposCheckVulnerabilityAlerts(
            final String owner,
            final String repo) throws ApiException, IOException {
        prepareReposCheckVulnerabilityAlertsRequest(owner, repo).execute();
    }

    /**
     * Shows whether dependency alerts are enabled or disabled for a repository. The authenticated
     * user must have admin read access to the repository. For more information, see "[About
     * security alerts for vulnerable
     * dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposCheckVulnerabilityAlertsAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposCheckVulnerabilityAlertsRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCheckVulnerabilityAlerts.
     */
    private ApiCall<Void, ApiException> prepareReposCheckVulnerabilityAlertsRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/vulnerability-alerts")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Not Found if repository is not enabled with vulnerability alerts",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Enables dependency alerts and the dependency graph for a repository. The authenticated user
     * must have admin access to the repository. For more information, see "[About security alerts
     * for vulnerable
     * dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposEnableVulnerabilityAlerts(
            final String owner,
            final String repo) throws ApiException, IOException {
        prepareReposEnableVulnerabilityAlertsRequest(owner, repo).execute();
    }

    /**
     * Enables dependency alerts and the dependency graph for a repository. The authenticated user
     * must have admin access to the repository. For more information, see "[About security alerts
     * for vulnerable
     * dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposEnableVulnerabilityAlertsAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposEnableVulnerabilityAlertsRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposEnableVulnerabilityAlerts.
     */
    private ApiCall<Void, ApiException> prepareReposEnableVulnerabilityAlertsRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/vulnerability-alerts")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Disables dependency alerts and the dependency graph for a repository. The authenticated user
     * must have admin access to the repository. For more information, see "[About security alerts
     * for vulnerable
     * dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDisableVulnerabilityAlerts(
            final String owner,
            final String repo) throws ApiException, IOException {
        prepareReposDisableVulnerabilityAlertsRequest(owner, repo).execute();
    }

    /**
     * Disables dependency alerts and the dependency graph for a repository. The authenticated user
     * must have admin access to the repository. For more information, see "[About security alerts
     * for vulnerable
     * dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDisableVulnerabilityAlertsAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareReposDisableVulnerabilityAlertsRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDisableVulnerabilityAlerts.
     */
    private ApiCall<Void, ApiException> prepareReposDisableVulnerabilityAlertsRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/vulnerability-alerts")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the
     * repositorys default branch (usually `main`) will be used. Please make sure your HTTP
     * framework is configured to follow redirects or you will need to use the `Location` header to
     * make a second `GET` request. **Note**: For private repositories, these links are temporary
     * and expire after five minutes. If the repository is empty, you will receive a 404 when you
     * follow the redirect.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDownloadZipballArchive(
            final String owner,
            final String repo,
            final String ref) throws ApiException, IOException {
        prepareReposDownloadZipballArchiveRequest(owner, repo, ref).execute();
    }

    /**
     * Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the
     * repositorys default branch (usually `main`) will be used. Please make sure your HTTP
     * framework is configured to follow redirects or you will need to use the `Location` header to
     * make a second `GET` request. **Note**: For private repositories, these links are temporary
     * and expire after five minutes. If the repository is empty, you will receive a 404 when you
     * follow the redirect.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDownloadZipballArchiveAsync(
            final String owner,
            final String repo,
            final String ref) {
        try { 
            return prepareReposDownloadZipballArchiveRequest(owner, repo, ref).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDownloadZipballArchive.
     */
    private ApiCall<Void, ApiException> prepareReposDownloadZipballArchiveRequest(
            final String owner,
            final String repo,
            final String ref) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/zipball/{ref}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("ref").value(ref)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates a new repository using a repository template. Use the `template_owner` and
     * `template_repo` route parameters to specify the repository to use as the template. If the
     * repository is not public, the authenticated user must own or be a member of an organization
     * that owns the repository. To check if a repository is available to use as a template, get the
     * repository's information using the [Get a
     * repository](https://docs.github.com/rest/reference/repos#get-a-repository) endpoint and check
     * that the `is_template` key is `true`. **OAuth scope requirements** When using
     * [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/),
     * authorizations must include: * `public_repo` scope or `repo` scope to create a public
     * repository. Note: For GitHub AE, use `repo` scope to create an internal repository. * `repo`
     * scope to create a private repository.
     * @param  templateOwner  Required parameter: Example:
     * @param  templateRepo  Required parameter: Example:
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposGenerateResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposGenerateResponse reposCreateUsingTemplate(
            final String templateOwner,
            final String templateRepo,
            final ReposGenerateRequest body) throws ApiException, IOException {
        return prepareReposCreateUsingTemplateRequest(templateOwner, templateRepo, body).execute();
    }

    /**
     * Creates a new repository using a repository template. Use the `template_owner` and
     * `template_repo` route parameters to specify the repository to use as the template. If the
     * repository is not public, the authenticated user must own or be a member of an organization
     * that owns the repository. To check if a repository is available to use as a template, get the
     * repository's information using the [Get a
     * repository](https://docs.github.com/rest/reference/repos#get-a-repository) endpoint and check
     * that the `is_template` key is `true`. **OAuth scope requirements** When using
     * [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/),
     * authorizations must include: * `public_repo` scope or `repo` scope to create a public
     * repository. Note: For GitHub AE, use `repo` scope to create an internal repository. * `repo`
     * scope to create a private repository.
     * @param  templateOwner  Required parameter: Example:
     * @param  templateRepo  Required parameter: Example:
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposGenerateResponse response from the API call
     */
    public CompletableFuture<ReposGenerateResponse> reposCreateUsingTemplateAsync(
            final String templateOwner,
            final String templateRepo,
            final ReposGenerateRequest body) {
        try { 
            return prepareReposCreateUsingTemplateRequest(templateOwner, templateRepo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateUsingTemplate.
     */
    private ApiCall<ReposGenerateResponse, ApiException> prepareReposCreateUsingTemplateRequest(
            final String templateOwner,
            final String templateRepo,
            final ReposGenerateRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposGenerateResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{template_owner}/{template_repo}/generate")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("template_owner").value(templateOwner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("template_repo").value(templateRepo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposGenerateResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all public repositories in the order that they were created. Note: - For GitHub
     * Enterprise Server, this endpoint will only list repositories available to all users on the
     * enterprise. - Pagination is powered exclusively by the `since` parameter. Use the [Link
     * header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get
     * the URL for the next page of repositories.
     * @param  since  Optional parameter: A repository ID. Only return repositories with an ID
     *         greater than this ID.
     * @return    Returns the List of MinimalRepository response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<MinimalRepository> reposListPublic(
            final Integer since) throws ApiException, IOException {
        return prepareReposListPublicRequest(since).execute();
    }

    /**
     * Lists all public repositories in the order that they were created. Note: - For GitHub
     * Enterprise Server, this endpoint will only list repositories available to all users on the
     * enterprise. - Pagination is powered exclusively by the `since` parameter. Use the [Link
     * header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get
     * the URL for the next page of repositories.
     * @param  since  Optional parameter: A repository ID. Only return repositories with an ID
     *         greater than this ID.
     * @return    Returns the List of MinimalRepository response from the API call
     */
    public CompletableFuture<List<MinimalRepository>> reposListPublicAsync(
            final Integer since) {
        try { 
            return prepareReposListPublicRequest(since).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListPublic.
     */
    private ApiCall<List<MinimalRepository>, ApiException> prepareReposListPublicRequest(
            final Integer since) throws IOException {
        return new ApiCall.Builder<List<MinimalRepository>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repositories")
                        .queryParam(param -> param.key("since")
                                .value(since).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        MinimalRepository[].class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new Repositories422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or
     * `:admin`) to access. The authenticated user has explicit permission to access repositories
     * they own, repositories where they are a collaborator, and repositories that they can access
     * through an organization membership.
     * @param  visibility  Optional parameter: Limit results to repositories with the specified
     *         visibility.
     * @param  affiliation  Optional parameter: Comma-separated list of values. Can include: *
     *         `owner`: Repositories that are owned by the authenticated user. * `collaborator`:
     *         Repositories that the user has been added to as a collaborator. *
     *         `organization_member`: Repositories that the user has access to through being a
     *         member of an organization. This includes every repository on every team that the user
     *         is on.
     * @param  type  Optional parameter: Limit results to repositories of the specified type. Will
     *         cause a `422` error if used in the same request as **visibility** or **affiliation**.
     * @param  sort  Optional parameter: The property to sort the results by.
     * @param  direction  Optional parameter: The order to sort by. Default: `asc` when using
     *         `full_name`, otherwise `desc`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  before  Optional parameter: Only show notifications updated before the given time.
     *         This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @return    Returns the List of Repository response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Repository> reposListForAuthenticatedUser(
            final Visibility911Enum visibility,
            final String affiliation,
            final Type6151Enum type,
            final Sort61Enum sort,
            final Direction21Enum direction,
            final Integer perPage,
            final Integer page,
            final LocalDateTime since,
            final LocalDateTime before) throws ApiException, IOException {
        return prepareReposListForAuthenticatedUserRequest(visibility, affiliation, type, sort,
                direction, perPage, page, since, before).execute();
    }

    /**
     * Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or
     * `:admin`) to access. The authenticated user has explicit permission to access repositories
     * they own, repositories where they are a collaborator, and repositories that they can access
     * through an organization membership.
     * @param  visibility  Optional parameter: Limit results to repositories with the specified
     *         visibility.
     * @param  affiliation  Optional parameter: Comma-separated list of values. Can include: *
     *         `owner`: Repositories that are owned by the authenticated user. * `collaborator`:
     *         Repositories that the user has been added to as a collaborator. *
     *         `organization_member`: Repositories that the user has access to through being a
     *         member of an organization. This includes every repository on every team that the user
     *         is on.
     * @param  type  Optional parameter: Limit results to repositories of the specified type. Will
     *         cause a `422` error if used in the same request as **visibility** or **affiliation**.
     * @param  sort  Optional parameter: The property to sort the results by.
     * @param  direction  Optional parameter: The order to sort by. Default: `asc` when using
     *         `full_name`, otherwise `desc`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  before  Optional parameter: Only show notifications updated before the given time.
     *         This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @return    Returns the List of Repository response from the API call
     */
    public CompletableFuture<List<Repository>> reposListForAuthenticatedUserAsync(
            final Visibility911Enum visibility,
            final String affiliation,
            final Type6151Enum type,
            final Sort61Enum sort,
            final Direction21Enum direction,
            final Integer perPage,
            final Integer page,
            final LocalDateTime since,
            final LocalDateTime before) {
        try { 
            return prepareReposListForAuthenticatedUserRequest(visibility, affiliation, type, sort,
            direction, perPage, page, since, before).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListForAuthenticatedUser.
     */
    private ApiCall<List<Repository>, ApiException> prepareReposListForAuthenticatedUserRequest(
            final Visibility911Enum visibility,
            final String affiliation,
            final Type6151Enum type,
            final Sort61Enum sort,
            final Direction21Enum direction,
            final Integer perPage,
            final Integer page,
            final LocalDateTime since,
            final LocalDateTime before) throws IOException {
        return new ApiCall.Builder<List<Repository>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/repos")
                        .queryParam(param -> param.key("visibility")
                                .value((visibility != null) ? visibility.value() : null).isRequired(false))
                        .queryParam(param -> param.key("affiliation")
                                .value((affiliation != null) ? affiliation : "owner,collaborator,organization_member").isRequired(false))
                        .queryParam(param -> param.key("type")
                                .value((type != null) ? type.value() : null).isRequired(false))
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("since")
                                .value(DateTimeHelper.toRfc8601DateTime(since)).isRequired(false))
                        .queryParam(param -> param.key("before")
                                .value(DateTimeHelper.toRfc8601DateTime(before)).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Repository[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserRepos401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserRepos403ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UserRepos422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates a new repository for the authenticated user. **OAuth scope requirements** When using
     * [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/),
     * authorizations must include: * `public_repo` scope or `repo` scope to create a public
     * repository. Note: For GitHub AE, use `repo` scope to create an internal repository. * `repo`
     * scope to create a private repository.
     * @param  body  Required parameter: Example:
     * @return    Returns the UserReposResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserReposResponse reposCreateForAuthenticatedUser(
            final UserReposRequest body) throws ApiException, IOException {
        return prepareReposCreateForAuthenticatedUserRequest(body).execute();
    }

    /**
     * Creates a new repository for the authenticated user. **OAuth scope requirements** When using
     * [OAuth](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/),
     * authorizations must include: * `public_repo` scope or `repo` scope to create a public
     * repository. Note: For GitHub AE, use `repo` scope to create an internal repository. * `repo`
     * scope to create a private repository.
     * @param  body  Required parameter: Example:
     * @return    Returns the UserReposResponse response from the API call
     */
    public CompletableFuture<UserReposResponse> reposCreateForAuthenticatedUserAsync(
            final UserReposRequest body) {
        try { 
            return prepareReposCreateForAuthenticatedUserRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposCreateForAuthenticatedUser.
     */
    private ApiCall<UserReposResponse, ApiException> prepareReposCreateForAuthenticatedUserRequest(
            final UserReposRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<UserReposResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/repos")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserReposResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new UserRepos400ErrorException(reason, context)))
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserRepos401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserRepos403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserRepos404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UserRepos422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * When authenticating as a user, this endpoint will list all currently open repository
     * invitations for that user.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of RepositoryInvitation response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<RepositoryInvitation> reposListInvitationsForAuthenticatedUser(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListInvitationsForAuthenticatedUserRequest(perPage, page).execute();
    }

    /**
     * When authenticating as a user, this endpoint will list all currently open repository
     * invitations for that user.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of RepositoryInvitation response from the API call
     */
    public CompletableFuture<List<RepositoryInvitation>> reposListInvitationsForAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListInvitationsForAuthenticatedUserRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListInvitationsForAuthenticatedUser.
     */
    private ApiCall<List<RepositoryInvitation>, ApiException> prepareReposListInvitationsForAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<RepositoryInvitation>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/repository_invitations")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        RepositoryInvitation[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserRepositoryInvitations401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserRepositoryInvitations403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserRepositoryInvitations404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Accept a repository invitation.
     * @param  invitationId  Required parameter: The unique identifier of the invitation.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposAcceptInvitationForAuthenticatedUser(
            final int invitationId) throws ApiException, IOException {
        prepareReposAcceptInvitationForAuthenticatedUserRequest(invitationId).execute();
    }

    /**
     * Accept a repository invitation.
     * @param  invitationId  Required parameter: The unique identifier of the invitation.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposAcceptInvitationForAuthenticatedUserAsync(
            final int invitationId) {
        try { 
            return prepareReposAcceptInvitationForAuthenticatedUserRequest(invitationId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposAcceptInvitationForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareReposAcceptInvitationForAuthenticatedUserRequest(
            final int invitationId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/repository_invitations/{invitation_id}")
                        .templateParam(param -> param.key("invitation_id").value(invitationId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserRepositoryInvitations403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserRepositoryInvitations404ErrorException(reason, context)))
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict",
                                (reason, context) -> new UserRepositoryInvitations409ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Decline a repository invitation.
     * @param  invitationId  Required parameter: The unique identifier of the invitation.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void reposDeclineInvitationForAuthenticatedUser(
            final int invitationId) throws ApiException, IOException {
        prepareReposDeclineInvitationForAuthenticatedUserRequest(invitationId).execute();
    }

    /**
     * Decline a repository invitation.
     * @param  invitationId  Required parameter: The unique identifier of the invitation.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> reposDeclineInvitationForAuthenticatedUserAsync(
            final int invitationId) {
        try { 
            return prepareReposDeclineInvitationForAuthenticatedUserRequest(invitationId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposDeclineInvitationForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareReposDeclineInvitationForAuthenticatedUserRequest(
            final int invitationId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/repository_invitations/{invitation_id}")
                        .templateParam(param -> param.key("invitation_id").value(invitationId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserRepositoryInvitations403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserRepositoryInvitations404ErrorException(reason, context)))
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict",
                                (reason, context) -> new UserRepositoryInvitations409ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists public repositories for the specified user. Note: For GitHub AE, this endpoint will
     * list internal repositories for the specified user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  type  Optional parameter: Limit results to repositories of the specified type.
     * @param  sort  Optional parameter: The property to sort the results by.
     * @param  direction  Optional parameter: The order to sort by. Default: `asc` when using
     *         `full_name`, otherwise `desc`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MinimalRepository response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<MinimalRepository> reposListForUser(
            final String username,
            final Type6161Enum type,
            final Sort61Enum sort,
            final Direction21Enum direction,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareReposListForUserRequest(username, type, sort, direction, perPage,
                page).execute();
    }

    /**
     * Lists public repositories for the specified user. Note: For GitHub AE, this endpoint will
     * list internal repositories for the specified user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  type  Optional parameter: Limit results to repositories of the specified type.
     * @param  sort  Optional parameter: The property to sort the results by.
     * @param  direction  Optional parameter: The order to sort by. Default: `asc` when using
     *         `full_name`, otherwise `desc`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MinimalRepository response from the API call
     */
    public CompletableFuture<List<MinimalRepository>> reposListForUserAsync(
            final String username,
            final Type6161Enum type,
            final Sort61Enum sort,
            final Direction21Enum direction,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareReposListForUserRequest(username, type, sort, direction, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for reposListForUser.
     */
    private ApiCall<List<MinimalRepository>, ApiException> prepareReposListForUserRequest(
            final String username,
            final Type6161Enum type,
            final Sort61Enum sort,
            final Direction21Enum direction,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<MinimalRepository>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/repos")
                        .queryParam(param -> param.key("type")
                                .value((type != null) ? type.value() : null).isRequired(false))
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        MinimalRepository[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}