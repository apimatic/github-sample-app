/*
 * GitHubAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.github.api.controllers;

import com.github.api.ApiHelper;
import com.github.api.Server;
import com.github.api.exceptions.ApiException;
import com.github.api.exceptions.OrgsPackages401ErrorException;
import com.github.api.exceptions.OrgsPackages403ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageName401ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageName403ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageName404ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageNameRestore401ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageNameRestore403ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageNameRestore404ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageNameVersions401ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageNameVersions403ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageNameVersions404ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageNameVersionsPackageVersionId401ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageNameVersionsPackageVersionId403ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageNameVersionsPackageVersionId404ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageNameVersionsPackageVersionIdRestore401ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageNameVersionsPackageVersionIdRestore403ErrorException;
import com.github.api.exceptions.OrgsPackagesPackageNameVersionsPackageVersionIdRestore404ErrorException;
import com.github.api.exceptions.UserPackages401ErrorException;
import com.github.api.exceptions.UserPackages403ErrorException;
import com.github.api.exceptions.UserPackages404ErrorException;
import com.github.api.exceptions.UserPackagesRestore401ErrorException;
import com.github.api.exceptions.UserPackagesRestore403ErrorException;
import com.github.api.exceptions.UserPackagesRestore404ErrorException;
import com.github.api.exceptions.UserPackagesVersions401ErrorException;
import com.github.api.exceptions.UserPackagesVersions403ErrorException;
import com.github.api.exceptions.UserPackagesVersions404ErrorException;
import com.github.api.exceptions.UserPackagesVersionsPackageVersionId401ErrorException;
import com.github.api.exceptions.UserPackagesVersionsPackageVersionId403ErrorException;
import com.github.api.exceptions.UserPackagesVersionsPackageVersionId404ErrorException;
import com.github.api.exceptions.UserPackagesVersionsPackageVersionIdRestore401ErrorException;
import com.github.api.exceptions.UserPackagesVersionsPackageVersionIdRestore403ErrorException;
import com.github.api.exceptions.UserPackagesVersionsPackageVersionIdRestore404ErrorException;
import com.github.api.exceptions.UsersPackages401ErrorException;
import com.github.api.exceptions.UsersPackages403ErrorException;
import com.github.api.exceptions.UsersPackagesPackageName401ErrorException;
import com.github.api.exceptions.UsersPackagesPackageName403ErrorException;
import com.github.api.exceptions.UsersPackagesPackageName404ErrorException;
import com.github.api.exceptions.UsersPackagesPackageNameRestore401ErrorException;
import com.github.api.exceptions.UsersPackagesPackageNameRestore403ErrorException;
import com.github.api.exceptions.UsersPackagesPackageNameRestore404ErrorException;
import com.github.api.exceptions.UsersPackagesPackageNameVersions401ErrorException;
import com.github.api.exceptions.UsersPackagesPackageNameVersions403ErrorException;
import com.github.api.exceptions.UsersPackagesPackageNameVersions404ErrorException;
import com.github.api.exceptions.UsersPackagesPackageNameVersionsPackageVersionId401ErrorException;
import com.github.api.exceptions.UsersPackagesPackageNameVersionsPackageVersionId403ErrorException;
import com.github.api.exceptions.UsersPackagesPackageNameVersionsPackageVersionId404ErrorException;
import com.github.api.exceptions.UsersPackagesPackageNameVersionsPackageVersionIdRestore401ErrorException;
import com.github.api.exceptions.UsersPackagesPackageNameVersionsPackageVersionIdRestore403ErrorException;
import com.github.api.exceptions.UsersPackagesPackageNameVersionsPackageVersionIdRestore404ErrorException;
import com.github.api.http.request.HttpMethod;
import com.github.api.models.OrgsPackagesPackageNameResponse;
import com.github.api.models.OrgsPackagesPackageNameVersionsPackageVersionIdResponse;
import com.github.api.models.Package;
import com.github.api.models.PackageType21Enum;
import com.github.api.models.PackageVersion;
import com.github.api.models.State63Enum;
import com.github.api.models.UserPackagesResponse;
import com.github.api.models.UserPackagesVersionsPackageVersionIdResponse;
import com.github.api.models.UsersPackagesPackageNameResponse;
import com.github.api.models.UsersPackagesPackageNameVersionsPackageVersionIdResponse;
import com.github.api.models.Visibility636Enum;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class PackagesController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public PackagesController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Lists all packages in an organization readable by the user. To use this endpoint, you must
     * authenticate using an access token with the `read:packages` scope. If the `package_type`
     * belongs to a registry that only supports repository-scoped permissions, your token must also
     * include the `repo` scope. For the list of GitHub Packages registries that only support
     * repository-scoped permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  visibility  Optional parameter: The selected visibility of the packages. This
     *         parameter is optional and only filters an existing result set. The `internal`
     *         visibility is only supported for GitHub Packages registries that allow for granular
     *         permissions. For other ecosystems `internal` is synonymous with `private`. For the
     *         list of GitHub Packages registries that support granular permissions, see "[About
     *         permissions for GitHub
     *         Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."
     * @return    Returns the List of Package response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Package> packagesListPackagesForOrganization(
            final PackageType21Enum packageType,
            final String org,
            final Visibility636Enum visibility) throws ApiException, IOException {
        return preparePackagesListPackagesForOrganizationRequest(packageType, org,
                visibility).execute();
    }

    /**
     * Lists all packages in an organization readable by the user. To use this endpoint, you must
     * authenticate using an access token with the `read:packages` scope. If the `package_type`
     * belongs to a registry that only supports repository-scoped permissions, your token must also
     * include the `repo` scope. For the list of GitHub Packages registries that only support
     * repository-scoped permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  visibility  Optional parameter: The selected visibility of the packages. This
     *         parameter is optional and only filters an existing result set. The `internal`
     *         visibility is only supported for GitHub Packages registries that allow for granular
     *         permissions. For other ecosystems `internal` is synonymous with `private`. For the
     *         list of GitHub Packages registries that support granular permissions, see "[About
     *         permissions for GitHub
     *         Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."
     * @return    Returns the List of Package response from the API call
     */
    public CompletableFuture<List<Package>> packagesListPackagesForOrganizationAsync(
            final PackageType21Enum packageType,
            final String org,
            final Visibility636Enum visibility) {
        try { 
            return preparePackagesListPackagesForOrganizationRequest(packageType, org,
            visibility).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesListPackagesForOrganization.
     */
    private ApiCall<List<Package>, ApiException> preparePackagesListPackagesForOrganizationRequest(
            final PackageType21Enum packageType,
            final String org,
            final Visibility636Enum visibility) throws IOException {
        return new ApiCall.Builder<List<Package>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/packages")
                        .queryParam(param -> param.key("package_type")
                                .value((packageType != null) ? packageType.value() : null))
                        .queryParam(param -> param.key("visibility")
                                .value((visibility != null) ? visibility.value() : null).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Package[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new OrgsPackages401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new OrgsPackages403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific package in an organization. To use this endpoint, you must authenticate using
     * an access token with the `read:packages` scope. If the `package_type` belongs to a GitHub
     * Packages registry that only supports repository-scoped permissions, your token must also
     * include the `repo` scope. For the list of GitHub Packages registries that only support
     * repository-scoped permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the OrgsPackagesPackageNameResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsPackagesPackageNameResponse packagesGetPackageForOrganization(
            final PackageType21Enum packageType,
            final String packageName,
            final String org) throws ApiException, IOException {
        return preparePackagesGetPackageForOrganizationRequest(packageType, packageName,
                org).execute();
    }

    /**
     * Gets a specific package in an organization. To use this endpoint, you must authenticate using
     * an access token with the `read:packages` scope. If the `package_type` belongs to a GitHub
     * Packages registry that only supports repository-scoped permissions, your token must also
     * include the `repo` scope. For the list of GitHub Packages registries that only support
     * repository-scoped permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the OrgsPackagesPackageNameResponse response from the API call
     */
    public CompletableFuture<OrgsPackagesPackageNameResponse> packagesGetPackageForOrganizationAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final String org) {
        try { 
            return preparePackagesGetPackageForOrganizationRequest(packageType, packageName,
            org).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesGetPackageForOrganization.
     */
    private ApiCall<OrgsPackagesPackageNameResponse, ApiException> preparePackagesGetPackageForOrganizationRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final String org) throws IOException {
        return new ApiCall.Builder<OrgsPackagesPackageNameResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/packages/{package_type}/{package_name}")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsPackagesPackageNameResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes an entire package in an organization. You cannot delete a public package if any
     * version of the package has more than 5,000 downloads. In this scenario, contact GitHub
     * support for further assistance. To use this endpoint, you must have admin permissions in the
     * organization and authenticate using an access token with the `read:packages` and
     * `delete:packages` scopes. In addition: - If the `package_type` belongs to a GitHub Packages
     * registry that only supports repository-scoped permissions, your token must also include the
     * `repo` scope. For the list of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package you want to delete. For the list
     * of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void packagesDeletePackageForOrg(
            final PackageType21Enum packageType,
            final String packageName,
            final String org) throws ApiException, IOException {
        preparePackagesDeletePackageForOrgRequest(packageType, packageName, org).execute();
    }

    /**
     * Deletes an entire package in an organization. You cannot delete a public package if any
     * version of the package has more than 5,000 downloads. In this scenario, contact GitHub
     * support for further assistance. To use this endpoint, you must have admin permissions in the
     * organization and authenticate using an access token with the `read:packages` and
     * `delete:packages` scopes. In addition: - If the `package_type` belongs to a GitHub Packages
     * registry that only supports repository-scoped permissions, your token must also include the
     * `repo` scope. For the list of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package you want to delete. For the list
     * of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> packagesDeletePackageForOrgAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final String org) {
        try { 
            return preparePackagesDeletePackageForOrgRequest(packageType, packageName, org).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesDeletePackageForOrg.
     */
    private ApiCall<Void, ApiException> preparePackagesDeletePackageForOrgRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final String org) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/packages/{package_type}/{package_name}")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new OrgsPackagesPackageName401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new OrgsPackagesPackageName403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsPackagesPackageName404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Restores an entire package in an organization. You can restore a deleted package under the
     * following conditions: - The package was deleted within the last 30 days. - The same package
     * namespace and version is still available and not reused for a new package. If the same
     * package namespace is not available, you will not be able to restore your package. In this
     * scenario, to restore the deleted package, you must delete the new package that uses the
     * deleted package's namespace first. To use this endpoint, you must have admin permissions in
     * the organization and authenticate using an access token with the `read:packages` and
     * `write:packages` scopes. In addition: - If the `package_type` belongs to a GitHub Packages
     * registry that only supports repository-scoped permissions, your token must also include the
     * `repo` scope. For the list of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package you want to restore. For the list
     * of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  token  Optional parameter: package token
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void packagesRestorePackageForOrg(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final String token) throws ApiException, IOException {
        preparePackagesRestorePackageForOrgRequest(packageType, packageName, org, token).execute();
    }

    /**
     * Restores an entire package in an organization. You can restore a deleted package under the
     * following conditions: - The package was deleted within the last 30 days. - The same package
     * namespace and version is still available and not reused for a new package. If the same
     * package namespace is not available, you will not be able to restore your package. In this
     * scenario, to restore the deleted package, you must delete the new package that uses the
     * deleted package's namespace first. To use this endpoint, you must have admin permissions in
     * the organization and authenticate using an access token with the `read:packages` and
     * `write:packages` scopes. In addition: - If the `package_type` belongs to a GitHub Packages
     * registry that only supports repository-scoped permissions, your token must also include the
     * `repo` scope. For the list of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package you want to restore. For the list
     * of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  token  Optional parameter: package token
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> packagesRestorePackageForOrgAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final String token) {
        try { 
            return preparePackagesRestorePackageForOrgRequest(packageType, packageName, org,
            token).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesRestorePackageForOrg.
     */
    private ApiCall<Void, ApiException> preparePackagesRestorePackageForOrgRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final String token) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/packages/{package_type}/{package_name}/restore")
                        .queryParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new OrgsPackagesPackageNameRestore401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new OrgsPackagesPackageNameRestore403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsPackagesPackageNameRestore404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists package versions for a package owned by an organization. If the `package_type` belongs
     * to a GitHub Packages registry that only supports repository-scoped permissions, your token
     * must also include the `repo` scope. For the list of GitHub Packages registries that only
     * support repository-scoped permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  state  Optional parameter: The state of the package, either active or deleted.
     * @return    Returns the List of PackageVersion response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<PackageVersion> packagesGetAllPackageVersionsForPackageOwnedByOrg(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final Integer page,
            final Integer perPage,
            final State63Enum state) throws ApiException, IOException {
        return preparePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest(packageType,
                packageName, org, page, perPage, state).execute();
    }

    /**
     * Lists package versions for a package owned by an organization. If the `package_type` belongs
     * to a GitHub Packages registry that only supports repository-scoped permissions, your token
     * must also include the `repo` scope. For the list of GitHub Packages registries that only
     * support repository-scoped permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  state  Optional parameter: The state of the package, either active or deleted.
     * @return    Returns the List of PackageVersion response from the API call
     */
    public CompletableFuture<List<PackageVersion>> packagesGetAllPackageVersionsForPackageOwnedByOrgAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final Integer page,
            final Integer perPage,
            final State63Enum state) {
        try { 
            return preparePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest(packageType, packageName,
            org, page, perPage, state).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesGetAllPackageVersionsForPackageOwnedByOrg.
     */
    private ApiCall<List<PackageVersion>, ApiException> preparePackagesGetAllPackageVersionsForPackageOwnedByOrgRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final Integer page,
            final Integer perPage,
            final State63Enum state) throws IOException {
        return new ApiCall.Builder<List<PackageVersion>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/packages/{package_type}/{package_name}/versions")
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("state")
                                .value((state != null) ? state.value() : null).isRequired(false))
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        PackageVersion[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new OrgsPackagesPackageNameVersions401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new OrgsPackagesPackageNameVersions403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsPackagesPackageNameVersions404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific package version in an organization. You must authenticate using an access
     * token with the `read:packages` scope. If the `package_type` belongs to a GitHub Packages
     * registry that only supports repository-scoped permissions, your token must also include the
     * `repo` scope. For the list of GitHub Packages registries that only support repository-scoped
     * permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @return    Returns the OrgsPackagesPackageNameVersionsPackageVersionIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsPackagesPackageNameVersionsPackageVersionIdResponse packagesGetPackageVersionForOrganization(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final int packageVersionId) throws ApiException, IOException {
        return preparePackagesGetPackageVersionForOrganizationRequest(packageType, packageName, org,
                packageVersionId).execute();
    }

    /**
     * Gets a specific package version in an organization. You must authenticate using an access
     * token with the `read:packages` scope. If the `package_type` belongs to a GitHub Packages
     * registry that only supports repository-scoped permissions, your token must also include the
     * `repo` scope. For the list of GitHub Packages registries that only support repository-scoped
     * permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @return    Returns the OrgsPackagesPackageNameVersionsPackageVersionIdResponse response from the API call
     */
    public CompletableFuture<OrgsPackagesPackageNameVersionsPackageVersionIdResponse> packagesGetPackageVersionForOrganizationAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final int packageVersionId) {
        try { 
            return preparePackagesGetPackageVersionForOrganizationRequest(packageType, packageName, org,
            packageVersionId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesGetPackageVersionForOrganization.
     */
    private ApiCall<OrgsPackagesPackageNameVersionsPackageVersionIdResponse, ApiException> preparePackagesGetPackageVersionForOrganizationRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final int packageVersionId) throws IOException {
        return new ApiCall.Builder<OrgsPackagesPackageNameVersionsPackageVersionIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_version_id").value(packageVersionId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsPackagesPackageNameVersionsPackageVersionIdResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a specific package version in an organization. If the package is public and the
     * package version has more than 5,000 downloads, you cannot delete the package version. In this
     * scenario, contact GitHub support for further assistance. To use this endpoint, you must have
     * admin permissions in the organization and authenticate using an access token with the
     * `read:packages` and `delete:packages` scopes. In addition: - If the `package_type` belongs to
     * a GitHub Packages registry that only supports repository-scoped permissions, your token must
     * also include the `repo` scope. For the list of these registries, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package whose version you want to delete.
     * For the list of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void packagesDeletePackageVersionForOrg(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final int packageVersionId) throws ApiException, IOException {
        preparePackagesDeletePackageVersionForOrgRequest(packageType, packageName, org,
                packageVersionId).execute();
    }

    /**
     * Deletes a specific package version in an organization. If the package is public and the
     * package version has more than 5,000 downloads, you cannot delete the package version. In this
     * scenario, contact GitHub support for further assistance. To use this endpoint, you must have
     * admin permissions in the organization and authenticate using an access token with the
     * `read:packages` and `delete:packages` scopes. In addition: - If the `package_type` belongs to
     * a GitHub Packages registry that only supports repository-scoped permissions, your token must
     * also include the `repo` scope. For the list of these registries, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package whose version you want to delete.
     * For the list of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> packagesDeletePackageVersionForOrgAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final int packageVersionId) {
        try { 
            return preparePackagesDeletePackageVersionForOrgRequest(packageType, packageName, org,
            packageVersionId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesDeletePackageVersionForOrg.
     */
    private ApiCall<Void, ApiException> preparePackagesDeletePackageVersionForOrgRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final int packageVersionId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_version_id").value(packageVersionId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new OrgsPackagesPackageNameVersionsPackageVersionId401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new OrgsPackagesPackageNameVersionsPackageVersionId403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsPackagesPackageNameVersionsPackageVersionId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Restores a specific package version in an organization. You can restore a deleted package
     * under the following conditions: - The package was deleted within the last 30 days. - The same
     * package namespace and version is still available and not reused for a new package. If the
     * same package namespace is not available, you will not be able to restore your package. In
     * this scenario, to restore the deleted package, you must delete the new package that uses the
     * deleted package's namespace first. To use this endpoint, you must have admin permissions in
     * the organization and authenticate using an access token with the `read:packages` and
     * `write:packages` scopes. In addition: - If the `package_type` belongs to a GitHub Packages
     * registry that only supports repository-scoped permissions, your token must also include the
     * `repo` scope. For the list of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package whose version you want to
     * restore. For the list of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void packagesRestorePackageVersionForOrg(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final int packageVersionId) throws ApiException, IOException {
        preparePackagesRestorePackageVersionForOrgRequest(packageType, packageName, org,
                packageVersionId).execute();
    }

    /**
     * Restores a specific package version in an organization. You can restore a deleted package
     * under the following conditions: - The package was deleted within the last 30 days. - The same
     * package namespace and version is still available and not reused for a new package. If the
     * same package namespace is not available, you will not be able to restore your package. In
     * this scenario, to restore the deleted package, you must delete the new package that uses the
     * deleted package's namespace first. To use this endpoint, you must have admin permissions in
     * the organization and authenticate using an access token with the `read:packages` and
     * `write:packages` scopes. In addition: - If the `package_type` belongs to a GitHub Packages
     * registry that only supports repository-scoped permissions, your token must also include the
     * `repo` scope. For the list of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package whose version you want to
     * restore. For the list of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> packagesRestorePackageVersionForOrgAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final int packageVersionId) {
        try { 
            return preparePackagesRestorePackageVersionForOrgRequest(packageType, packageName, org,
            packageVersionId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesRestorePackageVersionForOrg.
     */
    private ApiCall<Void, ApiException> preparePackagesRestorePackageVersionForOrgRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final String org,
            final int packageVersionId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_version_id").value(packageVersionId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new OrgsPackagesPackageNameVersionsPackageVersionIdRestore401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new OrgsPackagesPackageNameVersionsPackageVersionIdRestore403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsPackagesPackageNameVersionsPackageVersionIdRestore404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists packages owned by the authenticated user within the user's namespace. To use this
     * endpoint, you must authenticate using an access token with the `read:packages` scope. If the
     * `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of GitHub Packages
     * registries that only support repository-scoped permissions, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  visibility  Optional parameter: The selected visibility of the packages. This
     *         parameter is optional and only filters an existing result set. The `internal`
     *         visibility is only supported for GitHub Packages registries that allow for granular
     *         permissions. For other ecosystems `internal` is synonymous with `private`. For the
     *         list of GitHub Packages registries that support granular permissions, see "[About
     *         permissions for GitHub
     *         Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."
     * @return    Returns the List of Package response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Package> packagesListPackagesForAuthenticatedUser(
            final PackageType21Enum packageType,
            final Visibility636Enum visibility) throws ApiException, IOException {
        return preparePackagesListPackagesForAuthenticatedUserRequest(packageType,
                visibility).execute();
    }

    /**
     * Lists packages owned by the authenticated user within the user's namespace. To use this
     * endpoint, you must authenticate using an access token with the `read:packages` scope. If the
     * `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of GitHub Packages
     * registries that only support repository-scoped permissions, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  visibility  Optional parameter: The selected visibility of the packages. This
     *         parameter is optional and only filters an existing result set. The `internal`
     *         visibility is only supported for GitHub Packages registries that allow for granular
     *         permissions. For other ecosystems `internal` is synonymous with `private`. For the
     *         list of GitHub Packages registries that support granular permissions, see "[About
     *         permissions for GitHub
     *         Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."
     * @return    Returns the List of Package response from the API call
     */
    public CompletableFuture<List<Package>> packagesListPackagesForAuthenticatedUserAsync(
            final PackageType21Enum packageType,
            final Visibility636Enum visibility) {
        try { 
            return preparePackagesListPackagesForAuthenticatedUserRequest(packageType,
            visibility).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesListPackagesForAuthenticatedUser.
     */
    private ApiCall<List<Package>, ApiException> preparePackagesListPackagesForAuthenticatedUserRequest(
            final PackageType21Enum packageType,
            final Visibility636Enum visibility) throws IOException {
        return new ApiCall.Builder<List<Package>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/packages")
                        .queryParam(param -> param.key("package_type")
                                .value((packageType != null) ? packageType.value() : null))
                        .queryParam(param -> param.key("visibility")
                                .value((visibility != null) ? visibility.value() : null).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Package[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific package for a package owned by the authenticated user. To use this endpoint,
     * you must authenticate using an access token with the `read:packages` scope. If the
     * `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of GitHub Packages
     * registries that only support repository-scoped permissions, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @return    Returns the UserPackagesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserPackagesResponse packagesGetPackageForAuthenticatedUser(
            final PackageType21Enum packageType,
            final String packageName) throws ApiException, IOException {
        return preparePackagesGetPackageForAuthenticatedUserRequest(packageType,
                packageName).execute();
    }

    /**
     * Gets a specific package for a package owned by the authenticated user. To use this endpoint,
     * you must authenticate using an access token with the `read:packages` scope. If the
     * `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of GitHub Packages
     * registries that only support repository-scoped permissions, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @return    Returns the UserPackagesResponse response from the API call
     */
    public CompletableFuture<UserPackagesResponse> packagesGetPackageForAuthenticatedUserAsync(
            final PackageType21Enum packageType,
            final String packageName) {
        try { 
            return preparePackagesGetPackageForAuthenticatedUserRequest(packageType,
            packageName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesGetPackageForAuthenticatedUser.
     */
    private ApiCall<UserPackagesResponse, ApiException> preparePackagesGetPackageForAuthenticatedUserRequest(
            final PackageType21Enum packageType,
            final String packageName) throws IOException {
        return new ApiCall.Builder<UserPackagesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/packages/{package_type}/{package_name}")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserPackagesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a package owned by the authenticated user. You cannot delete a public package if any
     * version of the package has more than 5,000 downloads. In this scenario, contact GitHub
     * support for further assistance. To use this endpoint, you must authenticate using an access
     * token with the `read:packages` and `delete:packages` scopes. If the `package_type` belongs to
     * a GitHub Packages registry that only supports repository-scoped permissions, your token must
     * also include the `repo` scope. For the list of GitHub Packages registries that only support
     * repository-scoped permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void packagesDeletePackageForAuthenticatedUser(
            final PackageType21Enum packageType,
            final String packageName) throws ApiException, IOException {
        preparePackagesDeletePackageForAuthenticatedUserRequest(packageType, packageName).execute();
    }

    /**
     * Deletes a package owned by the authenticated user. You cannot delete a public package if any
     * version of the package has more than 5,000 downloads. In this scenario, contact GitHub
     * support for further assistance. To use this endpoint, you must authenticate using an access
     * token with the `read:packages` and `delete:packages` scopes. If the `package_type` belongs to
     * a GitHub Packages registry that only supports repository-scoped permissions, your token must
     * also include the `repo` scope. For the list of GitHub Packages registries that only support
     * repository-scoped permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> packagesDeletePackageForAuthenticatedUserAsync(
            final PackageType21Enum packageType,
            final String packageName) {
        try { 
            return preparePackagesDeletePackageForAuthenticatedUserRequest(packageType,
            packageName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesDeletePackageForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> preparePackagesDeletePackageForAuthenticatedUserRequest(
            final PackageType21Enum packageType,
            final String packageName) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/packages/{package_type}/{package_name}")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserPackages401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserPackages403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserPackages404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Restores a package owned by the authenticated user. You can restore a deleted package under
     * the following conditions: - The package was deleted within the last 30 days. - The same
     * package namespace and version is still available and not reused for a new package. If the
     * same package namespace is not available, you will not be able to restore your package. In
     * this scenario, to restore the deleted package, you must delete the new package that uses the
     * deleted package's namespace first. To use this endpoint, you must authenticate using an
     * access token with the `read:packages` and `write:packages` scopes. If the `package_type`
     * belongs to a GitHub Packages registry that only supports repository-scoped permissions, your
     * token must also include the `repo` scope. For the list of GitHub Packages registries that
     * only support repository-scoped permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  token  Optional parameter: package token
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void packagesRestorePackageForAuthenticatedUser(
            final PackageType21Enum packageType,
            final String packageName,
            final String token) throws ApiException, IOException {
        preparePackagesRestorePackageForAuthenticatedUserRequest(packageType, packageName,
                token).execute();
    }

    /**
     * Restores a package owned by the authenticated user. You can restore a deleted package under
     * the following conditions: - The package was deleted within the last 30 days. - The same
     * package namespace and version is still available and not reused for a new package. If the
     * same package namespace is not available, you will not be able to restore your package. In
     * this scenario, to restore the deleted package, you must delete the new package that uses the
     * deleted package's namespace first. To use this endpoint, you must authenticate using an
     * access token with the `read:packages` and `write:packages` scopes. If the `package_type`
     * belongs to a GitHub Packages registry that only supports repository-scoped permissions, your
     * token must also include the `repo` scope. For the list of GitHub Packages registries that
     * only support repository-scoped permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  token  Optional parameter: package token
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> packagesRestorePackageForAuthenticatedUserAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final String token) {
        try { 
            return preparePackagesRestorePackageForAuthenticatedUserRequest(packageType, packageName,
            token).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesRestorePackageForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> preparePackagesRestorePackageForAuthenticatedUserRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final String token) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/packages/{package_type}/{package_name}/restore")
                        .queryParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserPackagesRestore401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserPackagesRestore403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserPackagesRestore404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists package versions for a package owned by the authenticated user. To use this endpoint,
     * you must authenticate using an access token with the `read:packages` scope. If the
     * `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of GitHub Packages
     * registries that only support repository-scoped permissions, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  state  Optional parameter: The state of the package, either active or deleted.
     * @return    Returns the List of PackageVersion response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<PackageVersion> packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(
            final PackageType21Enum packageType,
            final String packageName,
            final Integer page,
            final Integer perPage,
            final State63Enum state) throws ApiException, IOException {
        return preparePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest(
                packageType, packageName, page, perPage, state).execute();
    }

    /**
     * Lists package versions for a package owned by the authenticated user. To use this endpoint,
     * you must authenticate using an access token with the `read:packages` scope. If the
     * `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of GitHub Packages
     * registries that only support repository-scoped permissions, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  state  Optional parameter: The state of the package, either active or deleted.
     * @return    Returns the List of PackageVersion response from the API call
     */
    public CompletableFuture<List<PackageVersion>> packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final Integer page,
            final Integer perPage,
            final State63Enum state) {
        try { 
            return preparePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest(
            packageType, packageName, page, perPage, state).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser.
     */
    private ApiCall<List<PackageVersion>, ApiException> preparePackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final Integer page,
            final Integer perPage,
            final State63Enum state) throws IOException {
        return new ApiCall.Builder<List<PackageVersion>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/packages/{package_type}/{package_name}/versions")
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("state")
                                .value((state != null) ? state.value() : null).isRequired(false))
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        PackageVersion[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserPackagesVersions401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserPackagesVersions403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserPackagesVersions404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific package version for a package owned by the authenticated user. To use this
     * endpoint, you must authenticate using an access token with the `read:packages` scope. If the
     * `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of GitHub Packages
     * registries that only support repository-scoped permissions, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @return    Returns the UserPackagesVersionsPackageVersionIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserPackagesVersionsPackageVersionIdResponse packagesGetPackageVersionForAuthenticatedUser(
            final PackageType21Enum packageType,
            final String packageName,
            final int packageVersionId) throws ApiException, IOException {
        return preparePackagesGetPackageVersionForAuthenticatedUserRequest(packageType, packageName,
                packageVersionId).execute();
    }

    /**
     * Gets a specific package version for a package owned by the authenticated user. To use this
     * endpoint, you must authenticate using an access token with the `read:packages` scope. If the
     * `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of GitHub Packages
     * registries that only support repository-scoped permissions, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @return    Returns the UserPackagesVersionsPackageVersionIdResponse response from the API call
     */
    public CompletableFuture<UserPackagesVersionsPackageVersionIdResponse> packagesGetPackageVersionForAuthenticatedUserAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final int packageVersionId) {
        try { 
            return preparePackagesGetPackageVersionForAuthenticatedUserRequest(packageType, packageName,
            packageVersionId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesGetPackageVersionForAuthenticatedUser.
     */
    private ApiCall<UserPackagesVersionsPackageVersionIdResponse, ApiException> preparePackagesGetPackageVersionForAuthenticatedUserRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final int packageVersionId) throws IOException {
        return new ApiCall.Builder<UserPackagesVersionsPackageVersionIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/packages/{package_type}/{package_name}/versions/{package_version_id}")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_version_id").value(packageVersionId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserPackagesVersionsPackageVersionIdResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a specific package version for a package owned by the authenticated user. If the
     * package is public and the package version has more than 5,000 downloads, you cannot delete
     * the package version. In this scenario, contact GitHub support for further assistance. To use
     * this endpoint, you must have admin permissions in the organization and authenticate using an
     * access token with the `read:packages` and `delete:packages` scopes. If the `package_type`
     * belongs to a GitHub Packages registry that only supports repository-scoped permissions, your
     * token must also include the `repo` scope. For the list of GitHub Packages registries that
     * only support repository-scoped permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void packagesDeletePackageVersionForAuthenticatedUser(
            final PackageType21Enum packageType,
            final String packageName,
            final int packageVersionId) throws ApiException, IOException {
        preparePackagesDeletePackageVersionForAuthenticatedUserRequest(packageType, packageName,
                packageVersionId).execute();
    }

    /**
     * Deletes a specific package version for a package owned by the authenticated user. If the
     * package is public and the package version has more than 5,000 downloads, you cannot delete
     * the package version. In this scenario, contact GitHub support for further assistance. To use
     * this endpoint, you must have admin permissions in the organization and authenticate using an
     * access token with the `read:packages` and `delete:packages` scopes. If the `package_type`
     * belongs to a GitHub Packages registry that only supports repository-scoped permissions, your
     * token must also include the `repo` scope. For the list of GitHub Packages registries that
     * only support repository-scoped permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> packagesDeletePackageVersionForAuthenticatedUserAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final int packageVersionId) {
        try { 
            return preparePackagesDeletePackageVersionForAuthenticatedUserRequest(packageType, packageName,
            packageVersionId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesDeletePackageVersionForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> preparePackagesDeletePackageVersionForAuthenticatedUserRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final int packageVersionId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/packages/{package_type}/{package_name}/versions/{package_version_id}")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_version_id").value(packageVersionId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserPackagesVersionsPackageVersionId401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserPackagesVersionsPackageVersionId403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserPackagesVersionsPackageVersionId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Restores a package version owned by the authenticated user. You can restore a deleted package
     * version under the following conditions: - The package was deleted within the last 30 days. -
     * The same package namespace and version is still available and not reused for a new package.
     * If the same package namespace is not available, you will not be able to restore your package.
     * In this scenario, to restore the deleted package, you must delete the new package that uses
     * the deleted package's namespace first. To use this endpoint, you must authenticate using an
     * access token with the `read:packages` and `write:packages` scopes. If the `package_type`
     * belongs to a GitHub Packages registry that only supports repository-scoped permissions, your
     * token must also include the `repo` scope. For the list of GitHub Packages registries that
     * only support repository-scoped permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void packagesRestorePackageVersionForAuthenticatedUser(
            final PackageType21Enum packageType,
            final String packageName,
            final int packageVersionId) throws ApiException, IOException {
        preparePackagesRestorePackageVersionForAuthenticatedUserRequest(packageType, packageName,
                packageVersionId).execute();
    }

    /**
     * Restores a package version owned by the authenticated user. You can restore a deleted package
     * version under the following conditions: - The package was deleted within the last 30 days. -
     * The same package namespace and version is still available and not reused for a new package.
     * If the same package namespace is not available, you will not be able to restore your package.
     * In this scenario, to restore the deleted package, you must delete the new package that uses
     * the deleted package's namespace first. To use this endpoint, you must authenticate using an
     * access token with the `read:packages` and `write:packages` scopes. If the `package_type`
     * belongs to a GitHub Packages registry that only supports repository-scoped permissions, your
     * token must also include the `repo` scope. For the list of GitHub Packages registries that
     * only support repository-scoped permissions, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> packagesRestorePackageVersionForAuthenticatedUserAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final int packageVersionId) {
        try { 
            return preparePackagesRestorePackageVersionForAuthenticatedUserRequest(packageType, packageName,
            packageVersionId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesRestorePackageVersionForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> preparePackagesRestorePackageVersionForAuthenticatedUserRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final int packageVersionId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_version_id").value(packageVersionId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserPackagesVersionsPackageVersionIdRestore401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserPackagesVersionsPackageVersionIdRestore403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserPackagesVersionsPackageVersionIdRestore404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all packages in a user's namespace for which the requesting user has access. To use
     * this endpoint, you must authenticate using an access token with the `read:packages` scope. If
     * the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of GitHub Packages
     * registries that only support repository-scoped permissions, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  visibility  Optional parameter: The selected visibility of the packages. This
     *         parameter is optional and only filters an existing result set. The `internal`
     *         visibility is only supported for GitHub Packages registries that allow for granular
     *         permissions. For other ecosystems `internal` is synonymous with `private`. For the
     *         list of GitHub Packages registries that support granular permissions, see "[About
     *         permissions for GitHub
     *         Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."
     * @return    Returns the List of Package response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Package> packagesListPackagesForUser(
            final PackageType21Enum packageType,
            final String username,
            final Visibility636Enum visibility) throws ApiException, IOException {
        return preparePackagesListPackagesForUserRequest(packageType, username,
                visibility).execute();
    }

    /**
     * Lists all packages in a user's namespace for which the requesting user has access. To use
     * this endpoint, you must authenticate using an access token with the `read:packages` scope. If
     * the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of GitHub Packages
     * registries that only support repository-scoped permissions, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  visibility  Optional parameter: The selected visibility of the packages. This
     *         parameter is optional and only filters an existing result set. The `internal`
     *         visibility is only supported for GitHub Packages registries that allow for granular
     *         permissions. For other ecosystems `internal` is synonymous with `private`. For the
     *         list of GitHub Packages registries that support granular permissions, see "[About
     *         permissions for GitHub
     *         Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages)."
     * @return    Returns the List of Package response from the API call
     */
    public CompletableFuture<List<Package>> packagesListPackagesForUserAsync(
            final PackageType21Enum packageType,
            final String username,
            final Visibility636Enum visibility) {
        try { 
            return preparePackagesListPackagesForUserRequest(packageType, username,
            visibility).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesListPackagesForUser.
     */
    private ApiCall<List<Package>, ApiException> preparePackagesListPackagesForUserRequest(
            final PackageType21Enum packageType,
            final String username,
            final Visibility636Enum visibility) throws IOException {
        return new ApiCall.Builder<List<Package>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/packages")
                        .queryParam(param -> param.key("package_type")
                                .value((packageType != null) ? packageType.value() : null))
                        .queryParam(param -> param.key("visibility")
                                .value((visibility != null) ? visibility.value() : null).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Package[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UsersPackages401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UsersPackages403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific package metadata for a public package owned by a user. To use this endpoint,
     * you must authenticate using an access token with the `read:packages` scope. If the
     * `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of GitHub Packages
     * registries that only support repository-scoped permissions, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the UsersPackagesPackageNameResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UsersPackagesPackageNameResponse packagesGetPackageForUser(
            final PackageType21Enum packageType,
            final String packageName,
            final String username) throws ApiException, IOException {
        return preparePackagesGetPackageForUserRequest(packageType, packageName,
                username).execute();
    }

    /**
     * Gets a specific package metadata for a public package owned by a user. To use this endpoint,
     * you must authenticate using an access token with the `read:packages` scope. If the
     * `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of GitHub Packages
     * registries that only support repository-scoped permissions, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the UsersPackagesPackageNameResponse response from the API call
     */
    public CompletableFuture<UsersPackagesPackageNameResponse> packagesGetPackageForUserAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final String username) {
        try { 
            return preparePackagesGetPackageForUserRequest(packageType, packageName,
            username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesGetPackageForUser.
     */
    private ApiCall<UsersPackagesPackageNameResponse, ApiException> preparePackagesGetPackageForUserRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final String username) throws IOException {
        return new ApiCall.Builder<UsersPackagesPackageNameResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/packages/{package_type}/{package_name}")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UsersPackagesPackageNameResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes an entire package for a user. You cannot delete a public package if any version of
     * the package has more than 5,000 downloads. In this scenario, contact GitHub support for
     * further assistance. To use this endpoint, you must authenticate using an access token with
     * the `read:packages` and `delete:packages` scopes. In addition: - If the `package_type`
     * belongs to a GitHub Packages registry that only supports repository-scoped permissions, your
     * token must also include the `repo` scope. For the list of these registries, see "[About
     * permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package you want to delete. For the list
     * of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void packagesDeletePackageForUser(
            final PackageType21Enum packageType,
            final String packageName,
            final String username) throws ApiException, IOException {
        preparePackagesDeletePackageForUserRequest(packageType, packageName, username).execute();
    }

    /**
     * Deletes an entire package for a user. You cannot delete a public package if any version of
     * the package has more than 5,000 downloads. In this scenario, contact GitHub support for
     * further assistance. To use this endpoint, you must authenticate using an access token with
     * the `read:packages` and `delete:packages` scopes. In addition: - If the `package_type`
     * belongs to a GitHub Packages registry that only supports repository-scoped permissions, your
     * token must also include the `repo` scope. For the list of these registries, see "[About
     * permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package you want to delete. For the list
     * of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> packagesDeletePackageForUserAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final String username) {
        try { 
            return preparePackagesDeletePackageForUserRequest(packageType, packageName,
            username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesDeletePackageForUser.
     */
    private ApiCall<Void, ApiException> preparePackagesDeletePackageForUserRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final String username) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/packages/{package_type}/{package_name}")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UsersPackagesPackageName401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UsersPackagesPackageName403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UsersPackagesPackageName404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Restores an entire package for a user. You can restore a deleted package under the following
     * conditions: - The package was deleted within the last 30 days. - The same package namespace
     * and version is still available and not reused for a new package. If the same package
     * namespace is not available, you will not be able to restore your package. In this scenario,
     * to restore the deleted package, you must delete the new package that uses the deleted
     * package's namespace first. To use this endpoint, you must authenticate using an access token
     * with the `read:packages` and `write:packages` scopes. In addition: - If the `package_type`
     * belongs to a GitHub Packages registry that only supports repository-scoped permissions, your
     * token must also include the `repo` scope. For the list of these registries, see "[About
     * permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package you want to restore. For the list
     * of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  token  Optional parameter: package token
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void packagesRestorePackageForUser(
            final PackageType21Enum packageType,
            final String packageName,
            final String username,
            final String token) throws ApiException, IOException {
        preparePackagesRestorePackageForUserRequest(packageType, packageName, username,
                token).execute();
    }

    /**
     * Restores an entire package for a user. You can restore a deleted package under the following
     * conditions: - The package was deleted within the last 30 days. - The same package namespace
     * and version is still available and not reused for a new package. If the same package
     * namespace is not available, you will not be able to restore your package. In this scenario,
     * to restore the deleted package, you must delete the new package that uses the deleted
     * package's namespace first. To use this endpoint, you must authenticate using an access token
     * with the `read:packages` and `write:packages` scopes. In addition: - If the `package_type`
     * belongs to a GitHub Packages registry that only supports repository-scoped permissions, your
     * token must also include the `repo` scope. For the list of these registries, see "[About
     * permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package you want to restore. For the list
     * of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  token  Optional parameter: package token
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> packagesRestorePackageForUserAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final String username,
            final String token) {
        try { 
            return preparePackagesRestorePackageForUserRequest(packageType, packageName, username,
            token).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesRestorePackageForUser.
     */
    private ApiCall<Void, ApiException> preparePackagesRestorePackageForUserRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final String username,
            final String token) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/packages/{package_type}/{package_name}/restore")
                        .queryParam(param -> param.key("token")
                                .value(token).isRequired(false))
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UsersPackagesPackageNameRestore401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UsersPackagesPackageNameRestore403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UsersPackagesPackageNameRestore404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists package versions for a public package owned by a specified user. To use this endpoint,
     * you must authenticate using an access token with the `read:packages` scope. If the
     * `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of GitHub Packages
     * registries that only support repository-scoped permissions, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the List of PackageVersion response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<PackageVersion> packagesGetAllPackageVersionsForPackageOwnedByUser(
            final PackageType21Enum packageType,
            final String packageName,
            final String username) throws ApiException, IOException {
        return preparePackagesGetAllPackageVersionsForPackageOwnedByUserRequest(packageType,
                packageName, username).execute();
    }

    /**
     * Lists package versions for a public package owned by a specified user. To use this endpoint,
     * you must authenticate using an access token with the `read:packages` scope. If the
     * `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of GitHub Packages
     * registries that only support repository-scoped permissions, see "[About permissions for
     * GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the List of PackageVersion response from the API call
     */
    public CompletableFuture<List<PackageVersion>> packagesGetAllPackageVersionsForPackageOwnedByUserAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final String username) {
        try { 
            return preparePackagesGetAllPackageVersionsForPackageOwnedByUserRequest(packageType,
            packageName, username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesGetAllPackageVersionsForPackageOwnedByUser.
     */
    private ApiCall<List<PackageVersion>, ApiException> preparePackagesGetAllPackageVersionsForPackageOwnedByUserRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final String username) throws IOException {
        return new ApiCall.Builder<List<PackageVersion>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/packages/{package_type}/{package_name}/versions")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        PackageVersion[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UsersPackagesPackageNameVersions401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UsersPackagesPackageNameVersions403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UsersPackagesPackageNameVersions404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific package version for a public package owned by a specified user. At this time,
     * to use this endpoint, you must authenticate using an access token with the `read:packages`
     * scope. If the `package_type` belongs to a GitHub Packages registry that only supports
     * repository-scoped permissions, your token must also include the `repo` scope. For the list of
     * GitHub Packages registries that only support repository-scoped permissions, see "[About
     * permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the UsersPackagesPackageNameVersionsPackageVersionIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UsersPackagesPackageNameVersionsPackageVersionIdResponse packagesGetPackageVersionForUser(
            final PackageType21Enum packageType,
            final String packageName,
            final int packageVersionId,
            final String username) throws ApiException, IOException {
        return preparePackagesGetPackageVersionForUserRequest(packageType, packageName,
                packageVersionId, username).execute();
    }

    /**
     * Gets a specific package version for a public package owned by a specified user. At this time,
     * to use this endpoint, you must authenticate using an access token with the `read:packages`
     * scope. If the `package_type` belongs to a GitHub Packages registry that only supports
     * repository-scoped permissions, your token must also include the `repo` scope. For the list of
     * GitHub Packages registries that only support repository-scoped permissions, see "[About
     * permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the UsersPackagesPackageNameVersionsPackageVersionIdResponse response from the API call
     */
    public CompletableFuture<UsersPackagesPackageNameVersionsPackageVersionIdResponse> packagesGetPackageVersionForUserAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final int packageVersionId,
            final String username) {
        try { 
            return preparePackagesGetPackageVersionForUserRequest(packageType, packageName,
            packageVersionId, username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesGetPackageVersionForUser.
     */
    private ApiCall<UsersPackagesPackageNameVersionsPackageVersionIdResponse, ApiException> preparePackagesGetPackageVersionForUserRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final int packageVersionId,
            final String username) throws IOException {
        return new ApiCall.Builder<UsersPackagesPackageNameVersionsPackageVersionIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_version_id").value(packageVersionId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UsersPackagesPackageNameVersionsPackageVersionIdResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a specific package version for a user. If the package is public and the package
     * version has more than 5,000 downloads, you cannot delete the package version. In this
     * scenario, contact GitHub support for further assistance. To use this endpoint, you must
     * authenticate using an access token with the `read:packages` and `delete:packages` scopes. In
     * addition: - If the `package_type` belongs to a GitHub Packages registry that only supports
     * repository-scoped permissions, your token must also include the `repo` scope. For the list of
     * these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package whose version you want to delete.
     * For the list of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void packagesDeletePackageVersionForUser(
            final PackageType21Enum packageType,
            final String packageName,
            final String username,
            final int packageVersionId) throws ApiException, IOException {
        preparePackagesDeletePackageVersionForUserRequest(packageType, packageName, username,
                packageVersionId).execute();
    }

    /**
     * Deletes a specific package version for a user. If the package is public and the package
     * version has more than 5,000 downloads, you cannot delete the package version. In this
     * scenario, contact GitHub support for further assistance. To use this endpoint, you must
     * authenticate using an access token with the `read:packages` and `delete:packages` scopes. In
     * addition: - If the `package_type` belongs to a GitHub Packages registry that only supports
     * repository-scoped permissions, your token must also include the `repo` scope. For the list of
     * these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package whose version you want to delete.
     * For the list of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> packagesDeletePackageVersionForUserAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final String username,
            final int packageVersionId) {
        try { 
            return preparePackagesDeletePackageVersionForUserRequest(packageType, packageName, username,
            packageVersionId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesDeletePackageVersionForUser.
     */
    private ApiCall<Void, ApiException> preparePackagesDeletePackageVersionForUserRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final String username,
            final int packageVersionId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_version_id").value(packageVersionId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UsersPackagesPackageNameVersionsPackageVersionId401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UsersPackagesPackageNameVersionsPackageVersionId403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UsersPackagesPackageNameVersionsPackageVersionId404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Restores a specific package version for a user. You can restore a deleted package under the
     * following conditions: - The package was deleted within the last 30 days. - The same package
     * namespace and version is still available and not reused for a new package. If the same
     * package namespace is not available, you will not be able to restore your package. In this
     * scenario, to restore the deleted package, you must delete the new package that uses the
     * deleted package's namespace first. To use this endpoint, you must authenticate using an
     * access token with the `read:packages` and `write:packages` scopes. In addition: - If the
     * `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of these registries,
     * see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package whose version you want to
     * restore. For the list of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void packagesRestorePackageVersionForUser(
            final PackageType21Enum packageType,
            final String packageName,
            final String username,
            final int packageVersionId) throws ApiException, IOException {
        preparePackagesRestorePackageVersionForUserRequest(packageType, packageName, username,
                packageVersionId).execute();
    }

    /**
     * Restores a specific package version for a user. You can restore a deleted package under the
     * following conditions: - The package was deleted within the last 30 days. - The same package
     * namespace and version is still available and not reused for a new package. If the same
     * package namespace is not available, you will not be able to restore your package. In this
     * scenario, to restore the deleted package, you must delete the new package that uses the
     * deleted package's namespace first. To use this endpoint, you must authenticate using an
     * access token with the `read:packages` and `write:packages` scopes. In addition: - If the
     * `package_type` belongs to a GitHub Packages registry that only supports repository-scoped
     * permissions, your token must also include the `repo` scope. For the list of these registries,
     * see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
     * - If the `package_type` belongs to a GitHub Packages registry that supports granular
     * permissions, you must have admin permissions to the package whose version you want to
     * restore. For the list of these registries, see "[About permissions for GitHub
     * Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#granular-permissions-for-userorganization-scoped-packages).".
     * @param  packageType  Required parameter: The type of supported package. Packages in GitHub's
     *         Gradle registry have the type `maven`. Docker images pushed to GitHub's Container
     *         registry (`ghcr.io`) have the type `container`. You can use the type `docker` to find
     *         images that were pushed to GitHub's Docker registry (`docker.pkg.github.com`), even
     *         if these have now been migrated to the Container registry.
     * @param  packageName  Required parameter: The name of the package.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  packageVersionId  Required parameter: Unique identifier of the package version.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> packagesRestorePackageVersionForUserAsync(
            final PackageType21Enum packageType,
            final String packageName,
            final String username,
            final int packageVersionId) {
        try { 
            return preparePackagesRestorePackageVersionForUserRequest(packageType, packageName, username,
            packageVersionId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for packagesRestorePackageVersionForUser.
     */
    private ApiCall<Void, ApiException> preparePackagesRestorePackageVersionForUserRequest(
            final PackageType21Enum packageType,
            final String packageName,
            final String username,
            final int packageVersionId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore")
                        .templateParam(param -> param.key("package_type").value((packageType != null) ? packageType.value() : null)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_name").value(packageName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("package_version_id").value(packageVersionId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UsersPackagesPackageNameVersionsPackageVersionIdRestore401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UsersPackagesPackageNameVersionsPackageVersionIdRestore403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UsersPackagesPackageNameVersionsPackageVersionIdRestore404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}