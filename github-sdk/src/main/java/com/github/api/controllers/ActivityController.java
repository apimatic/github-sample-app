/*
 * GitHubAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.github.api.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.github.api.ApiHelper;
import com.github.api.DateTimeHelper;
import com.github.api.Server;
import com.github.api.exceptions.ApiException;
import com.github.api.exceptions.Events403ErrorException;
import com.github.api.exceptions.NetworksEvents403ErrorException;
import com.github.api.exceptions.NetworksEvents404ErrorException;
import com.github.api.exceptions.Notifications401ErrorException;
import com.github.api.exceptions.Notifications403ErrorException;
import com.github.api.exceptions.Notifications422ErrorException;
import com.github.api.exceptions.NotificationsThreads401ErrorException;
import com.github.api.exceptions.NotificationsThreads403ErrorException;
import com.github.api.exceptions.NotificationsThreadsSubscription401ErrorException;
import com.github.api.exceptions.NotificationsThreadsSubscription403ErrorException;
import com.github.api.exceptions.ReposStargazers422ErrorException;
import com.github.api.exceptions.ReposSubscription403ErrorException;
import com.github.api.exceptions.ServiceUnavailable1Exception;
import com.github.api.exceptions.UserStarred401ErrorException;
import com.github.api.exceptions.UserStarred403ErrorException;
import com.github.api.exceptions.UserStarred404ErrorException;
import com.github.api.exceptions.UserSubscriptions401ErrorException;
import com.github.api.exceptions.UserSubscriptions403ErrorException;
import com.github.api.http.request.HttpMethod;
import com.github.api.models.Direction1Enum;
import com.github.api.models.Event;
import com.github.api.models.FeedsResponse;
import com.github.api.models.MinimalRepository;
import com.github.api.models.NotificationsRequest;
import com.github.api.models.NotificationsResponse;
import com.github.api.models.NotificationsThreadsResponse;
import com.github.api.models.NotificationsThreadsSubscriptionRequest;
import com.github.api.models.NotificationsThreadsSubscriptionResponse;
import com.github.api.models.ReposNotificationsRequest;
import com.github.api.models.ReposNotificationsResponse;
import com.github.api.models.ReposSubscriptionRequest;
import com.github.api.models.ReposSubscriptionResponse;
import com.github.api.models.Repository;
import com.github.api.models.SimpleUser;
import com.github.api.models.Sort1Enum;
import com.github.api.models.Thread;
import com.github.api.models.containers.ActivityListReposStarredByUserResponse;
import com.github.api.models.containers.ActivityListStargazersForRepoResponse;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class ActivityController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public ActivityController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * We delay the public events feed by five minutes, which means the most recent event returned
     * by the public events API actually occurred at least five minutes ago.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Event> activityListPublicEvents(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListPublicEventsRequest(perPage, page).execute();
    }

    /**
     * We delay the public events feed by five minutes, which means the most recent event returned
     * by the public events API actually occurred at least five minutes ago.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     */
    public CompletableFuture<List<Event>> activityListPublicEventsAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListPublicEventsRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListPublicEvents.
     */
    private ApiCall<List<Event>, ApiException> prepareActivityListPublicEventsRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Event>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/events")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Event[].class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new Events403ErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.create("Service unavailable",
                                (reason, context) -> new ServiceUnavailable1Exception(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * GitHub provides several timeline resources in
     * [Atom](http://en.wikipedia.org/wiki/Atom_(standard)) format. The Feeds API lists all the
     * feeds available to the authenticated user: * **Timeline**: The GitHub global public timeline
     * * **User**: The public timeline for any user, using [URI
     * template](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia) *
     * **Current user public**: The public timeline for the authenticated user * **Current user**:
     * The private timeline for the authenticated user * **Current user actor**: The private
     * timeline for activity created by the authenticated user * **Current user organizations**: The
     * private timeline for the organizations the authenticated user is a member of. * **Security
     * advisories**: A collection of public announcements that provide information about
     * security-related vulnerabilities in software on GitHub. **Note**: Private feeds are only
     * returned when [authenticating via Basic
     * Auth](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * since current feed URIs use the older, non revocable auth tokens.
     * @return    Returns the FeedsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public FeedsResponse activityGetFeeds() throws ApiException, IOException {
        return prepareActivityGetFeedsRequest().execute();
    }

    /**
     * GitHub provides several timeline resources in
     * [Atom](http://en.wikipedia.org/wiki/Atom_(standard)) format. The Feeds API lists all the
     * feeds available to the authenticated user: * **Timeline**: The GitHub global public timeline
     * * **User**: The public timeline for any user, using [URI
     * template](https://docs.github.com/rest/overview/resources-in-the-rest-api#hypermedia) *
     * **Current user public**: The public timeline for the authenticated user * **Current user**:
     * The private timeline for the authenticated user * **Current user actor**: The private
     * timeline for activity created by the authenticated user * **Current user organizations**: The
     * private timeline for the organizations the authenticated user is a member of. * **Security
     * advisories**: A collection of public announcements that provide information about
     * security-related vulnerabilities in software on GitHub. **Note**: Private feeds are only
     * returned when [authenticating via Basic
     * Auth](https://docs.github.com/rest/overview/other-authentication-methods#basic-authentication)
     * since current feed URIs use the older, non revocable auth tokens.
     * @return    Returns the FeedsResponse response from the API call
     */
    public CompletableFuture<FeedsResponse> activityGetFeedsAsync() {
        try { 
            return prepareActivityGetFeedsRequest().executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityGetFeeds.
     */
    private ApiCall<FeedsResponse, ApiException> prepareActivityGetFeedsRequest() throws IOException {
        return new ApiCall.Builder<FeedsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/feeds")
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, FeedsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List public events for a network of repositories.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Event> activityListPublicEventsForRepoNetwork(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListPublicEventsForRepoNetworkRequest(owner, repo, perPage,
                page).execute();
    }

    /**
     * List public events for a network of repositories.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     */
    public CompletableFuture<List<Event>> activityListPublicEventsForRepoNetworkAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListPublicEventsForRepoNetworkRequest(owner, repo, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListPublicEventsForRepoNetwork.
     */
    private ApiCall<List<Event>, ApiException> prepareActivityListPublicEventsForRepoNetworkRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Event>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/networks/{owner}/{repo}/events")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Event[].class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new NetworksEvents403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new NetworksEvents404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List all notifications for the current user, sorted by most recently updated.
     * @param  all  Optional parameter: If `true`, show notifications marked as read.
     * @param  participating  Optional parameter: If `true`, only shows notifications in which the
     *         user is directly participating or mentioned.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  before  Optional parameter: Only show notifications updated before the given time.
     *         This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 50).
     * @return    Returns the List of Thread response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Thread> activityListNotificationsForAuthenticatedUser(
            final Boolean all,
            final Boolean participating,
            final LocalDateTime since,
            final LocalDateTime before,
            final Integer page,
            final Integer perPage) throws ApiException, IOException {
        return prepareActivityListNotificationsForAuthenticatedUserRequest(all, participating,
                since, before, page, perPage).execute();
    }

    /**
     * List all notifications for the current user, sorted by most recently updated.
     * @param  all  Optional parameter: If `true`, show notifications marked as read.
     * @param  participating  Optional parameter: If `true`, only shows notifications in which the
     *         user is directly participating or mentioned.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  before  Optional parameter: Only show notifications updated before the given time.
     *         This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 50).
     * @return    Returns the List of Thread response from the API call
     */
    public CompletableFuture<List<Thread>> activityListNotificationsForAuthenticatedUserAsync(
            final Boolean all,
            final Boolean participating,
            final LocalDateTime since,
            final LocalDateTime before,
            final Integer page,
            final Integer perPage) {
        try { 
            return prepareActivityListNotificationsForAuthenticatedUserRequest(all, participating, since,
            before, page, perPage).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListNotificationsForAuthenticatedUser.
     */
    private ApiCall<List<Thread>, ApiException> prepareActivityListNotificationsForAuthenticatedUserRequest(
            final Boolean all,
            final Boolean participating,
            final LocalDateTime since,
            final LocalDateTime before,
            final Integer page,
            final Integer perPage) throws IOException {
        return new ApiCall.Builder<List<Thread>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/notifications")
                        .queryParam(param -> param.key("all")
                                .value((all != null) ? all : false).isRequired(false))
                        .queryParam(param -> param.key("participating")
                                .value((participating != null) ? participating : false).isRequired(false))
                        .queryParam(param -> param.key("since")
                                .value(DateTimeHelper.toRfc8601DateTime(since)).isRequired(false))
                        .queryParam(param -> param.key("before")
                                .value(DateTimeHelper.toRfc8601DateTime(before)).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 50).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Thread[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new Notifications401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new Notifications403ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new Notifications422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Marks all notifications as "read" for the current user. If the number of notifications is too
     * large to complete in one request, you will receive a `202 Accepted` status and GitHub will
     * run an asynchronous process to mark notifications as "read." To check whether any "unread"
     * notifications remain, you can use the [List notifications for the authenticated
     * user](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)
     * endpoint and pass the query parameter `all=false`.
     * @param  body  Optional parameter: Example:
     * @return    Returns the NotificationsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public NotificationsResponse activityMarkNotificationsAsRead(
            final NotificationsRequest body) throws ApiException, IOException {
        return prepareActivityMarkNotificationsAsReadRequest(body).execute();
    }

    /**
     * Marks all notifications as "read" for the current user. If the number of notifications is too
     * large to complete in one request, you will receive a `202 Accepted` status and GitHub will
     * run an asynchronous process to mark notifications as "read." To check whether any "unread"
     * notifications remain, you can use the [List notifications for the authenticated
     * user](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)
     * endpoint and pass the query parameter `all=false`.
     * @param  body  Optional parameter: Example:
     * @return    Returns the NotificationsResponse response from the API call
     */
    public CompletableFuture<NotificationsResponse> activityMarkNotificationsAsReadAsync(
            final NotificationsRequest body) {
        try { 
            return prepareActivityMarkNotificationsAsReadRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityMarkNotificationsAsRead.
     */
    private ApiCall<NotificationsResponse, ApiException> prepareActivityMarkNotificationsAsReadRequest(
            final NotificationsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<NotificationsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/notifications")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, NotificationsResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new Notifications401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new Notifications403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets information about a notification thread.
     * @param  threadId  Required parameter: The unique identifier of the notification thread. This
     *         corresponds to the value returned in the `id` field when you retrieve notifications
     *         (for example with the [`GET /notifications`
     *         operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).
     * @return    Returns the NotificationsThreadsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public NotificationsThreadsResponse activityGetThread(
            final int threadId) throws ApiException, IOException {
        return prepareActivityGetThreadRequest(threadId).execute();
    }

    /**
     * Gets information about a notification thread.
     * @param  threadId  Required parameter: The unique identifier of the notification thread. This
     *         corresponds to the value returned in the `id` field when you retrieve notifications
     *         (for example with the [`GET /notifications`
     *         operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).
     * @return    Returns the NotificationsThreadsResponse response from the API call
     */
    public CompletableFuture<NotificationsThreadsResponse> activityGetThreadAsync(
            final int threadId) {
        try { 
            return prepareActivityGetThreadRequest(threadId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityGetThread.
     */
    private ApiCall<NotificationsThreadsResponse, ApiException> prepareActivityGetThreadRequest(
            final int threadId) throws IOException {
        return new ApiCall.Builder<NotificationsThreadsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/notifications/threads/{thread_id}")
                        .templateParam(param -> param.key("thread_id").value(threadId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, NotificationsThreadsResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new NotificationsThreads401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new NotificationsThreads403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Marks a thread as "read." Marking a thread as "read" is equivalent to clicking a notification
     * in your notification inbox on GitHub: https://github.com/notifications.
     * @param  threadId  Required parameter: The unique identifier of the notification thread. This
     *         corresponds to the value returned in the `id` field when you retrieve notifications
     *         (for example with the [`GET /notifications`
     *         operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void activityMarkThreadAsRead(
            final int threadId) throws ApiException, IOException {
        prepareActivityMarkThreadAsReadRequest(threadId).execute();
    }

    /**
     * Marks a thread as "read." Marking a thread as "read" is equivalent to clicking a notification
     * in your notification inbox on GitHub: https://github.com/notifications.
     * @param  threadId  Required parameter: The unique identifier of the notification thread. This
     *         corresponds to the value returned in the `id` field when you retrieve notifications
     *         (for example with the [`GET /notifications`
     *         operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> activityMarkThreadAsReadAsync(
            final int threadId) {
        try { 
            return prepareActivityMarkThreadAsReadRequest(threadId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityMarkThreadAsRead.
     */
    private ApiCall<Void, ApiException> prepareActivityMarkThreadAsReadRequest(
            final int threadId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/notifications/threads/{thread_id}")
                        .templateParam(param -> param.key("thread_id").value(threadId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new NotificationsThreads403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This checks to see if the current user is subscribed to a thread. You can also [get a
     * repository
     * subscription](https://docs.github.com/rest/reference/activity#get-a-repository-subscription).
     * Note that subscriptions are only generated if a user is participating in a conversation--for
     * example, they've replied to the thread, were **@mentioned**, or manually subscribe to a
     * thread.
     * @param  threadId  Required parameter: The unique identifier of the notification thread. This
     *         corresponds to the value returned in the `id` field when you retrieve notifications
     *         (for example with the [`GET /notifications`
     *         operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).
     * @return    Returns the NotificationsThreadsSubscriptionResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public NotificationsThreadsSubscriptionResponse activityGetThreadSubscriptionForAuthenticatedUser(
            final int threadId) throws ApiException, IOException {
        return prepareActivityGetThreadSubscriptionForAuthenticatedUserRequest(threadId).execute();
    }

    /**
     * This checks to see if the current user is subscribed to a thread. You can also [get a
     * repository
     * subscription](https://docs.github.com/rest/reference/activity#get-a-repository-subscription).
     * Note that subscriptions are only generated if a user is participating in a conversation--for
     * example, they've replied to the thread, were **@mentioned**, or manually subscribe to a
     * thread.
     * @param  threadId  Required parameter: The unique identifier of the notification thread. This
     *         corresponds to the value returned in the `id` field when you retrieve notifications
     *         (for example with the [`GET /notifications`
     *         operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).
     * @return    Returns the NotificationsThreadsSubscriptionResponse response from the API call
     */
    public CompletableFuture<NotificationsThreadsSubscriptionResponse> activityGetThreadSubscriptionForAuthenticatedUserAsync(
            final int threadId) {
        try { 
            return prepareActivityGetThreadSubscriptionForAuthenticatedUserRequest(threadId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityGetThreadSubscriptionForAuthenticatedUser.
     */
    private ApiCall<NotificationsThreadsSubscriptionResponse, ApiException> prepareActivityGetThreadSubscriptionForAuthenticatedUserRequest(
            final int threadId) throws IOException {
        return new ApiCall.Builder<NotificationsThreadsSubscriptionResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/notifications/threads/{thread_id}/subscription")
                        .templateParam(param -> param.key("thread_id").value(threadId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, NotificationsThreadsSubscriptionResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new NotificationsThreadsSubscription401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new NotificationsThreadsSubscription403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * If you are watching a repository, you receive notifications for all threads by default. Use
     * this endpoint to ignore future notifications for threads until you comment on the thread or
     * get an **@mention**. You can also use this endpoint to subscribe to threads that you are
     * currently not receiving notifications for or to subscribed to threads that you have
     * previously ignored. Unsubscribing from a conversation in a repository that you are not
     * watching is functionally equivalent to the [Delete a thread
     * subscription](https://docs.github.com/rest/reference/activity#delete-a-thread-subscription)
     * endpoint.
     * @param  threadId  Required parameter: The unique identifier of the notification thread. This
     *         corresponds to the value returned in the `id` field when you retrieve notifications
     *         (for example with the [`GET /notifications`
     *         operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).
     * @param  body  Optional parameter: Example:
     * @return    Returns the NotificationsThreadsSubscriptionResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public NotificationsThreadsSubscriptionResponse activitySetThreadSubscription(
            final int threadId,
            final NotificationsThreadsSubscriptionRequest body) throws ApiException, IOException {
        return prepareActivitySetThreadSubscriptionRequest(threadId, body).execute();
    }

    /**
     * If you are watching a repository, you receive notifications for all threads by default. Use
     * this endpoint to ignore future notifications for threads until you comment on the thread or
     * get an **@mention**. You can also use this endpoint to subscribe to threads that you are
     * currently not receiving notifications for or to subscribed to threads that you have
     * previously ignored. Unsubscribing from a conversation in a repository that you are not
     * watching is functionally equivalent to the [Delete a thread
     * subscription](https://docs.github.com/rest/reference/activity#delete-a-thread-subscription)
     * endpoint.
     * @param  threadId  Required parameter: The unique identifier of the notification thread. This
     *         corresponds to the value returned in the `id` field when you retrieve notifications
     *         (for example with the [`GET /notifications`
     *         operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).
     * @param  body  Optional parameter: Example:
     * @return    Returns the NotificationsThreadsSubscriptionResponse response from the API call
     */
    public CompletableFuture<NotificationsThreadsSubscriptionResponse> activitySetThreadSubscriptionAsync(
            final int threadId,
            final NotificationsThreadsSubscriptionRequest body) {
        try { 
            return prepareActivitySetThreadSubscriptionRequest(threadId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activitySetThreadSubscription.
     */
    private ApiCall<NotificationsThreadsSubscriptionResponse, ApiException> prepareActivitySetThreadSubscriptionRequest(
            final int threadId,
            final NotificationsThreadsSubscriptionRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<NotificationsThreadsSubscriptionResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/notifications/threads/{thread_id}/subscription")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("thread_id").value(threadId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, NotificationsThreadsSubscriptionResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new NotificationsThreadsSubscription401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new NotificationsThreadsSubscription403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Mutes all future notifications for a conversation until you comment on the thread or get an
     * **@mention**. If you are watching the repository of the thread, you will still receive
     * notifications. To ignore future notifications for a repository you are watching, use the [Set
     * a thread
     * subscription](https://docs.github.com/rest/reference/activity#set-a-thread-subscription)
     * endpoint and set `ignore` to `true`.
     * @param  threadId  Required parameter: The unique identifier of the notification thread. This
     *         corresponds to the value returned in the `id` field when you retrieve notifications
     *         (for example with the [`GET /notifications`
     *         operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void activityDeleteThreadSubscription(
            final int threadId) throws ApiException, IOException {
        prepareActivityDeleteThreadSubscriptionRequest(threadId).execute();
    }

    /**
     * Mutes all future notifications for a conversation until you comment on the thread or get an
     * **@mention**. If you are watching the repository of the thread, you will still receive
     * notifications. To ignore future notifications for a repository you are watching, use the [Set
     * a thread
     * subscription](https://docs.github.com/rest/reference/activity#set-a-thread-subscription)
     * endpoint and set `ignore` to `true`.
     * @param  threadId  Required parameter: The unique identifier of the notification thread. This
     *         corresponds to the value returned in the `id` field when you retrieve notifications
     *         (for example with the [`GET /notifications`
     *         operation](https://docs.github.com/rest/reference/activity#list-notifications-for-the-authenticated-user)).
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> activityDeleteThreadSubscriptionAsync(
            final int threadId) {
        try { 
            return prepareActivityDeleteThreadSubscriptionRequest(threadId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityDeleteThreadSubscription.
     */
    private ApiCall<Void, ApiException> prepareActivityDeleteThreadSubscriptionRequest(
            final int threadId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/notifications/threads/{thread_id}/subscription")
                        .templateParam(param -> param.key("thread_id").value(threadId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new NotificationsThreadsSubscription401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new NotificationsThreadsSubscription403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List public organization events.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Event> activityListPublicOrgEvents(
            final String org,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListPublicOrgEventsRequest(org, perPage, page).execute();
    }

    /**
     * List public organization events.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     */
    public CompletableFuture<List<Event>> activityListPublicOrgEventsAsync(
            final String org,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListPublicOrgEventsRequest(org, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListPublicOrgEvents.
     */
    private ApiCall<List<Event>, ApiException> prepareActivityListPublicOrgEventsRequest(
            final String org,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Event>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/events")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Event[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List repository events.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Event> activityListRepoEvents(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListRepoEventsRequest(owner, repo, perPage, page).execute();
    }

    /**
     * List repository events.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     */
    public CompletableFuture<List<Event>> activityListRepoEventsAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListRepoEventsRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListRepoEvents.
     */
    private ApiCall<List<Event>, ApiException> prepareActivityListRepoEventsRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Event>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/events")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Event[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all notifications for the current user in the specified repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  all  Optional parameter: If `true`, show notifications marked as read.
     * @param  participating  Optional parameter: If `true`, only shows notifications in which the
     *         user is directly participating or mentioned.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  before  Optional parameter: Only show notifications updated before the given time.
     *         This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Thread response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Thread> activityListRepoNotificationsForAuthenticatedUser(
            final String owner,
            final String repo,
            final Boolean all,
            final Boolean participating,
            final LocalDateTime since,
            final LocalDateTime before,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListRepoNotificationsForAuthenticatedUserRequest(owner, repo, all,
                participating, since, before, perPage, page).execute();
    }

    /**
     * Lists all notifications for the current user in the specified repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  all  Optional parameter: If `true`, show notifications marked as read.
     * @param  participating  Optional parameter: If `true`, only shows notifications in which the
     *         user is directly participating or mentioned.
     * @param  since  Optional parameter: Only show notifications updated after the given time. This
     *         is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  before  Optional parameter: Only show notifications updated before the given time.
     *         This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format:
     *         `YYYY-MM-DDTHH:MM:SSZ`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Thread response from the API call
     */
    public CompletableFuture<List<Thread>> activityListRepoNotificationsForAuthenticatedUserAsync(
            final String owner,
            final String repo,
            final Boolean all,
            final Boolean participating,
            final LocalDateTime since,
            final LocalDateTime before,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListRepoNotificationsForAuthenticatedUserRequest(owner, repo, all,
            participating, since, before, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListRepoNotificationsForAuthenticatedUser.
     */
    private ApiCall<List<Thread>, ApiException> prepareActivityListRepoNotificationsForAuthenticatedUserRequest(
            final String owner,
            final String repo,
            final Boolean all,
            final Boolean participating,
            final LocalDateTime since,
            final LocalDateTime before,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Thread>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/notifications")
                        .queryParam(param -> param.key("all")
                                .value((all != null) ? all : false).isRequired(false))
                        .queryParam(param -> param.key("participating")
                                .value((participating != null) ? participating : false).isRequired(false))
                        .queryParam(param -> param.key("since")
                                .value(DateTimeHelper.toRfc8601DateTime(since)).isRequired(false))
                        .queryParam(param -> param.key("before")
                                .value(DateTimeHelper.toRfc8601DateTime(before)).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Thread[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Marks all notifications in a repository as "read" for the current user. If the number of
     * notifications is too large to complete in one request, you will receive a `202 Accepted`
     * status and GitHub will run an asynchronous process to mark notifications as "read." To check
     * whether any "unread" notifications remain, you can use the [List repository notifications for
     * the authenticated
     * user](https://docs.github.com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user)
     * endpoint and pass the query parameter `all=false`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposNotificationsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposNotificationsResponse activityMarkRepoNotificationsAsRead(
            final String owner,
            final String repo,
            final ReposNotificationsRequest body) throws ApiException, IOException {
        return prepareActivityMarkRepoNotificationsAsReadRequest(owner, repo, body).execute();
    }

    /**
     * Marks all notifications in a repository as "read" for the current user. If the number of
     * notifications is too large to complete in one request, you will receive a `202 Accepted`
     * status and GitHub will run an asynchronous process to mark notifications as "read." To check
     * whether any "unread" notifications remain, you can use the [List repository notifications for
     * the authenticated
     * user](https://docs.github.com/rest/reference/activity#list-repository-notifications-for-the-authenticated-user)
     * endpoint and pass the query parameter `all=false`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposNotificationsResponse response from the API call
     */
    public CompletableFuture<ReposNotificationsResponse> activityMarkRepoNotificationsAsReadAsync(
            final String owner,
            final String repo,
            final ReposNotificationsRequest body) {
        try { 
            return prepareActivityMarkRepoNotificationsAsReadRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityMarkRepoNotificationsAsRead.
     */
    private ApiCall<ReposNotificationsResponse, ApiException> prepareActivityMarkRepoNotificationsAsReadRequest(
            final String owner,
            final String repo,
            final ReposNotificationsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposNotificationsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/notifications")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposNotificationsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the people that have starred the repository. You can also find out _when_ stars were
     * created by passing the following custom [media
     * type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:
     * `application/vnd.github.star+json`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ActivityListStargazersForRepoResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActivityListStargazersForRepoResponse activityListStargazersForRepo(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListStargazersForRepoRequest(owner, repo, perPage, page).execute();
    }

    /**
     * Lists the people that have starred the repository. You can also find out _when_ stars were
     * created by passing the following custom [media
     * type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:
     * `application/vnd.github.star+json`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ActivityListStargazersForRepoResponse response from the API call
     */
    public CompletableFuture<ActivityListStargazersForRepoResponse> activityListStargazersForRepoAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListStargazersForRepoRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListStargazersForRepo.
     */
    private ApiCall<ActivityListStargazersForRepoResponse, ApiException> prepareActivityListStargazersForRepoRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ActivityListStargazersForRepoResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/stargazers")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActivityListStargazersForRepoResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposStargazers422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the people watching the specified repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SimpleUser response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<SimpleUser> activityListWatchersForRepo(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListWatchersForRepoRequest(owner, repo, perPage, page).execute();
    }

    /**
     * Lists the people watching the specified repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SimpleUser response from the API call
     */
    public CompletableFuture<List<SimpleUser>> activityListWatchersForRepoAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListWatchersForRepoRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListWatchersForRepo.
     */
    private ApiCall<List<SimpleUser>, ApiException> prepareActivityListWatchersForRepoRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<SimpleUser>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/subscribers")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        SimpleUser[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get a repository subscription.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposSubscriptionResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposSubscriptionResponse activityGetRepoSubscription(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareActivityGetRepoSubscriptionRequest(owner, repo).execute();
    }

    /**
     * Get a repository subscription.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposSubscriptionResponse response from the API call
     */
    public CompletableFuture<ReposSubscriptionResponse> activityGetRepoSubscriptionAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActivityGetRepoSubscriptionRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityGetRepoSubscription.
     */
    private ApiCall<ReposSubscriptionResponse, ApiException> prepareActivityGetRepoSubscriptionRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposSubscriptionResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/subscription")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposSubscriptionResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposSubscription403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Not Found if you don't subscribe to the repository",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * If you would like to watch a repository, set `subscribed` to `true`. If you would like to
     * ignore notifications made within a repository, set `ignored` to `true`. If you would like to
     * stop watching a repository, [delete the repository's
     * subscription](https://docs.github.com/rest/reference/activity#delete-a-repository-subscription)
     * completely.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposSubscriptionResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposSubscriptionResponse activitySetRepoSubscription(
            final String owner,
            final String repo,
            final ReposSubscriptionRequest body) throws ApiException, IOException {
        return prepareActivitySetRepoSubscriptionRequest(owner, repo, body).execute();
    }

    /**
     * If you would like to watch a repository, set `subscribed` to `true`. If you would like to
     * ignore notifications made within a repository, set `ignored` to `true`. If you would like to
     * stop watching a repository, [delete the repository's
     * subscription](https://docs.github.com/rest/reference/activity#delete-a-repository-subscription)
     * completely.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposSubscriptionResponse response from the API call
     */
    public CompletableFuture<ReposSubscriptionResponse> activitySetRepoSubscriptionAsync(
            final String owner,
            final String repo,
            final ReposSubscriptionRequest body) {
        try { 
            return prepareActivitySetRepoSubscriptionRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activitySetRepoSubscription.
     */
    private ApiCall<ReposSubscriptionResponse, ApiException> prepareActivitySetRepoSubscriptionRequest(
            final String owner,
            final String repo,
            final ReposSubscriptionRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposSubscriptionResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/subscription")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposSubscriptionResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This endpoint should only be used to stop watching a repository. To control whether or not
     * you wish to receive notifications from a repository, [set the repository's subscription
     * manually](https://docs.github.com/rest/reference/activity#set-a-repository-subscription).
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void activityDeleteRepoSubscription(
            final String owner,
            final String repo) throws ApiException, IOException {
        prepareActivityDeleteRepoSubscriptionRequest(owner, repo).execute();
    }

    /**
     * This endpoint should only be used to stop watching a repository. To control whether or not
     * you wish to receive notifications from a repository, [set the repository's subscription
     * manually](https://docs.github.com/rest/reference/activity#set-a-repository-subscription).
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> activityDeleteRepoSubscriptionAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActivityDeleteRepoSubscriptionRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityDeleteRepoSubscription.
     */
    private ApiCall<Void, ApiException> prepareActivityDeleteRepoSubscriptionRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/subscription")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists repositories the authenticated user has starred. You can also find out _when_ stars
     * were created by passing the following custom [media
     * type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:
     * `application/vnd.github.star+json`.
     * @param  sort  Optional parameter: The property to sort the results by. `created` means when
     *         the repository was starred. `updated` means when the repository was last pushed to.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Repository response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Repository> activityListReposStarredByAuthenticatedUser(
            final Sort1Enum sort,
            final Direction1Enum direction,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListReposStarredByAuthenticatedUserRequest(sort, direction, perPage,
                page).execute();
    }

    /**
     * Lists repositories the authenticated user has starred. You can also find out _when_ stars
     * were created by passing the following custom [media
     * type](https://docs.github.com/rest/overview/media-types/) via the `Accept` header:
     * `application/vnd.github.star+json`.
     * @param  sort  Optional parameter: The property to sort the results by. `created` means when
     *         the repository was starred. `updated` means when the repository was last pushed to.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Repository response from the API call
     */
    public CompletableFuture<List<Repository>> activityListReposStarredByAuthenticatedUserAsync(
            final Sort1Enum sort,
            final Direction1Enum direction,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListReposStarredByAuthenticatedUserRequest(sort, direction, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListReposStarredByAuthenticatedUser.
     */
    private ApiCall<List<Repository>, ApiException> prepareActivityListReposStarredByAuthenticatedUserRequest(
            final Sort1Enum sort,
            final Direction1Enum direction,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Repository>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/starred")
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Repository[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserStarred401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserStarred403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Check if a repository is starred by the authenticated user.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void activityCheckRepoIsStarredByAuthenticatedUser(
            final String owner,
            final String repo) throws ApiException, IOException {
        prepareActivityCheckRepoIsStarredByAuthenticatedUserRequest(owner, repo).execute();
    }

    /**
     * Check if a repository is starred by the authenticated user.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> activityCheckRepoIsStarredByAuthenticatedUserAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActivityCheckRepoIsStarredByAuthenticatedUserRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityCheckRepoIsStarredByAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareActivityCheckRepoIsStarredByAuthenticatedUserRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/starred/{owner}/{repo}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserStarred401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserStarred403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Not Found if this repository is not starred by you",
                                (reason, context) -> new UserStarred404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For
     * more information, see "[HTTP
     * verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void activityStarRepoForAuthenticatedUser(
            final String owner,
            final String repo) throws ApiException, IOException {
        prepareActivityStarRepoForAuthenticatedUserRequest(owner, repo).execute();
    }

    /**
     * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For
     * more information, see "[HTTP
     * verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> activityStarRepoForAuthenticatedUserAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActivityStarRepoForAuthenticatedUserRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityStarRepoForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareActivityStarRepoForAuthenticatedUserRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/starred/{owner}/{repo}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserStarred401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserStarred403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserStarred404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Unstar a repository for the authenticated user.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void activityUnstarRepoForAuthenticatedUser(
            final String owner,
            final String repo) throws ApiException, IOException {
        prepareActivityUnstarRepoForAuthenticatedUserRequest(owner, repo).execute();
    }

    /**
     * Unstar a repository for the authenticated user.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> activityUnstarRepoForAuthenticatedUserAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActivityUnstarRepoForAuthenticatedUserRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityUnstarRepoForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareActivityUnstarRepoForAuthenticatedUserRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/starred/{owner}/{repo}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserStarred401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserStarred403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserStarred404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists repositories the authenticated user is watching.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MinimalRepository response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<MinimalRepository> activityListWatchedReposForAuthenticatedUser(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListWatchedReposForAuthenticatedUserRequest(perPage, page).execute();
    }

    /**
     * Lists repositories the authenticated user is watching.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MinimalRepository response from the API call
     */
    public CompletableFuture<List<MinimalRepository>> activityListWatchedReposForAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListWatchedReposForAuthenticatedUserRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListWatchedReposForAuthenticatedUser.
     */
    private ApiCall<List<MinimalRepository>, ApiException> prepareActivityListWatchedReposForAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<MinimalRepository>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/subscriptions")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        MinimalRepository[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserSubscriptions401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserSubscriptions403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * If you are authenticated as the given user, you will see your private events. Otherwise,
     * you'll only see public events.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Event> activityListEventsForAuthenticatedUser(
            final String username,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListEventsForAuthenticatedUserRequest(username, perPage,
                page).execute();
    }

    /**
     * If you are authenticated as the given user, you will see your private events. Otherwise,
     * you'll only see public events.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     */
    public CompletableFuture<List<Event>> activityListEventsForAuthenticatedUserAsync(
            final String username,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListEventsForAuthenticatedUserRequest(username, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListEventsForAuthenticatedUser.
     */
    private ApiCall<List<Event>, ApiException> prepareActivityListEventsForAuthenticatedUserRequest(
            final String username,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Event>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/events")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Event[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This is the user's organization dashboard. You must be authenticated as the user to view
     * this.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Event> activityListOrgEventsForAuthenticatedUser(
            final String username,
            final String org,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListOrgEventsForAuthenticatedUserRequest(username, org, perPage,
                page).execute();
    }

    /**
     * This is the user's organization dashboard. You must be authenticated as the user to view
     * this.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     */
    public CompletableFuture<List<Event>> activityListOrgEventsForAuthenticatedUserAsync(
            final String username,
            final String org,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListOrgEventsForAuthenticatedUserRequest(username, org, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListOrgEventsForAuthenticatedUser.
     */
    private ApiCall<List<Event>, ApiException> prepareActivityListOrgEventsForAuthenticatedUserRequest(
            final String username,
            final String org,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Event>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/events/orgs/{org}")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Event[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List public events for a user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Event> activityListPublicEventsForUser(
            final String username,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListPublicEventsForUserRequest(username, perPage, page).execute();
    }

    /**
     * List public events for a user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     */
    public CompletableFuture<List<Event>> activityListPublicEventsForUserAsync(
            final String username,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListPublicEventsForUserRequest(username, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListPublicEventsForUser.
     */
    private ApiCall<List<Event>, ApiException> prepareActivityListPublicEventsForUserRequest(
            final String username,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Event>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/events/public")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Event[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * These are events that you've received by watching repos and following users. If you are
     * authenticated as the given user, you will see private events. Otherwise, you'll only see
     * public events.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Event> activityListReceivedEventsForUser(
            final String username,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListReceivedEventsForUserRequest(username, perPage, page).execute();
    }

    /**
     * These are events that you've received by watching repos and following users. If you are
     * authenticated as the given user, you will see private events. Otherwise, you'll only see
     * public events.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     */
    public CompletableFuture<List<Event>> activityListReceivedEventsForUserAsync(
            final String username,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListReceivedEventsForUserRequest(username, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListReceivedEventsForUser.
     */
    private ApiCall<List<Event>, ApiException> prepareActivityListReceivedEventsForUserRequest(
            final String username,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Event>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/received_events")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Event[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List public events received by a user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Event> activityListReceivedPublicEventsForUser(
            final String username,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListReceivedPublicEventsForUserRequest(username, perPage,
                page).execute();
    }

    /**
     * List public events received by a user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Event response from the API call
     */
    public CompletableFuture<List<Event>> activityListReceivedPublicEventsForUserAsync(
            final String username,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListReceivedPublicEventsForUserRequest(username, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListReceivedPublicEventsForUser.
     */
    private ApiCall<List<Event>, ApiException> prepareActivityListReceivedPublicEventsForUserRequest(
            final String username,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Event>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/received_events/public")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Event[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists repositories a user has starred. You can also find out _when_ stars were created by
     * passing the following custom [media type](https://docs.github.com/rest/overview/media-types/)
     * via the `Accept` header: `application/vnd.github.star+json`.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  sort  Optional parameter: The property to sort the results by. `created` means when
     *         the repository was starred. `updated` means when the repository was last pushed to.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ActivityListReposStarredByUserResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActivityListReposStarredByUserResponse activityListReposStarredByUser(
            final String username,
            final Sort1Enum sort,
            final Direction1Enum direction,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListReposStarredByUserRequest(username, sort, direction, perPage,
                page).execute();
    }

    /**
     * Lists repositories a user has starred. You can also find out _when_ stars were created by
     * passing the following custom [media type](https://docs.github.com/rest/overview/media-types/)
     * via the `Accept` header: `application/vnd.github.star+json`.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  sort  Optional parameter: The property to sort the results by. `created` means when
     *         the repository was starred. `updated` means when the repository was last pushed to.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ActivityListReposStarredByUserResponse response from the API call
     */
    public CompletableFuture<ActivityListReposStarredByUserResponse> activityListReposStarredByUserAsync(
            final String username,
            final Sort1Enum sort,
            final Direction1Enum direction,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListReposStarredByUserRequest(username, sort, direction, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListReposStarredByUser.
     */
    private ApiCall<ActivityListReposStarredByUserResponse, ApiException> prepareActivityListReposStarredByUserRequest(
            final String username,
            final Sort1Enum sort,
            final Direction1Enum direction,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ActivityListReposStarredByUserResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/starred")
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActivityListReposStarredByUserResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists repositories a user is watching.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MinimalRepository response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<MinimalRepository> activityListReposWatchedByUser(
            final String username,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActivityListReposWatchedByUserRequest(username, perPage, page).execute();
    }

    /**
     * Lists repositories a user is watching.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MinimalRepository response from the API call
     */
    public CompletableFuture<List<MinimalRepository>> activityListReposWatchedByUserAsync(
            final String username,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActivityListReposWatchedByUserRequest(username, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for activityListReposWatchedByUser.
     */
    private ApiCall<List<MinimalRepository>, ApiException> prepareActivityListReposWatchedByUserRequest(
            final String username,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<MinimalRepository>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/subscriptions")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        MinimalRepository[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}