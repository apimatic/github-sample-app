/*
 * GitHubAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.github.api.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.github.api.ApiHelper;
import com.github.api.Server;
import com.github.api.exceptions.ApiException;
import com.github.api.exceptions.EnterprisesDependabotAlerts403ErrorException;
import com.github.api.exceptions.EnterprisesDependabotAlerts404ErrorException;
import com.github.api.exceptions.EnterprisesDependabotAlerts422ErrorException;
import com.github.api.exceptions.OrgsDependabotAlerts400ErrorException;
import com.github.api.exceptions.OrgsDependabotAlerts403ErrorException;
import com.github.api.exceptions.OrgsDependabotAlerts404ErrorException;
import com.github.api.exceptions.OrgsDependabotAlerts422ErrorException;
import com.github.api.exceptions.ReposDependabotAlerts400ErrorException;
import com.github.api.exceptions.ReposDependabotAlerts403ErrorException;
import com.github.api.exceptions.ReposDependabotAlerts404ErrorException;
import com.github.api.exceptions.ReposDependabotAlerts422ErrorException;
import com.github.api.exceptions.ReposDependabotAlertsAlertNumber400ErrorException;
import com.github.api.exceptions.ReposDependabotAlertsAlertNumber403ErrorException;
import com.github.api.exceptions.ReposDependabotAlertsAlertNumber404ErrorException;
import com.github.api.exceptions.ReposDependabotAlertsAlertNumber409ErrorException;
import com.github.api.exceptions.ReposDependabotAlertsAlertNumber422ErrorException;
import com.github.api.http.request.HttpMethod;
import com.github.api.models.DependabotAlert;
import com.github.api.models.DependabotAlertWithRepository;
import com.github.api.models.Direction1Enum;
import com.github.api.models.OrgsActionsSecretsRepositoriesResponse;
import com.github.api.models.OrgsDependabotSecretsPublicKeyResponse;
import com.github.api.models.OrgsDependabotSecretsRepositoriesRequest;
import com.github.api.models.OrgsDependabotSecretsRequest;
import com.github.api.models.OrgsDependabotSecretsResponse;
import com.github.api.models.OrgsDependabotSecretsResponse2;
import com.github.api.models.ReposDependabotAlertsAlertNumberRequest;
import com.github.api.models.ReposDependabotAlertsAlertNumberResponse;
import com.github.api.models.ReposDependabotSecretsPublicKeyResponse;
import com.github.api.models.ReposDependabotSecretsResponse;
import com.github.api.models.ReposDependabotSecretsSecretNameRequest;
import com.github.api.models.ReposDependabotSecretsSecretNameResponse;
import com.github.api.models.Scope61Enum;
import com.github.api.models.Sort18Enum;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class DependabotController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public DependabotController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Lists Dependabot alerts for repositories that are owned by the specified enterprise. To use
     * this endpoint, you must be a member of the enterprise, and you must use an access token with
     * the `repo` scope or `security_events` scope. Alerts are only returned for organizations in
     * the enterprise for which you are an organization owner or a security manager. For more
     * information about security managers, see "[Managing security managers in your
     * organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).".
     * @param  enterprise  Required parameter: The slug version of the enterprise name. You can also
     *         substitute this value with the enterprise id.
     * @param  state  Optional parameter: A comma-separated list of states. If specified, only
     *         alerts with these states will be returned. Can be: `dismissed`, `fixed`, `open`
     * @param  severity  Optional parameter: A comma-separated list of severities. If specified,
     *         only alerts with these severities will be returned. Can be: `low`, `medium`, `high`,
     *         `critical`
     * @param  ecosystem  Optional parameter: A comma-separated list of ecosystems. If specified,
     *         only alerts for these ecosystems will be returned. Can be: `composer`, `go`, `maven`,
     *         `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
     * @param  mPackage  Optional parameter: A comma-separated list of package names. If specified,
     *         only alerts for these packages will be returned.
     * @param  scope  Optional parameter: The scope of the vulnerable dependency. If specified, only
     *         alerts with this scope will be returned.
     * @param  sort  Optional parameter: The property by which to sort the results. `created` means
     *         when the alert was created. `updated` means when the alert's state last changed.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  before  Optional parameter: A cursor, as given in the [Link
     *         header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header).
     *         If specified, the query only searches for results before this cursor.
     * @param  after  Optional parameter: A cursor, as given in the [Link
     *         header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header).
     *         If specified, the query only searches for results after this cursor.
     * @param  first  Optional parameter: **Deprecated**. The number of results per page (max 100),
     *         starting from the first matching result. This parameter must not be used in
     *         combination with `last`. Instead, use `per_page` in combination with `after` to fetch
     *         the first page of results.
     * @param  last  Optional parameter: **Deprecated**. The number of results per page (max 100),
     *         starting from the last matching result. This parameter must not be used in
     *         combination with `first`. Instead, use `per_page` in combination with `before` to
     *         fetch the last page of results.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the List of DependabotAlertWithRepository response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<DependabotAlertWithRepository> dependabotListAlertsForEnterprise(
            final String enterprise,
            final String state,
            final String severity,
            final String ecosystem,
            final String mPackage,
            final Scope61Enum scope,
            final Sort18Enum sort,
            final Direction1Enum direction,
            final String before,
            final String after,
            final Integer first,
            final Integer last,
            final Integer perPage) throws ApiException, IOException {
        return prepareDependabotListAlertsForEnterpriseRequest(enterprise, state, severity,
                ecosystem, mPackage, scope, sort, direction, before, after, first, last,
                perPage).execute();
    }

    /**
     * Lists Dependabot alerts for repositories that are owned by the specified enterprise. To use
     * this endpoint, you must be a member of the enterprise, and you must use an access token with
     * the `repo` scope or `security_events` scope. Alerts are only returned for organizations in
     * the enterprise for which you are an organization owner or a security manager. For more
     * information about security managers, see "[Managing security managers in your
     * organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization).".
     * @param  enterprise  Required parameter: The slug version of the enterprise name. You can also
     *         substitute this value with the enterprise id.
     * @param  state  Optional parameter: A comma-separated list of states. If specified, only
     *         alerts with these states will be returned. Can be: `dismissed`, `fixed`, `open`
     * @param  severity  Optional parameter: A comma-separated list of severities. If specified,
     *         only alerts with these severities will be returned. Can be: `low`, `medium`, `high`,
     *         `critical`
     * @param  ecosystem  Optional parameter: A comma-separated list of ecosystems. If specified,
     *         only alerts for these ecosystems will be returned. Can be: `composer`, `go`, `maven`,
     *         `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
     * @param  mPackage  Optional parameter: A comma-separated list of package names. If specified,
     *         only alerts for these packages will be returned.
     * @param  scope  Optional parameter: The scope of the vulnerable dependency. If specified, only
     *         alerts with this scope will be returned.
     * @param  sort  Optional parameter: The property by which to sort the results. `created` means
     *         when the alert was created. `updated` means when the alert's state last changed.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  before  Optional parameter: A cursor, as given in the [Link
     *         header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header).
     *         If specified, the query only searches for results before this cursor.
     * @param  after  Optional parameter: A cursor, as given in the [Link
     *         header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header).
     *         If specified, the query only searches for results after this cursor.
     * @param  first  Optional parameter: **Deprecated**. The number of results per page (max 100),
     *         starting from the first matching result. This parameter must not be used in
     *         combination with `last`. Instead, use `per_page` in combination with `after` to fetch
     *         the first page of results.
     * @param  last  Optional parameter: **Deprecated**. The number of results per page (max 100),
     *         starting from the last matching result. This parameter must not be used in
     *         combination with `first`. Instead, use `per_page` in combination with `before` to
     *         fetch the last page of results.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the List of DependabotAlertWithRepository response from the API call
     */
    public CompletableFuture<List<DependabotAlertWithRepository>> dependabotListAlertsForEnterpriseAsync(
            final String enterprise,
            final String state,
            final String severity,
            final String ecosystem,
            final String mPackage,
            final Scope61Enum scope,
            final Sort18Enum sort,
            final Direction1Enum direction,
            final String before,
            final String after,
            final Integer first,
            final Integer last,
            final Integer perPage) {
        try { 
            return prepareDependabotListAlertsForEnterpriseRequest(enterprise, state, severity, ecosystem,
            mPackage, scope, sort, direction, before, after, first, last, perPage).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotListAlertsForEnterprise.
     */
    private ApiCall<List<DependabotAlertWithRepository>, ApiException> prepareDependabotListAlertsForEnterpriseRequest(
            final String enterprise,
            final String state,
            final String severity,
            final String ecosystem,
            final String mPackage,
            final Scope61Enum scope,
            final Sort18Enum sort,
            final Direction1Enum direction,
            final String before,
            final String after,
            final Integer first,
            final Integer last,
            final Integer perPage) throws IOException {
        return new ApiCall.Builder<List<DependabotAlertWithRepository>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/enterprises/{enterprise}/dependabot/alerts")
                        .queryParam(param -> param.key("state")
                                .value(state).isRequired(false))
                        .queryParam(param -> param.key("severity")
                                .value(severity).isRequired(false))
                        .queryParam(param -> param.key("ecosystem")
                                .value(ecosystem).isRequired(false))
                        .queryParam(param -> param.key("package")
                                .value(mPackage).isRequired(false))
                        .queryParam(param -> param.key("scope")
                                .value((scope != null) ? scope.value() : null).isRequired(false))
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("before")
                                .value(before).isRequired(false))
                        .queryParam(param -> param.key("after")
                                .value(after).isRequired(false))
                        .queryParam(param -> param.key("first")
                                .value((first != null) ? first : 30).isRequired(false))
                        .queryParam(param -> param.key("last")
                                .value(last).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .templateParam(param -> param.key("enterprise").value(enterprise)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        DependabotAlertWithRepository[].class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new EnterprisesDependabotAlerts403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new EnterprisesDependabotAlerts404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new EnterprisesDependabotAlerts422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists Dependabot alerts for an organization. To use this endpoint, you must be an owner or
     * security manager for the organization, and you must use an access token with the `repo` scope
     * or `security_events` scope. For public repositories, you may instead use the `public_repo`
     * scope. GitHub Apps must have **Dependabot alerts** read permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  state  Optional parameter: A comma-separated list of states. If specified, only
     *         alerts with these states will be returned. Can be: `dismissed`, `fixed`, `open`
     * @param  severity  Optional parameter: A comma-separated list of severities. If specified,
     *         only alerts with these severities will be returned. Can be: `low`, `medium`, `high`,
     *         `critical`
     * @param  ecosystem  Optional parameter: A comma-separated list of ecosystems. If specified,
     *         only alerts for these ecosystems will be returned. Can be: `composer`, `go`, `maven`,
     *         `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
     * @param  mPackage  Optional parameter: A comma-separated list of package names. If specified,
     *         only alerts for these packages will be returned.
     * @param  scope  Optional parameter: The scope of the vulnerable dependency. If specified, only
     *         alerts with this scope will be returned.
     * @param  sort  Optional parameter: The property by which to sort the results. `created` means
     *         when the alert was created. `updated` means when the alert's state last changed.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  before  Optional parameter: A cursor, as given in the [Link
     *         header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header).
     *         If specified, the query only searches for results before this cursor.
     * @param  after  Optional parameter: A cursor, as given in the [Link
     *         header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header).
     *         If specified, the query only searches for results after this cursor.
     * @param  first  Optional parameter: **Deprecated**. The number of results per page (max 100),
     *         starting from the first matching result. This parameter must not be used in
     *         combination with `last`. Instead, use `per_page` in combination with `after` to fetch
     *         the first page of results.
     * @param  last  Optional parameter: **Deprecated**. The number of results per page (max 100),
     *         starting from the last matching result. This parameter must not be used in
     *         combination with `first`. Instead, use `per_page` in combination with `before` to
     *         fetch the last page of results.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the List of DependabotAlertWithRepository response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<DependabotAlertWithRepository> dependabotListAlertsForOrg(
            final String org,
            final String state,
            final String severity,
            final String ecosystem,
            final String mPackage,
            final Scope61Enum scope,
            final Sort18Enum sort,
            final Direction1Enum direction,
            final String before,
            final String after,
            final Integer first,
            final Integer last,
            final Integer perPage) throws ApiException, IOException {
        return prepareDependabotListAlertsForOrgRequest(org, state, severity, ecosystem, mPackage,
                scope, sort, direction, before, after, first, last, perPage).execute();
    }

    /**
     * Lists Dependabot alerts for an organization. To use this endpoint, you must be an owner or
     * security manager for the organization, and you must use an access token with the `repo` scope
     * or `security_events` scope. For public repositories, you may instead use the `public_repo`
     * scope. GitHub Apps must have **Dependabot alerts** read permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  state  Optional parameter: A comma-separated list of states. If specified, only
     *         alerts with these states will be returned. Can be: `dismissed`, `fixed`, `open`
     * @param  severity  Optional parameter: A comma-separated list of severities. If specified,
     *         only alerts with these severities will be returned. Can be: `low`, `medium`, `high`,
     *         `critical`
     * @param  ecosystem  Optional parameter: A comma-separated list of ecosystems. If specified,
     *         only alerts for these ecosystems will be returned. Can be: `composer`, `go`, `maven`,
     *         `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
     * @param  mPackage  Optional parameter: A comma-separated list of package names. If specified,
     *         only alerts for these packages will be returned.
     * @param  scope  Optional parameter: The scope of the vulnerable dependency. If specified, only
     *         alerts with this scope will be returned.
     * @param  sort  Optional parameter: The property by which to sort the results. `created` means
     *         when the alert was created. `updated` means when the alert's state last changed.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  before  Optional parameter: A cursor, as given in the [Link
     *         header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header).
     *         If specified, the query only searches for results before this cursor.
     * @param  after  Optional parameter: A cursor, as given in the [Link
     *         header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header).
     *         If specified, the query only searches for results after this cursor.
     * @param  first  Optional parameter: **Deprecated**. The number of results per page (max 100),
     *         starting from the first matching result. This parameter must not be used in
     *         combination with `last`. Instead, use `per_page` in combination with `after` to fetch
     *         the first page of results.
     * @param  last  Optional parameter: **Deprecated**. The number of results per page (max 100),
     *         starting from the last matching result. This parameter must not be used in
     *         combination with `first`. Instead, use `per_page` in combination with `before` to
     *         fetch the last page of results.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the List of DependabotAlertWithRepository response from the API call
     */
    public CompletableFuture<List<DependabotAlertWithRepository>> dependabotListAlertsForOrgAsync(
            final String org,
            final String state,
            final String severity,
            final String ecosystem,
            final String mPackage,
            final Scope61Enum scope,
            final Sort18Enum sort,
            final Direction1Enum direction,
            final String before,
            final String after,
            final Integer first,
            final Integer last,
            final Integer perPage) {
        try { 
            return prepareDependabotListAlertsForOrgRequest(org, state, severity, ecosystem, mPackage,
            scope, sort, direction, before, after, first, last, perPage).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotListAlertsForOrg.
     */
    private ApiCall<List<DependabotAlertWithRepository>, ApiException> prepareDependabotListAlertsForOrgRequest(
            final String org,
            final String state,
            final String severity,
            final String ecosystem,
            final String mPackage,
            final Scope61Enum scope,
            final Sort18Enum sort,
            final Direction1Enum direction,
            final String before,
            final String after,
            final Integer first,
            final Integer last,
            final Integer perPage) throws IOException {
        return new ApiCall.Builder<List<DependabotAlertWithRepository>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/dependabot/alerts")
                        .queryParam(param -> param.key("state")
                                .value(state).isRequired(false))
                        .queryParam(param -> param.key("severity")
                                .value(severity).isRequired(false))
                        .queryParam(param -> param.key("ecosystem")
                                .value(ecosystem).isRequired(false))
                        .queryParam(param -> param.key("package")
                                .value(mPackage).isRequired(false))
                        .queryParam(param -> param.key("scope")
                                .value((scope != null) ? scope.value() : null).isRequired(false))
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("before")
                                .value(before).isRequired(false))
                        .queryParam(param -> param.key("after")
                                .value(after).isRequired(false))
                        .queryParam(param -> param.key("first")
                                .value((first != null) ? first : 30).isRequired(false))
                        .queryParam(param -> param.key("last")
                                .value(last).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        DependabotAlertWithRepository[].class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new OrgsDependabotAlerts400ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new OrgsDependabotAlerts403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsDependabotAlerts404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new OrgsDependabotAlerts422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all secrets available in an organization without revealing their encrypted values. You
     * must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsDependabotSecretsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsDependabotSecretsResponse dependabotListOrgSecrets(
            final String org,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareDependabotListOrgSecretsRequest(org, perPage, page).execute();
    }

    /**
     * Lists all secrets available in an organization without revealing their encrypted values. You
     * must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsDependabotSecretsResponse response from the API call
     */
    public CompletableFuture<OrgsDependabotSecretsResponse> dependabotListOrgSecretsAsync(
            final String org,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareDependabotListOrgSecretsRequest(org, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotListOrgSecrets.
     */
    private ApiCall<OrgsDependabotSecretsResponse, ApiException> prepareDependabotListOrgSecretsRequest(
            final String org,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<OrgsDependabotSecretsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/dependabot/secrets")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsDependabotSecretsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
     * you can create or update secrets. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets`
     * organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the OrgsDependabotSecretsPublicKeyResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsDependabotSecretsPublicKeyResponse dependabotGetOrgPublicKey(
            final String org) throws ApiException, IOException {
        return prepareDependabotGetOrgPublicKeyRequest(org).execute();
    }

    /**
     * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
     * you can create or update secrets. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets`
     * organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the OrgsDependabotSecretsPublicKeyResponse response from the API call
     */
    public CompletableFuture<OrgsDependabotSecretsPublicKeyResponse> dependabotGetOrgPublicKeyAsync(
            final String org) {
        try { 
            return prepareDependabotGetOrgPublicKeyRequest(org).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotGetOrgPublicKey.
     */
    private ApiCall<OrgsDependabotSecretsPublicKeyResponse, ApiException> prepareDependabotGetOrgPublicKeyRequest(
            final String org) throws IOException {
        return new ApiCall.Builder<OrgsDependabotSecretsPublicKeyResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/dependabot/secrets/public-key")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsDependabotSecretsPublicKeyResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a single organization secret without revealing its encrypted value. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub
     * Apps must have the `dependabot_secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the OrgsDependabotSecretsResponse2 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsDependabotSecretsResponse2 dependabotGetOrgSecret(
            final String org,
            final String secretName) throws ApiException, IOException {
        return prepareDependabotGetOrgSecretRequest(org, secretName).execute();
    }

    /**
     * Gets a single organization secret without revealing its encrypted value. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub
     * Apps must have the `dependabot_secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the OrgsDependabotSecretsResponse2 response from the API call
     */
    public CompletableFuture<OrgsDependabotSecretsResponse2> dependabotGetOrgSecretAsync(
            final String org,
            final String secretName) {
        try { 
            return prepareDependabotGetOrgSecretRequest(org, secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotGetOrgSecret.
     */
    private ApiCall<OrgsDependabotSecretsResponse2, ApiException> prepareDependabotGetOrgSecretRequest(
            final String org,
            final String secretName) throws IOException {
        return new ApiCall.Builder<OrgsDependabotSecretsResponse2, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/dependabot/secrets/{secret_name}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsDependabotSecretsResponse2.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates or updates an organization secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub
     * Apps must have the `dependabot_secrets` organization permission to use this endpoint. ####
     * Example encrypting a secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example encrypting a secret using Python Encrypt your secret
     * using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with
     * Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example encrypting a
     * secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object dependabotCreateOrUpdateOrgSecret(
            final String org,
            final String secretName,
            final OrgsDependabotSecretsRequest body) throws ApiException, IOException {
        return prepareDependabotCreateOrUpdateOrgSecretRequest(org, secretName, body).execute();
    }

    /**
     * Creates or updates an organization secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub
     * Apps must have the `dependabot_secrets` organization permission to use this endpoint. ####
     * Example encrypting a secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example encrypting a secret using Python Encrypt your secret
     * using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with
     * Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example encrypting a
     * secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> dependabotCreateOrUpdateOrgSecretAsync(
            final String org,
            final String secretName,
            final OrgsDependabotSecretsRequest body) {
        try { 
            return prepareDependabotCreateOrUpdateOrgSecretRequest(org, secretName, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotCreateOrUpdateOrgSecret.
     */
    private ApiCall<Object, ApiException> prepareDependabotCreateOrUpdateOrgSecretRequest(
            final String org,
            final String secretName,
            final OrgsDependabotSecretsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/dependabot/secrets/{secret_name}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a secret in an organization using the secret name. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
     * `dependabot_secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void dependabotDeleteOrgSecret(
            final String org,
            final String secretName) throws ApiException, IOException {
        prepareDependabotDeleteOrgSecretRequest(org, secretName).execute();
    }

    /**
     * Deletes a secret in an organization using the secret name. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
     * `dependabot_secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> dependabotDeleteOrgSecretAsync(
            final String org,
            final String secretName) {
        try { 
            return prepareDependabotDeleteOrgSecretRequest(org, secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotDeleteOrgSecret.
     */
    private ApiCall<Void, ApiException> prepareDependabotDeleteOrgSecretRequest(
            final String org,
            final String secretName) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/dependabot/secrets/{secret_name}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all repositories that have been selected when the `visibility` for repository access to
     * a secret is set to `selected`. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets`
     * organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the OrgsActionsSecretsRepositoriesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsSecretsRepositoriesResponse dependabotListSelectedReposForOrgSecret(
            final String org,
            final String secretName,
            final Integer page,
            final Integer perPage) throws ApiException, IOException {
        return prepareDependabotListSelectedReposForOrgSecretRequest(org, secretName, page,
                perPage).execute();
    }

    /**
     * Lists all repositories that have been selected when the `visibility` for repository access to
     * a secret is set to `selected`. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the `dependabot_secrets`
     * organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the OrgsActionsSecretsRepositoriesResponse response from the API call
     */
    public CompletableFuture<OrgsActionsSecretsRepositoriesResponse> dependabotListSelectedReposForOrgSecretAsync(
            final String org,
            final String secretName,
            final Integer page,
            final Integer perPage) {
        try { 
            return prepareDependabotListSelectedReposForOrgSecretRequest(org, secretName, page,
            perPage).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotListSelectedReposForOrgSecret.
     */
    private ApiCall<OrgsActionsSecretsRepositoriesResponse, ApiException> prepareDependabotListSelectedReposForOrgSecretRequest(
            final String org,
            final String secretName,
            final Integer page,
            final Integer perPage) throws IOException {
        return new ApiCall.Builder<OrgsActionsSecretsRepositoriesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/dependabot/secrets/{secret_name}/repositories")
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsSecretsRepositoriesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Replaces all repositories for an organization secret when the `visibility` for repository
     * access is set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void dependabotSetSelectedReposForOrgSecret(
            final String org,
            final String secretName,
            final OrgsDependabotSecretsRepositoriesRequest body) throws ApiException, IOException {
        prepareDependabotSetSelectedReposForOrgSecretRequest(org, secretName, body).execute();
    }

    /**
     * Replaces all repositories for an organization secret when the `visibility` for repository
     * access is set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> dependabotSetSelectedReposForOrgSecretAsync(
            final String org,
            final String secretName,
            final OrgsDependabotSecretsRepositoriesRequest body) {
        try { 
            return prepareDependabotSetSelectedReposForOrgSecretRequest(org, secretName,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotSetSelectedReposForOrgSecret.
     */
    private ApiCall<Void, ApiException> prepareDependabotSetSelectedReposForOrgSecretRequest(
            final String org,
            final String secretName,
            final OrgsDependabotSecretsRepositoriesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/dependabot/secrets/{secret_name}/repositories")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Adds a repository to an organization secret when the `visibility` for repository access is
     * set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void dependabotAddSelectedRepoToOrgSecret(
            final String org,
            final String secretName,
            final int repositoryId) throws ApiException, IOException {
        prepareDependabotAddSelectedRepoToOrgSecretRequest(org, secretName, repositoryId).execute();
    }

    /**
     * Adds a repository to an organization secret when the `visibility` for repository access is
     * set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> dependabotAddSelectedRepoToOrgSecretAsync(
            final String org,
            final String secretName,
            final int repositoryId) {
        try { 
            return prepareDependabotAddSelectedRepoToOrgSecretRequest(org, secretName,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotAddSelectedRepoToOrgSecret.
     */
    private ApiCall<Void, ApiException> prepareDependabotAddSelectedRepoToOrgSecretRequest(
            final String org,
            final String secretName,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict when visibility type is not set to selected",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes a repository from an organization secret when the `visibility` for repository access
     * is set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void dependabotRemoveSelectedRepoFromOrgSecret(
            final String org,
            final String secretName,
            final int repositoryId) throws ApiException, IOException {
        prepareDependabotRemoveSelectedRepoFromOrgSecretRequest(org, secretName,
                repositoryId).execute();
    }

    /**
     * Removes a repository from an organization secret when the `visibility` for repository access
     * is set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/dependabot#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `dependabot_secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> dependabotRemoveSelectedRepoFromOrgSecretAsync(
            final String org,
            final String secretName,
            final int repositoryId) {
        try { 
            return prepareDependabotRemoveSelectedRepoFromOrgSecretRequest(org, secretName,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotRemoveSelectedRepoFromOrgSecret.
     */
    private ApiCall<Void, ApiException> prepareDependabotRemoveSelectedRepoFromOrgSecretRequest(
            final String org,
            final String secretName,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict when visibility type not set to selected",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * You must use an access token with the `security_events` scope to use this endpoint with
     * private repositories. You can also use tokens with the `public_repo` scope for public
     * repositories only. GitHub Apps must have **Dependabot alerts** read permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  state  Optional parameter: A comma-separated list of states. If specified, only
     *         alerts with these states will be returned. Can be: `dismissed`, `fixed`, `open`
     * @param  severity  Optional parameter: A comma-separated list of severities. If specified,
     *         only alerts with these severities will be returned. Can be: `low`, `medium`, `high`,
     *         `critical`
     * @param  ecosystem  Optional parameter: A comma-separated list of ecosystems. If specified,
     *         only alerts for these ecosystems will be returned. Can be: `composer`, `go`, `maven`,
     *         `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
     * @param  mPackage  Optional parameter: A comma-separated list of package names. If specified,
     *         only alerts for these packages will be returned.
     * @param  manifest  Optional parameter: A comma-separated list of full manifest paths. If
     *         specified, only alerts for these manifests will be returned.
     * @param  scope  Optional parameter: The scope of the vulnerable dependency. If specified, only
     *         alerts with this scope will be returned.
     * @param  sort  Optional parameter: The property by which to sort the results. `created` means
     *         when the alert was created. `updated` means when the alert's state last changed.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  page  Optional parameter: **Deprecated**. Page number of the results to fetch. Use
     *         cursor-based pagination with `before` or `after` instead.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  before  Optional parameter: A cursor, as given in the [Link
     *         header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header).
     *         If specified, the query only searches for results before this cursor.
     * @param  after  Optional parameter: A cursor, as given in the [Link
     *         header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header).
     *         If specified, the query only searches for results after this cursor.
     * @param  first  Optional parameter: **Deprecated**. The number of results per page (max 100),
     *         starting from the first matching result. This parameter must not be used in
     *         combination with `last`. Instead, use `per_page` in combination with `after` to fetch
     *         the first page of results.
     * @param  last  Optional parameter: **Deprecated**. The number of results per page (max 100),
     *         starting from the last matching result. This parameter must not be used in
     *         combination with `first`. Instead, use `per_page` in combination with `before` to
     *         fetch the last page of results.
     * @return    Returns the List of DependabotAlert response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<DependabotAlert> dependabotListAlertsForRepo(
            final String owner,
            final String repo,
            final String state,
            final String severity,
            final String ecosystem,
            final String mPackage,
            final String manifest,
            final Scope61Enum scope,
            final Sort18Enum sort,
            final Direction1Enum direction,
            final Integer page,
            final Integer perPage,
            final String before,
            final String after,
            final Integer first,
            final Integer last) throws ApiException, IOException {
        return prepareDependabotListAlertsForRepoRequest(owner, repo, state, severity, ecosystem,
                mPackage, manifest, scope, sort, direction, page, perPage, before, after, first,
                last).execute();
    }

    /**
     * You must use an access token with the `security_events` scope to use this endpoint with
     * private repositories. You can also use tokens with the `public_repo` scope for public
     * repositories only. GitHub Apps must have **Dependabot alerts** read permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  state  Optional parameter: A comma-separated list of states. If specified, only
     *         alerts with these states will be returned. Can be: `dismissed`, `fixed`, `open`
     * @param  severity  Optional parameter: A comma-separated list of severities. If specified,
     *         only alerts with these severities will be returned. Can be: `low`, `medium`, `high`,
     *         `critical`
     * @param  ecosystem  Optional parameter: A comma-separated list of ecosystems. If specified,
     *         only alerts for these ecosystems will be returned. Can be: `composer`, `go`, `maven`,
     *         `npm`, `nuget`, `pip`, `pub`, `rubygems`, `rust`
     * @param  mPackage  Optional parameter: A comma-separated list of package names. If specified,
     *         only alerts for these packages will be returned.
     * @param  manifest  Optional parameter: A comma-separated list of full manifest paths. If
     *         specified, only alerts for these manifests will be returned.
     * @param  scope  Optional parameter: The scope of the vulnerable dependency. If specified, only
     *         alerts with this scope will be returned.
     * @param  sort  Optional parameter: The property by which to sort the results. `created` means
     *         when the alert was created. `updated` means when the alert's state last changed.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @param  page  Optional parameter: **Deprecated**. Page number of the results to fetch. Use
     *         cursor-based pagination with `before` or `after` instead.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  before  Optional parameter: A cursor, as given in the [Link
     *         header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header).
     *         If specified, the query only searches for results before this cursor.
     * @param  after  Optional parameter: A cursor, as given in the [Link
     *         header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header).
     *         If specified, the query only searches for results after this cursor.
     * @param  first  Optional parameter: **Deprecated**. The number of results per page (max 100),
     *         starting from the first matching result. This parameter must not be used in
     *         combination with `last`. Instead, use `per_page` in combination with `after` to fetch
     *         the first page of results.
     * @param  last  Optional parameter: **Deprecated**. The number of results per page (max 100),
     *         starting from the last matching result. This parameter must not be used in
     *         combination with `first`. Instead, use `per_page` in combination with `before` to
     *         fetch the last page of results.
     * @return    Returns the List of DependabotAlert response from the API call
     */
    public CompletableFuture<List<DependabotAlert>> dependabotListAlertsForRepoAsync(
            final String owner,
            final String repo,
            final String state,
            final String severity,
            final String ecosystem,
            final String mPackage,
            final String manifest,
            final Scope61Enum scope,
            final Sort18Enum sort,
            final Direction1Enum direction,
            final Integer page,
            final Integer perPage,
            final String before,
            final String after,
            final Integer first,
            final Integer last) {
        try { 
            return prepareDependabotListAlertsForRepoRequest(owner, repo, state, severity, ecosystem,
            mPackage, manifest, scope, sort, direction, page, perPage, before, after, first,
            last).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotListAlertsForRepo.
     */
    private ApiCall<List<DependabotAlert>, ApiException> prepareDependabotListAlertsForRepoRequest(
            final String owner,
            final String repo,
            final String state,
            final String severity,
            final String ecosystem,
            final String mPackage,
            final String manifest,
            final Scope61Enum scope,
            final Sort18Enum sort,
            final Direction1Enum direction,
            final Integer page,
            final Integer perPage,
            final String before,
            final String after,
            final Integer first,
            final Integer last) throws IOException {
        return new ApiCall.Builder<List<DependabotAlert>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/dependabot/alerts")
                        .queryParam(param -> param.key("state")
                                .value(state).isRequired(false))
                        .queryParam(param -> param.key("severity")
                                .value(severity).isRequired(false))
                        .queryParam(param -> param.key("ecosystem")
                                .value(ecosystem).isRequired(false))
                        .queryParam(param -> param.key("package")
                                .value(mPackage).isRequired(false))
                        .queryParam(param -> param.key("manifest")
                                .value(manifest).isRequired(false))
                        .queryParam(param -> param.key("scope")
                                .value((scope != null) ? scope.value() : null).isRequired(false))
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("before")
                                .value(before).isRequired(false))
                        .queryParam(param -> param.key("after")
                                .value(after).isRequired(false))
                        .queryParam(param -> param.key("first")
                                .value((first != null) ? first : 30).isRequired(false))
                        .queryParam(param -> param.key("last")
                                .value(last).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        DependabotAlert[].class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new ReposDependabotAlerts400ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposDependabotAlerts403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposDependabotAlerts404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposDependabotAlerts422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * You must use an access token with the `security_events` scope to use this endpoint with
     * private repositories. You can also use tokens with the `public_repo` scope for public
     * repositories only. GitHub Apps must have **Dependabot alerts** read permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  alertNumber  Required parameter: The number that identifies a Dependabot alert in its
     *         repository. You can find this at the end of the URL for a Dependabot alert within
     *         GitHub, or in `number` fields in the response from the `GET
     *         /repos/{owner}/{repo}/dependabot/alerts` operation.
     * @return    Returns the ReposDependabotAlertsAlertNumberResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposDependabotAlertsAlertNumberResponse dependabotGetAlert(
            final String owner,
            final String repo,
            final int alertNumber) throws ApiException, IOException {
        return prepareDependabotGetAlertRequest(owner, repo, alertNumber).execute();
    }

    /**
     * You must use an access token with the `security_events` scope to use this endpoint with
     * private repositories. You can also use tokens with the `public_repo` scope for public
     * repositories only. GitHub Apps must have **Dependabot alerts** read permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  alertNumber  Required parameter: The number that identifies a Dependabot alert in its
     *         repository. You can find this at the end of the URL for a Dependabot alert within
     *         GitHub, or in `number` fields in the response from the `GET
     *         /repos/{owner}/{repo}/dependabot/alerts` operation.
     * @return    Returns the ReposDependabotAlertsAlertNumberResponse response from the API call
     */
    public CompletableFuture<ReposDependabotAlertsAlertNumberResponse> dependabotGetAlertAsync(
            final String owner,
            final String repo,
            final int alertNumber) {
        try { 
            return prepareDependabotGetAlertRequest(owner, repo, alertNumber).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotGetAlert.
     */
    private ApiCall<ReposDependabotAlertsAlertNumberResponse, ApiException> prepareDependabotGetAlertRequest(
            final String owner,
            final String repo,
            final int alertNumber) throws IOException {
        return new ApiCall.Builder<ReposDependabotAlertsAlertNumberResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/dependabot/alerts/{alert_number}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("alert_number").value(alertNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposDependabotAlertsAlertNumberResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposDependabotAlertsAlertNumber403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposDependabotAlertsAlertNumber404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * You must use an access token with the `security_events` scope to use this endpoint with
     * private repositories. You can also use tokens with the `public_repo` scope for public
     * repositories only. GitHub Apps must have **Dependabot alerts** write permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  alertNumber  Required parameter: The number that identifies a Dependabot alert in its
     *         repository. You can find this at the end of the URL for a Dependabot alert within
     *         GitHub, or in `number` fields in the response from the `GET
     *         /repos/{owner}/{repo}/dependabot/alerts` operation.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposDependabotAlertsAlertNumberResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposDependabotAlertsAlertNumberResponse dependabotUpdateAlert(
            final String owner,
            final String repo,
            final int alertNumber,
            final ReposDependabotAlertsAlertNumberRequest body) throws ApiException, IOException {
        return prepareDependabotUpdateAlertRequest(owner, repo, alertNumber, body).execute();
    }

    /**
     * You must use an access token with the `security_events` scope to use this endpoint with
     * private repositories. You can also use tokens with the `public_repo` scope for public
     * repositories only. GitHub Apps must have **Dependabot alerts** write permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  alertNumber  Required parameter: The number that identifies a Dependabot alert in its
     *         repository. You can find this at the end of the URL for a Dependabot alert within
     *         GitHub, or in `number` fields in the response from the `GET
     *         /repos/{owner}/{repo}/dependabot/alerts` operation.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposDependabotAlertsAlertNumberResponse response from the API call
     */
    public CompletableFuture<ReposDependabotAlertsAlertNumberResponse> dependabotUpdateAlertAsync(
            final String owner,
            final String repo,
            final int alertNumber,
            final ReposDependabotAlertsAlertNumberRequest body) {
        try { 
            return prepareDependabotUpdateAlertRequest(owner, repo, alertNumber, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotUpdateAlert.
     */
    private ApiCall<ReposDependabotAlertsAlertNumberResponse, ApiException> prepareDependabotUpdateAlertRequest(
            final String owner,
            final String repo,
            final int alertNumber,
            final ReposDependabotAlertsAlertNumberRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposDependabotAlertsAlertNumberResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/dependabot/alerts/{alert_number}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("alert_number").value(alertNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposDependabotAlertsAlertNumberResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new ReposDependabotAlertsAlertNumber400ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposDependabotAlertsAlertNumber403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposDependabotAlertsAlertNumber404ErrorException(reason, context)))
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict",
                                (reason, context) -> new ReposDependabotAlertsAlertNumber409ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposDependabotAlertsAlertNumber422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all secrets available in a repository without revealing their encrypted values. You
     * must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
     * Apps must have the `dependabot_secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposDependabotSecretsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposDependabotSecretsResponse dependabotListRepoSecrets(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareDependabotListRepoSecretsRequest(owner, repo, perPage, page).execute();
    }

    /**
     * Lists all secrets available in a repository without revealing their encrypted values. You
     * must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
     * Apps must have the `dependabot_secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposDependabotSecretsResponse response from the API call
     */
    public CompletableFuture<ReposDependabotSecretsResponse> dependabotListRepoSecretsAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareDependabotListRepoSecretsRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotListRepoSecrets.
     */
    private ApiCall<ReposDependabotSecretsResponse, ApiException> prepareDependabotListRepoSecretsRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposDependabotSecretsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/dependabot/secrets")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposDependabotSecretsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
     * you can create or update secrets. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `dependabot_secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposDependabotSecretsPublicKeyResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposDependabotSecretsPublicKeyResponse dependabotGetRepoPublicKey(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareDependabotGetRepoPublicKeyRequest(owner, repo).execute();
    }

    /**
     * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
     * you can create or update secrets. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `dependabot_secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposDependabotSecretsPublicKeyResponse response from the API call
     */
    public CompletableFuture<ReposDependabotSecretsPublicKeyResponse> dependabotGetRepoPublicKeyAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareDependabotGetRepoPublicKeyRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotGetRepoPublicKey.
     */
    private ApiCall<ReposDependabotSecretsPublicKeyResponse, ApiException> prepareDependabotGetRepoPublicKeyRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposDependabotSecretsPublicKeyResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/dependabot/secrets/public-key")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposDependabotSecretsPublicKeyResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a single repository secret without revealing its encrypted value. You must authenticate
     * using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `dependabot_secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the ReposDependabotSecretsSecretNameResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposDependabotSecretsSecretNameResponse dependabotGetRepoSecret(
            final String owner,
            final String repo,
            final String secretName) throws ApiException, IOException {
        return prepareDependabotGetRepoSecretRequest(owner, repo, secretName).execute();
    }

    /**
     * Gets a single repository secret without revealing its encrypted value. You must authenticate
     * using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `dependabot_secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the ReposDependabotSecretsSecretNameResponse response from the API call
     */
    public CompletableFuture<ReposDependabotSecretsSecretNameResponse> dependabotGetRepoSecretAsync(
            final String owner,
            final String repo,
            final String secretName) {
        try { 
            return prepareDependabotGetRepoSecretRequest(owner, repo, secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotGetRepoSecret.
     */
    private ApiCall<ReposDependabotSecretsSecretNameResponse, ApiException> prepareDependabotGetRepoSecretRequest(
            final String owner,
            final String repo,
            final String secretName) throws IOException {
        return new ApiCall.Builder<ReposDependabotSecretsSecretNameResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/dependabot/secrets/{secret_name}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposDependabotSecretsSecretNameResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates or updates a repository secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `dependabot_secrets` repository permission to use this endpoint. #### Example
     * encrypting a secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example encrypting a secret using Python Encrypt your secret
     * using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with
     * Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example encrypting a
     * secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object dependabotCreateOrUpdateRepoSecret(
            final String owner,
            final String repo,
            final String secretName,
            final ReposDependabotSecretsSecretNameRequest body) throws ApiException, IOException {
        return prepareDependabotCreateOrUpdateRepoSecretRequest(owner, repo, secretName,
                body).execute();
    }

    /**
     * Creates or updates a repository secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `dependabot_secrets` repository permission to use this endpoint. #### Example
     * encrypting a secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example encrypting a secret using Python Encrypt your secret
     * using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with
     * Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example encrypting a
     * secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> dependabotCreateOrUpdateRepoSecretAsync(
            final String owner,
            final String repo,
            final String secretName,
            final ReposDependabotSecretsSecretNameRequest body) {
        try { 
            return prepareDependabotCreateOrUpdateRepoSecretRequest(owner, repo, secretName,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotCreateOrUpdateRepoSecret.
     */
    private ApiCall<Object, ApiException> prepareDependabotCreateOrUpdateRepoSecretRequest(
            final String owner,
            final String repo,
            final String secretName,
            final ReposDependabotSecretsSecretNameRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/dependabot/secrets/{secret_name}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a secret in a repository using the secret name. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `dependabot_secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void dependabotDeleteRepoSecret(
            final String owner,
            final String repo,
            final String secretName) throws ApiException, IOException {
        prepareDependabotDeleteRepoSecretRequest(owner, repo, secretName).execute();
    }

    /**
     * Deletes a secret in a repository using the secret name. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `dependabot_secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> dependabotDeleteRepoSecretAsync(
            final String owner,
            final String repo,
            final String secretName) {
        try { 
            return prepareDependabotDeleteRepoSecretRequest(owner, repo, secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for dependabotDeleteRepoSecret.
     */
    private ApiCall<Void, ApiException> prepareDependabotDeleteRepoSecretRequest(
            final String owner,
            final String repo,
            final String secretName) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/dependabot/secrets/{secret_name}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}