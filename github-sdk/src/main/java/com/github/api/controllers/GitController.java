/*
 * GitHubAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.github.api.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.github.api.ApiHelper;
import com.github.api.Server;
import com.github.api.exceptions.ApiException;
import com.github.api.exceptions.ReposGitBlobs403ErrorException;
import com.github.api.exceptions.ReposGitBlobs404ErrorException;
import com.github.api.exceptions.ReposGitBlobs409ErrorException;
import com.github.api.exceptions.ReposGitBlobs422ErrorException;
import com.github.api.exceptions.ReposGitBlobsFileSha403ErrorException;
import com.github.api.exceptions.ReposGitBlobsFileSha404ErrorException;
import com.github.api.exceptions.ReposGitBlobsFileSha422ErrorException;
import com.github.api.exceptions.ReposGitCommits404ErrorException;
import com.github.api.exceptions.ReposGitCommits422ErrorException;
import com.github.api.exceptions.ReposGitCommitsCommitSha404ErrorException;
import com.github.api.exceptions.ReposGitRefRef404ErrorException;
import com.github.api.exceptions.ReposGitRefs422ErrorException;
import com.github.api.exceptions.ReposGitRefsRef422ErrorException;
import com.github.api.exceptions.ReposGitTags422ErrorException;
import com.github.api.exceptions.ReposGitTagsTagSha404ErrorException;
import com.github.api.exceptions.ReposGitTrees403ErrorException;
import com.github.api.exceptions.ReposGitTrees404ErrorException;
import com.github.api.exceptions.ReposGitTrees422ErrorException;
import com.github.api.exceptions.ReposGitTreesTreeSha404ErrorException;
import com.github.api.exceptions.ReposGitTreesTreeSha422ErrorException;
import com.github.api.http.request.HttpMethod;
import com.github.api.models.Commit3;
import com.github.api.models.GitReference;
import com.github.api.models.ReposGitBlobsFileShaResponse;
import com.github.api.models.ReposGitBlobsRequest;
import com.github.api.models.ReposGitCommitsCommitShaResponse;
import com.github.api.models.ReposGitCommitsRequest;
import com.github.api.models.ReposGitCommitsResponse;
import com.github.api.models.ReposGitRefRefResponse;
import com.github.api.models.ReposGitRefsRefRequest;
import com.github.api.models.ReposGitRefsRefResponse;
import com.github.api.models.ReposGitRefsRequest;
import com.github.api.models.ReposGitRefsResponse;
import com.github.api.models.ReposGitTagsRequest;
import com.github.api.models.ReposGitTagsResponse;
import com.github.api.models.ReposGitTagsTagShaResponse;
import com.github.api.models.ReposGitTreesRequest;
import com.github.api.models.ReposGitTreesResponse;
import com.github.api.models.ReposGitTreesTreeShaResponse;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class GitController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public GitController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Create a blob.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the Commit3 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Commit3 gitCreateBlob(
            final String owner,
            final String repo,
            final ReposGitBlobsRequest body) throws ApiException, IOException {
        return prepareGitCreateBlobRequest(owner, repo, body).execute();
    }

    /**
     * Create a blob.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the Commit3 response from the API call
     */
    public CompletableFuture<Commit3> gitCreateBlobAsync(
            final String owner,
            final String repo,
            final ReposGitBlobsRequest body) {
        try { 
            return prepareGitCreateBlobRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for gitCreateBlob.
     */
    private ApiCall<Commit3, ApiException> prepareGitCreateBlobRequest(
            final String owner,
            final String repo,
            final ReposGitBlobsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Commit3, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/git/blobs")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, Commit3.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposGitBlobs403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposGitBlobs404ErrorException(reason, context)))
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict",
                                (reason, context) -> new ReposGitBlobs409ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposGitBlobs422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * The `content` in the response will always be Base64 encoded. _Note_: This API supports blobs
     * up to 100 megabytes in size.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  fileSha  Required parameter: Example:
     * @return    Returns the ReposGitBlobsFileShaResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposGitBlobsFileShaResponse gitGetBlob(
            final String owner,
            final String repo,
            final String fileSha) throws ApiException, IOException {
        return prepareGitGetBlobRequest(owner, repo, fileSha).execute();
    }

    /**
     * The `content` in the response will always be Base64 encoded. _Note_: This API supports blobs
     * up to 100 megabytes in size.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  fileSha  Required parameter: Example:
     * @return    Returns the ReposGitBlobsFileShaResponse response from the API call
     */
    public CompletableFuture<ReposGitBlobsFileShaResponse> gitGetBlobAsync(
            final String owner,
            final String repo,
            final String fileSha) {
        try { 
            return prepareGitGetBlobRequest(owner, repo, fileSha).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for gitGetBlob.
     */
    private ApiCall<ReposGitBlobsFileShaResponse, ApiException> prepareGitGetBlobRequest(
            final String owner,
            final String repo,
            final String fileSha) throws IOException {
        return new ApiCall.Builder<ReposGitBlobsFileShaResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/git/blobs/{file_sha}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("file_sha").value(fileSha)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposGitBlobsFileShaResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposGitBlobsFileSha403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposGitBlobsFileSha404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposGitBlobsFileSha422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates a new Git [commit
     * object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects). **Signature
     * verification object** The response will include a `verification` object that describes the
     * result of verifying the commit's signature. The following fields are included in the
     * `verification` object: | Name | Type | Description | | ---- | ---- | ----------- | |
     * `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to
     * be verified. | | `reason` | `string` | The reason for verified value. Possible values and
     * their meanings are enumerated in the table below. | | `signature` | `string` | The signature
     * that was extracted from the commit. | | `payload` | `string` | The value that was signed. |
     * These are the possible values for `reason` in the `verification` object: | Value |
     * Description | | ----- | ----------- | | `expired_key` | The key that made the signature is
     * expired. | | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG
     * key that made the signature. | | `gpgverify_error` | There was an error communicating with
     * the signature verification service. | | `gpgverify_unavailable` | The signature verification
     * service is currently unavailable. | | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No
     * user was associated with the `committer` email address in the commit. | | `unverified_email`
     * | The `committer` email address in the commit was associated with a user, but the email
     * address is not verified on her/his account. | | `bad_email` | The `committer` email address
     * in the commit is not included in the identities of the PGP key that made the signature. | |
     * `unknown_key` | The key that made the signature has not been registered with any user's
     * account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid`
     * | The signature could not be cryptographically verified using the key whose key-id was found
     * in the signature. | | `valid` | None of the above errors applied, so the signature is
     * considered to be verified. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposGitCommitsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposGitCommitsResponse gitCreateCommit(
            final String owner,
            final String repo,
            final ReposGitCommitsRequest body) throws ApiException, IOException {
        return prepareGitCreateCommitRequest(owner, repo, body).execute();
    }

    /**
     * Creates a new Git [commit
     * object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects). **Signature
     * verification object** The response will include a `verification` object that describes the
     * result of verifying the commit's signature. The following fields are included in the
     * `verification` object: | Name | Type | Description | | ---- | ---- | ----------- | |
     * `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to
     * be verified. | | `reason` | `string` | The reason for verified value. Possible values and
     * their meanings are enumerated in the table below. | | `signature` | `string` | The signature
     * that was extracted from the commit. | | `payload` | `string` | The value that was signed. |
     * These are the possible values for `reason` in the `verification` object: | Value |
     * Description | | ----- | ----------- | | `expired_key` | The key that made the signature is
     * expired. | | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG
     * key that made the signature. | | `gpgverify_error` | There was an error communicating with
     * the signature verification service. | | `gpgverify_unavailable` | The signature verification
     * service is currently unavailable. | | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No
     * user was associated with the `committer` email address in the commit. | | `unverified_email`
     * | The `committer` email address in the commit was associated with a user, but the email
     * address is not verified on her/his account. | | `bad_email` | The `committer` email address
     * in the commit is not included in the identities of the PGP key that made the signature. | |
     * `unknown_key` | The key that made the signature has not been registered with any user's
     * account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid`
     * | The signature could not be cryptographically verified using the key whose key-id was found
     * in the signature. | | `valid` | None of the above errors applied, so the signature is
     * considered to be verified. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposGitCommitsResponse response from the API call
     */
    public CompletableFuture<ReposGitCommitsResponse> gitCreateCommitAsync(
            final String owner,
            final String repo,
            final ReposGitCommitsRequest body) {
        try { 
            return prepareGitCreateCommitRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for gitCreateCommit.
     */
    private ApiCall<ReposGitCommitsResponse, ApiException> prepareGitCreateCommitRequest(
            final String owner,
            final String repo,
            final ReposGitCommitsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposGitCommitsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/git/commits")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposGitCommitsResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposGitCommits404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposGitCommits422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a Git [commit
     * object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects). **Signature
     * verification object** The response will include a `verification` object that describes the
     * result of verifying the commit's signature. The following fields are included in the
     * `verification` object: | Name | Type | Description | | ---- | ---- | ----------- | |
     * `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to
     * be verified. | | `reason` | `string` | The reason for verified value. Possible values and
     * their meanings are enumerated in the table below. | | `signature` | `string` | The signature
     * that was extracted from the commit. | | `payload` | `string` | The value that was signed. |
     * These are the possible values for `reason` in the `verification` object: | Value |
     * Description | | ----- | ----------- | | `expired_key` | The key that made the signature is
     * expired. | | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG
     * key that made the signature. | | `gpgverify_error` | There was an error communicating with
     * the signature verification service. | | `gpgverify_unavailable` | The signature verification
     * service is currently unavailable. | | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No
     * user was associated with the `committer` email address in the commit. | | `unverified_email`
     * | The `committer` email address in the commit was associated with a user, but the email
     * address is not verified on her/his account. | | `bad_email` | The `committer` email address
     * in the commit is not included in the identities of the PGP key that made the signature. | |
     * `unknown_key` | The key that made the signature has not been registered with any user's
     * account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid`
     * | The signature could not be cryptographically verified using the key whose key-id was found
     * in the signature. | | `valid` | None of the above errors applied, so the signature is
     * considered to be verified. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commitSha  Required parameter: The SHA of the commit.
     * @return    Returns the ReposGitCommitsCommitShaResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposGitCommitsCommitShaResponse gitGetCommit(
            final String owner,
            final String repo,
            final String commitSha) throws ApiException, IOException {
        return prepareGitGetCommitRequest(owner, repo, commitSha).execute();
    }

    /**
     * Gets a Git [commit
     * object](https://git-scm.com/book/en/v1/Git-Internals-Git-Objects#Commit-Objects). **Signature
     * verification object** The response will include a `verification` object that describes the
     * result of verifying the commit's signature. The following fields are included in the
     * `verification` object: | Name | Type | Description | | ---- | ---- | ----------- | |
     * `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to
     * be verified. | | `reason` | `string` | The reason for verified value. Possible values and
     * their meanings are enumerated in the table below. | | `signature` | `string` | The signature
     * that was extracted from the commit. | | `payload` | `string` | The value that was signed. |
     * These are the possible values for `reason` in the `verification` object: | Value |
     * Description | | ----- | ----------- | | `expired_key` | The key that made the signature is
     * expired. | | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG
     * key that made the signature. | | `gpgverify_error` | There was an error communicating with
     * the signature verification service. | | `gpgverify_unavailable` | The signature verification
     * service is currently unavailable. | | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No
     * user was associated with the `committer` email address in the commit. | | `unverified_email`
     * | The `committer` email address in the commit was associated with a user, but the email
     * address is not verified on her/his account. | | `bad_email` | The `committer` email address
     * in the commit is not included in the identities of the PGP key that made the signature. | |
     * `unknown_key` | The key that made the signature has not been registered with any user's
     * account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid`
     * | The signature could not be cryptographically verified using the key whose key-id was found
     * in the signature. | | `valid` | None of the above errors applied, so the signature is
     * considered to be verified. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  commitSha  Required parameter: The SHA of the commit.
     * @return    Returns the ReposGitCommitsCommitShaResponse response from the API call
     */
    public CompletableFuture<ReposGitCommitsCommitShaResponse> gitGetCommitAsync(
            final String owner,
            final String repo,
            final String commitSha) {
        try { 
            return prepareGitGetCommitRequest(owner, repo, commitSha).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for gitGetCommit.
     */
    private ApiCall<ReposGitCommitsCommitShaResponse, ApiException> prepareGitGetCommitRequest(
            final String owner,
            final String repo,
            final String commitSha) throws IOException {
        return new ApiCall.Builder<ReposGitCommitsCommitShaResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/git/commits/{commit_sha}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("commit_sha").value(commitSha)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposGitCommitsCommitShaResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposGitCommitsCommitSha404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns an array of references from your Git database that match the supplied name. The
     * `:ref` in the URL must be formatted as `heads/&lt;branch name&gt;` for branches and `tags/&lt;tag
     * name&gt;` for tags. If the `:ref` doesn't exist in the repository, but existing refs start with
     * `:ref`, they will be returned as an array. When you use this endpoint without providing a
     * `:ref`, it will return an array of all the references from your Git database, including notes
     * and stashes if they exist on the server. Anything in the namespace is returned, not just
     * `heads` and `tags`. **Note:** You need to explicitly [request a pull
     * request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) to trigger a test
     * merge commit, which checks the mergeability of pull requests. For more information, see
     * "[Checking mergeability of pull
     * requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
     * If you request matching references for a branch named `feature` but the branch `feature`
     * doesn't exist, the response can still include other matching head refs that start with the
     * word `feature`, such as `featureA` and `featureB`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: ref parameter
     * @return    Returns the List of GitReference response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<GitReference> gitListMatchingRefs(
            final String owner,
            final String repo,
            final String ref) throws ApiException, IOException {
        return prepareGitListMatchingRefsRequest(owner, repo, ref).execute();
    }

    /**
     * Returns an array of references from your Git database that match the supplied name. The
     * `:ref` in the URL must be formatted as `heads/&lt;branch name&gt;` for branches and `tags/&lt;tag
     * name&gt;` for tags. If the `:ref` doesn't exist in the repository, but existing refs start with
     * `:ref`, they will be returned as an array. When you use this endpoint without providing a
     * `:ref`, it will return an array of all the references from your Git database, including notes
     * and stashes if they exist on the server. Anything in the namespace is returned, not just
     * `heads` and `tags`. **Note:** You need to explicitly [request a pull
     * request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) to trigger a test
     * merge commit, which checks the mergeability of pull requests. For more information, see
     * "[Checking mergeability of pull
     * requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
     * If you request matching references for a branch named `feature` but the branch `feature`
     * doesn't exist, the response can still include other matching head refs that start with the
     * word `feature`, such as `featureA` and `featureB`.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: ref parameter
     * @return    Returns the List of GitReference response from the API call
     */
    public CompletableFuture<List<GitReference>> gitListMatchingRefsAsync(
            final String owner,
            final String repo,
            final String ref) {
        try { 
            return prepareGitListMatchingRefsRequest(owner, repo, ref).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for gitListMatchingRefs.
     */
    private ApiCall<List<GitReference>, ApiException> prepareGitListMatchingRefsRequest(
            final String owner,
            final String repo,
            final String ref) throws IOException {
        return new ApiCall.Builder<List<GitReference>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/git/matching-refs/{ref}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("ref").value(ref)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        GitReference[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns a single reference from your Git database. The `:ref` in the URL must be formatted as
     * `heads/&lt;branch name&gt;` for branches and `tags/&lt;tag name&gt;` for tags. If the `:ref` doesn't
     * match an existing ref, a `404` is returned. **Note:** You need to explicitly [request a pull
     * request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) to trigger a test
     * merge commit, which checks the mergeability of pull requests. For more information, see
     * "[Checking mergeability of pull
     * requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: ref parameter
     * @return    Returns the ReposGitRefRefResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposGitRefRefResponse gitGetRef(
            final String owner,
            final String repo,
            final String ref) throws ApiException, IOException {
        return prepareGitGetRefRequest(owner, repo, ref).execute();
    }

    /**
     * Returns a single reference from your Git database. The `:ref` in the URL must be formatted as
     * `heads/&lt;branch name&gt;` for branches and `tags/&lt;tag name&gt;` for tags. If the `:ref` doesn't
     * match an existing ref, a `404` is returned. **Note:** You need to explicitly [request a pull
     * request](https://docs.github.com/rest/reference/pulls#get-a-pull-request) to trigger a test
     * merge commit, which checks the mergeability of pull requests. For more information, see
     * "[Checking mergeability of pull
     * requests](https://docs.github.com/rest/guides/getting-started-with-the-git-database-api#checking-mergeability-of-pull-requests)".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: ref parameter
     * @return    Returns the ReposGitRefRefResponse response from the API call
     */
    public CompletableFuture<ReposGitRefRefResponse> gitGetRefAsync(
            final String owner,
            final String repo,
            final String ref) {
        try { 
            return prepareGitGetRefRequest(owner, repo, ref).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for gitGetRef.
     */
    private ApiCall<ReposGitRefRefResponse, ApiException> prepareGitGetRefRequest(
            final String owner,
            final String repo,
            final String ref) throws IOException {
        return new ApiCall.Builder<ReposGitRefRefResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/git/ref/{ref}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("ref").value(ref)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposGitRefRefResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposGitRefRef404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates a reference for your repository. You are unable to create new references for empty
     * repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories
     * without branches.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposGitRefsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposGitRefsResponse gitCreateRef(
            final String owner,
            final String repo,
            final ReposGitRefsRequest body) throws ApiException, IOException {
        return prepareGitCreateRefRequest(owner, repo, body).execute();
    }

    /**
     * Creates a reference for your repository. You are unable to create new references for empty
     * repositories, even if the commit SHA-1 hash used exists. Empty repositories are repositories
     * without branches.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposGitRefsResponse response from the API call
     */
    public CompletableFuture<ReposGitRefsResponse> gitCreateRefAsync(
            final String owner,
            final String repo,
            final ReposGitRefsRequest body) {
        try { 
            return prepareGitCreateRefRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for gitCreateRef.
     */
    private ApiCall<ReposGitRefsResponse, ApiException> prepareGitCreateRefRequest(
            final String owner,
            final String repo,
            final ReposGitRefsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposGitRefsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/git/refs")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposGitRefsResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposGitRefs422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Update a reference.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: The name of the fully qualified reference to update. For
     *         example, `refs/heads/master`. If the value doesn't start with `refs` and have at
     *         least two slashes, it will be rejected.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposGitRefsRefResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposGitRefsRefResponse gitUpdateRef(
            final String owner,
            final String repo,
            final String ref,
            final ReposGitRefsRefRequest body) throws ApiException, IOException {
        return prepareGitUpdateRefRequest(owner, repo, ref, body).execute();
    }

    /**
     * Update a reference.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: The name of the fully qualified reference to update. For
     *         example, `refs/heads/master`. If the value doesn't start with `refs` and have at
     *         least two slashes, it will be rejected.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposGitRefsRefResponse response from the API call
     */
    public CompletableFuture<ReposGitRefsRefResponse> gitUpdateRefAsync(
            final String owner,
            final String repo,
            final String ref,
            final ReposGitRefsRefRequest body) {
        try { 
            return prepareGitUpdateRefRequest(owner, repo, ref, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for gitUpdateRef.
     */
    private ApiCall<ReposGitRefsRefResponse, ApiException> prepareGitUpdateRefRequest(
            final String owner,
            final String repo,
            final String ref,
            final ReposGitRefsRefRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposGitRefsRefResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/git/refs/{ref}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("ref").value(ref)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposGitRefsRefResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposGitRefsRef422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Delete a reference.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: ref parameter
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void gitDeleteRef(
            final String owner,
            final String repo,
            final String ref) throws ApiException, IOException {
        prepareGitDeleteRefRequest(owner, repo, ref).execute();
    }

    /**
     * Delete a reference.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  ref  Required parameter: ref parameter
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> gitDeleteRefAsync(
            final String owner,
            final String repo,
            final String ref) {
        try { 
            return prepareGitDeleteRefRequest(owner, repo, ref).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for gitDeleteRef.
     */
    private ApiCall<Void, ApiException> prepareGitDeleteRefRequest(
            final String owner,
            final String repo,
            final String ref) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/git/refs/{ref}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("ref").value(ref)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposGitRefsRef422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Note that creating a tag object does not create the reference that makes a tag in Git. If you
     * want to create an annotated tag in Git, you have to do this call to create the tag object,
     * and then [create](https://docs.github.com/rest/reference/git#create-a-reference) the
     * `refs/tags/[tag]` reference. If you want to create a lightweight tag, you only have to
     * [create](https://docs.github.com/rest/reference/git#create-a-reference) the tag reference -
     * this call would be unnecessary. **Signature verification object** The response will include a
     * `verification` object that describes the result of verifying the commit's signature. The
     * following fields are included in the `verification` object: | Name | Type | Description | |
     * ---- | ---- | ----------- | | `verified` | `boolean` | Indicates whether GitHub considers the
     * signature in this commit to be verified. | | `reason` | `string` | The reason for verified
     * value. Possible values and their meanings are enumerated in table below. | | `signature` |
     * `string` | The signature that was extracted from the commit. | | `payload` | `string` | The
     * value that was signed. | These are the possible values for `reason` in the `verification`
     * object: | Value | Description | | ----- | ----------- | | `expired_key` | The key that made
     * the signature is expired. | | `not_signing_key` | The "signing" flag is not among the usage
     * flags in the GPG key that made the signature. | | `gpgverify_error` | There was an error
     * communicating with the signature verification service. | | `gpgverify_unavailable` | The
     * signature verification service is currently unavailable. | | `unsigned` | The object does not
     * include a signature. | | `unknown_signature_type` | A non-PGP signature was found in the
     * commit. | | `no_user` | No user was associated with the `committer` email address in the
     * commit. | | `unverified_email` | The `committer` email address in the commit was associated
     * with a user, but the email address is not verified on her/his account. | | `bad_email` | The
     * `committer` email address in the commit is not included in the identities of the PGP key that
     * made the signature. | | `unknown_key` | The key that made the signature has not been
     * registered with any user's account. | | `malformed_signature` | There was an error parsing
     * the signature. | | `invalid` | The signature could not be cryptographically verified using
     * the key whose key-id was found in the signature. | | `valid` | None of the above errors
     * applied, so the signature is considered to be verified. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposGitTagsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposGitTagsResponse gitCreateTag(
            final String owner,
            final String repo,
            final ReposGitTagsRequest body) throws ApiException, IOException {
        return prepareGitCreateTagRequest(owner, repo, body).execute();
    }

    /**
     * Note that creating a tag object does not create the reference that makes a tag in Git. If you
     * want to create an annotated tag in Git, you have to do this call to create the tag object,
     * and then [create](https://docs.github.com/rest/reference/git#create-a-reference) the
     * `refs/tags/[tag]` reference. If you want to create a lightweight tag, you only have to
     * [create](https://docs.github.com/rest/reference/git#create-a-reference) the tag reference -
     * this call would be unnecessary. **Signature verification object** The response will include a
     * `verification` object that describes the result of verifying the commit's signature. The
     * following fields are included in the `verification` object: | Name | Type | Description | |
     * ---- | ---- | ----------- | | `verified` | `boolean` | Indicates whether GitHub considers the
     * signature in this commit to be verified. | | `reason` | `string` | The reason for verified
     * value. Possible values and their meanings are enumerated in table below. | | `signature` |
     * `string` | The signature that was extracted from the commit. | | `payload` | `string` | The
     * value that was signed. | These are the possible values for `reason` in the `verification`
     * object: | Value | Description | | ----- | ----------- | | `expired_key` | The key that made
     * the signature is expired. | | `not_signing_key` | The "signing" flag is not among the usage
     * flags in the GPG key that made the signature. | | `gpgverify_error` | There was an error
     * communicating with the signature verification service. | | `gpgverify_unavailable` | The
     * signature verification service is currently unavailable. | | `unsigned` | The object does not
     * include a signature. | | `unknown_signature_type` | A non-PGP signature was found in the
     * commit. | | `no_user` | No user was associated with the `committer` email address in the
     * commit. | | `unverified_email` | The `committer` email address in the commit was associated
     * with a user, but the email address is not verified on her/his account. | | `bad_email` | The
     * `committer` email address in the commit is not included in the identities of the PGP key that
     * made the signature. | | `unknown_key` | The key that made the signature has not been
     * registered with any user's account. | | `malformed_signature` | There was an error parsing
     * the signature. | | `invalid` | The signature could not be cryptographically verified using
     * the key whose key-id was found in the signature. | | `valid` | None of the above errors
     * applied, so the signature is considered to be verified. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposGitTagsResponse response from the API call
     */
    public CompletableFuture<ReposGitTagsResponse> gitCreateTagAsync(
            final String owner,
            final String repo,
            final ReposGitTagsRequest body) {
        try { 
            return prepareGitCreateTagRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for gitCreateTag.
     */
    private ApiCall<ReposGitTagsResponse, ApiException> prepareGitCreateTagRequest(
            final String owner,
            final String repo,
            final ReposGitTagsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposGitTagsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/git/tags")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposGitTagsResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposGitTags422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * **Signature verification object** The response will include a `verification` object that
     * describes the result of verifying the commit's signature. The following fields are included
     * in the `verification` object: | Name | Type | Description | | ---- | ---- | ----------- | |
     * `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to
     * be verified. | | `reason` | `string` | The reason for verified value. Possible values and
     * their meanings are enumerated in table below. | | `signature` | `string` | The signature that
     * was extracted from the commit. | | `payload` | `string` | The value that was signed. | These
     * are the possible values for `reason` in the `verification` object: | Value | Description | |
     * ----- | ----------- | | `expired_key` | The key that made the signature is expired. | |
     * `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made
     * the signature. | | `gpgverify_error` | There was an error communicating with the signature
     * verification service. | | `gpgverify_unavailable` | The signature verification service is
     * currently unavailable. | | `unsigned` | The object does not include a signature. | |
     * `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No
     * user was associated with the `committer` email address in the commit. | | `unverified_email`
     * | The `committer` email address in the commit was associated with a user, but the email
     * address is not verified on her/his account. | | `bad_email` | The `committer` email address
     * in the commit is not included in the identities of the PGP key that made the signature. | |
     * `unknown_key` | The key that made the signature has not been registered with any user's
     * account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid`
     * | The signature could not be cryptographically verified using the key whose key-id was found
     * in the signature. | | `valid` | None of the above errors applied, so the signature is
     * considered to be verified. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  tagSha  Required parameter: Example:
     * @return    Returns the ReposGitTagsTagShaResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposGitTagsTagShaResponse gitGetTag(
            final String owner,
            final String repo,
            final String tagSha) throws ApiException, IOException {
        return prepareGitGetTagRequest(owner, repo, tagSha).execute();
    }

    /**
     * **Signature verification object** The response will include a `verification` object that
     * describes the result of verifying the commit's signature. The following fields are included
     * in the `verification` object: | Name | Type | Description | | ---- | ---- | ----------- | |
     * `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to
     * be verified. | | `reason` | `string` | The reason for verified value. Possible values and
     * their meanings are enumerated in table below. | | `signature` | `string` | The signature that
     * was extracted from the commit. | | `payload` | `string` | The value that was signed. | These
     * are the possible values for `reason` in the `verification` object: | Value | Description | |
     * ----- | ----------- | | `expired_key` | The key that made the signature is expired. | |
     * `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made
     * the signature. | | `gpgverify_error` | There was an error communicating with the signature
     * verification service. | | `gpgverify_unavailable` | The signature verification service is
     * currently unavailable. | | `unsigned` | The object does not include a signature. | |
     * `unknown_signature_type` | A non-PGP signature was found in the commit. | | `no_user` | No
     * user was associated with the `committer` email address in the commit. | | `unverified_email`
     * | The `committer` email address in the commit was associated with a user, but the email
     * address is not verified on her/his account. | | `bad_email` | The `committer` email address
     * in the commit is not included in the identities of the PGP key that made the signature. | |
     * `unknown_key` | The key that made the signature has not been registered with any user's
     * account. | | `malformed_signature` | There was an error parsing the signature. | | `invalid`
     * | The signature could not be cryptographically verified using the key whose key-id was found
     * in the signature. | | `valid` | None of the above errors applied, so the signature is
     * considered to be verified. |.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  tagSha  Required parameter: Example:
     * @return    Returns the ReposGitTagsTagShaResponse response from the API call
     */
    public CompletableFuture<ReposGitTagsTagShaResponse> gitGetTagAsync(
            final String owner,
            final String repo,
            final String tagSha) {
        try { 
            return prepareGitGetTagRequest(owner, repo, tagSha).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for gitGetTag.
     */
    private ApiCall<ReposGitTagsTagShaResponse, ApiException> prepareGitGetTagRequest(
            final String owner,
            final String repo,
            final String tagSha) throws IOException {
        return new ApiCall.Builder<ReposGitTagsTagShaResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/git/tags/{tag_sha}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("tag_sha").value(tagSha)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposGitTagsTagShaResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposGitTagsTagSha404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * The tree creation API accepts nested entries. If you specify both a tree and a nested path
     * modifying that tree, this endpoint will overwrite the contents of the tree with the new path
     * contents, and create a new tree structure. If you use this endpoint to add, delete, or modify
     * the file contents in a tree, you will need to commit the tree and then update a branch to
     * point to the commit. For more information see "[Create a
     * commit](https://docs.github.com/rest/reference/git#create-a-commit)" and "[Update a
     * reference](https://docs.github.com/rest/reference/git#update-a-reference)." Returns an error
     * if you try to delete a file that does not exist.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposGitTreesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposGitTreesResponse gitCreateTree(
            final String owner,
            final String repo,
            final ReposGitTreesRequest body) throws ApiException, IOException {
        return prepareGitCreateTreeRequest(owner, repo, body).execute();
    }

    /**
     * The tree creation API accepts nested entries. If you specify both a tree and a nested path
     * modifying that tree, this endpoint will overwrite the contents of the tree with the new path
     * contents, and create a new tree structure. If you use this endpoint to add, delete, or modify
     * the file contents in a tree, you will need to commit the tree and then update a branch to
     * point to the commit. For more information see "[Create a
     * commit](https://docs.github.com/rest/reference/git#create-a-commit)" and "[Update a
     * reference](https://docs.github.com/rest/reference/git#update-a-reference)." Returns an error
     * if you try to delete a file that does not exist.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposGitTreesResponse response from the API call
     */
    public CompletableFuture<ReposGitTreesResponse> gitCreateTreeAsync(
            final String owner,
            final String repo,
            final ReposGitTreesRequest body) {
        try { 
            return prepareGitCreateTreeRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for gitCreateTree.
     */
    private ApiCall<ReposGitTreesResponse, ApiException> prepareGitCreateTreeRequest(
            final String owner,
            final String repo,
            final ReposGitTreesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposGitTreesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/git/trees")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposGitTreesResponse.class))
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposGitTrees403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposGitTrees404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposGitTrees422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns a single tree using the SHA1 value for that tree. If `truncated` is `true` in the
     * response then the number of items in the `tree` array exceeded our maximum limit. If you need
     * to fetch more items, use the non-recursive method of fetching trees, and fetch one sub-tree
     * at a time. **Note**: The limit for the `tree` array is 100,000 entries with a maximum size of
     * 7 MB when using the `recursive` parameter.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  treeSha  Required parameter: Example:
     * @param  recursive  Optional parameter: Setting this parameter to any value returns the
     *         objects or subtrees referenced by the tree specified in `:tree_sha`. For example,
     *         setting `recursive` to any of the following will enable returning objects or
     *         subtrees: `0`, `1`, `"true"`, and `"false"`. Omit this parameter to prevent
     *         recursively returning objects or subtrees.
     * @return    Returns the ReposGitTreesTreeShaResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposGitTreesTreeShaResponse gitGetTree(
            final String owner,
            final String repo,
            final String treeSha,
            final String recursive) throws ApiException, IOException {
        return prepareGitGetTreeRequest(owner, repo, treeSha, recursive).execute();
    }

    /**
     * Returns a single tree using the SHA1 value for that tree. If `truncated` is `true` in the
     * response then the number of items in the `tree` array exceeded our maximum limit. If you need
     * to fetch more items, use the non-recursive method of fetching trees, and fetch one sub-tree
     * at a time. **Note**: The limit for the `tree` array is 100,000 entries with a maximum size of
     * 7 MB when using the `recursive` parameter.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  treeSha  Required parameter: Example:
     * @param  recursive  Optional parameter: Setting this parameter to any value returns the
     *         objects or subtrees referenced by the tree specified in `:tree_sha`. For example,
     *         setting `recursive` to any of the following will enable returning objects or
     *         subtrees: `0`, `1`, `"true"`, and `"false"`. Omit this parameter to prevent
     *         recursively returning objects or subtrees.
     * @return    Returns the ReposGitTreesTreeShaResponse response from the API call
     */
    public CompletableFuture<ReposGitTreesTreeShaResponse> gitGetTreeAsync(
            final String owner,
            final String repo,
            final String treeSha,
            final String recursive) {
        try { 
            return prepareGitGetTreeRequest(owner, repo, treeSha, recursive).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for gitGetTree.
     */
    private ApiCall<ReposGitTreesTreeShaResponse, ApiException> prepareGitGetTreeRequest(
            final String owner,
            final String repo,
            final String treeSha,
            final String recursive) throws IOException {
        return new ApiCall.Builder<ReposGitTreesTreeShaResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/git/trees/{tree_sha}")
                        .queryParam(param -> param.key("recursive")
                                .value(recursive).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("tree_sha").value(treeSha)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposGitTreesTreeShaResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposGitTreesTreeSha404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposGitTreesTreeSha422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}