/*
 * GitHubAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.github.api.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.github.api.ApiHelper;
import com.github.api.DateTimeHelper;
import com.github.api.Server;
import com.github.api.exceptions.ApiException;
import com.github.api.exceptions.OrgsActionsRequiredWorkflows422ErrorException;
import com.github.api.exceptions.OrgsActionsRunnersLabels404ErrorException;
import com.github.api.exceptions.OrgsActionsRunnersLabels422ErrorException;
import com.github.api.exceptions.OrgsActionsRunnersLabelsName404ErrorException;
import com.github.api.exceptions.OrgsActionsRunnersLabelsName422ErrorException;
import com.github.api.exceptions.ReposActionsArtifactsArtifactIdArchiveFormat410ErrorException;
import com.github.api.exceptions.ReposActionsJobsJobIdRerun403ErrorException;
import com.github.api.exceptions.ReposActionsOidcCustomizationSub400ErrorException;
import com.github.api.exceptions.ReposActionsOidcCustomizationSub404ErrorException;
import com.github.api.exceptions.ReposActionsOidcCustomizationSub422ErrorException;
import com.github.api.exceptions.ReposActionsRequiredWorkflows404ErrorException;
import com.github.api.exceptions.ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepo404ErrorException;
import com.github.api.exceptions.ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoTiming404ErrorException;
import com.github.api.exceptions.ReposActionsRunnersRunnerIdLabels404ErrorException;
import com.github.api.exceptions.ReposActionsRunnersRunnerIdLabels422ErrorException;
import com.github.api.exceptions.ReposActionsRunnersRunnerIdLabelsName404ErrorException;
import com.github.api.exceptions.ReposActionsRunnersRunnerIdLabelsName422ErrorException;
import com.github.api.exceptions.ReposActionsRunsRunIdApprove403ErrorException;
import com.github.api.exceptions.ReposActionsRunsRunIdApprove404ErrorException;
import com.github.api.exceptions.ReposActionsRunsRunIdAttemptsAttemptNumberJobs404ErrorException;
import com.github.api.exceptions.ReposActionsRunsRunIdCancel409ErrorException;
import com.github.api.exceptions.ReposActionsRunsRunIdLogs403ErrorException;
import com.github.api.exceptions.ReposActionsRunsRunIdLogs500ErrorException;
import com.github.api.http.request.HttpMethod;
import com.github.api.models.ActionsCacheUsageOrgEnterprise;
import com.github.api.models.ActionsGetDefaultWorkflowPermissions;
import com.github.api.models.ActionsOrganizationPermissions;
import com.github.api.models.ActionsRepositoryPermissions;
import com.github.api.models.ActionsRunnerLabels;
import com.github.api.models.ActionsSetDefaultWorkflowPermissions;
import com.github.api.models.ActionsVariable;
import com.github.api.models.ActionsWorkflowAccessToRepository;
import com.github.api.models.Deployment;
import com.github.api.models.Direction1Enum;
import com.github.api.models.EnterprisesActionsRunnersLabelsRequest;
import com.github.api.models.EnvironmentApproval;
import com.github.api.models.Filter41Enum;
import com.github.api.models.OrgsActionsCacheUsageByRepositoryResponse;
import com.github.api.models.OrgsActionsPermissionsRepositoriesRequest;
import com.github.api.models.OrgsActionsPermissionsRepositoriesResponse;
import com.github.api.models.OrgsActionsPermissionsRequest;
import com.github.api.models.OrgsActionsRequiredWorkflowsRepositoriesRequest;
import com.github.api.models.OrgsActionsRequiredWorkflowsRequest;
import com.github.api.models.OrgsActionsRequiredWorkflowsRequest1;
import com.github.api.models.OrgsActionsRequiredWorkflowsResponse;
import com.github.api.models.OrgsActionsRunnerGroupsRepositoriesRequest;
import com.github.api.models.OrgsActionsRunnerGroupsRepositoriesResponse;
import com.github.api.models.OrgsActionsRunnerGroupsRequest;
import com.github.api.models.OrgsActionsRunnerGroupsRequest1;
import com.github.api.models.OrgsActionsRunnerGroupsResponse;
import com.github.api.models.OrgsActionsRunnerGroupsRunnersRequest;
import com.github.api.models.OrgsActionsRunnerGroupsRunnersResponse;
import com.github.api.models.OrgsActionsRunnersLabelsRequest1;
import com.github.api.models.OrgsActionsRunnersRegistrationTokenResponse;
import com.github.api.models.OrgsActionsRunnersRemoveTokenResponse;
import com.github.api.models.OrgsActionsRunnersResponse;
import com.github.api.models.OrgsActionsRunnersResponse2;
import com.github.api.models.OrgsActionsSecretsPublicKeyResponse;
import com.github.api.models.OrgsActionsSecretsRepositoriesRequest;
import com.github.api.models.OrgsActionsSecretsRepositoriesResponse;
import com.github.api.models.OrgsActionsSecretsRequest;
import com.github.api.models.OrgsActionsSecretsResponse;
import com.github.api.models.OrgsActionsSecretsResponse2;
import com.github.api.models.OrgsActionsVariablesRepositoriesRequest;
import com.github.api.models.OrgsActionsVariablesRequest;
import com.github.api.models.OrgsActionsVariablesRequest1;
import com.github.api.models.OrgsActionsVariablesResponse;
import com.github.api.models.OrgsActionsVariablesResponse2;
import com.github.api.models.PendingDeployment;
import com.github.api.models.ReposActionsArtifactsArtifactIdResponse;
import com.github.api.models.ReposActionsArtifactsResponse;
import com.github.api.models.ReposActionsCacheUsageResponse;
import com.github.api.models.ReposActionsCachesResponse;
import com.github.api.models.ReposActionsJobsJobIdResponse;
import com.github.api.models.ReposActionsOidcCustomizationSubRequest;
import com.github.api.models.ReposActionsOidcCustomizationSubResponse;
import com.github.api.models.ReposActionsPermissionsRequest;
import com.github.api.models.ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoResponse;
import com.github.api.models.ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoRunsResponse;
import com.github.api.models.ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoTimingResponse;
import com.github.api.models.ReposActionsRequiredWorkflowsResponse;
import com.github.api.models.ReposActionsRunnersRegistrationTokenResponse;
import com.github.api.models.ReposActionsRunnersRemoveTokenResponse;
import com.github.api.models.ReposActionsRunnersRunnerIdResponse;
import com.github.api.models.ReposActionsRunsResponse;
import com.github.api.models.ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse;
import com.github.api.models.ReposActionsRunsRunIdAttemptsAttemptNumberResponse;
import com.github.api.models.ReposActionsRunsRunIdPendingDeploymentsRequest;
import com.github.api.models.ReposActionsRunsRunIdResponse;
import com.github.api.models.ReposActionsRunsRunIdTimingResponse;
import com.github.api.models.ReposActionsSecretsPublicKeyResponse;
import com.github.api.models.ReposActionsSecretsResponse;
import com.github.api.models.ReposActionsSecretsSecretNameRequest;
import com.github.api.models.ReposActionsSecretsSecretNameResponse;
import com.github.api.models.ReposActionsVariablesNameRequest;
import com.github.api.models.ReposActionsVariablesRequest;
import com.github.api.models.ReposActionsVariablesResponse;
import com.github.api.models.ReposActionsWorkflowsResponse;
import com.github.api.models.ReposActionsWorkflowsWorkflowIdDispatchesRequest;
import com.github.api.models.ReposActionsWorkflowsWorkflowIdResponse;
import com.github.api.models.ReposActionsWorkflowsWorkflowIdRunsResponse;
import com.github.api.models.ReposActionsWorkflowsWorkflowIdTimingResponse;
import com.github.api.models.RepositoriesEnvironmentsSecretsPublicKeyResponse;
import com.github.api.models.RepositoriesEnvironmentsSecretsSecretNameRequest;
import com.github.api.models.RepositoriesEnvironmentsSecretsSecretNameResponse;
import com.github.api.models.RequiredWorkflow;
import com.github.api.models.RunnerApplication;
import com.github.api.models.RunnerGroupsOrg;
import com.github.api.models.SelectedActions;
import com.github.api.models.Sort71Enum;
import com.github.api.models.Status81Enum;
import com.github.api.models.containers.ActionsCreateWorkflowDispatchWorkflowId;
import com.github.api.models.containers.ActionsDisableWorkflowWorkflowId;
import com.github.api.models.containers.ActionsEnableWorkflowWorkflowId;
import com.github.api.models.containers.ActionsGetWorkflowUsageWorkflowId;
import com.github.api.models.containers.ActionsGetWorkflowWorkflowId;
import com.github.api.models.containers.ActionsListWorkflowRunsWorkflowId;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class ActionsController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public ActionsController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Gets the total GitHub Actions cache usage for an organization. The data fetched using this
     * API is refreshed approximately every 5 minutes, so values returned from this endpoint may
     * take at least 5 minutes to get updated. You must authenticate using an access token with the
     * `read:org` scope to use this endpoint. GitHub Apps must have the
     * `organization_admistration:read` permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the ActionsCacheUsageOrgEnterprise response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsCacheUsageOrgEnterprise actionsGetActionsCacheUsageForOrg(
            final String org) throws ApiException, IOException {
        return prepareActionsGetActionsCacheUsageForOrgRequest(org).execute();
    }

    /**
     * Gets the total GitHub Actions cache usage for an organization. The data fetched using this
     * API is refreshed approximately every 5 minutes, so values returned from this endpoint may
     * take at least 5 minutes to get updated. You must authenticate using an access token with the
     * `read:org` scope to use this endpoint. GitHub Apps must have the
     * `organization_admistration:read` permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the ActionsCacheUsageOrgEnterprise response from the API call
     */
    public CompletableFuture<ActionsCacheUsageOrgEnterprise> actionsGetActionsCacheUsageForOrgAsync(
            final String org) {
        try { 
            return prepareActionsGetActionsCacheUsageForOrgRequest(org).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetActionsCacheUsageForOrg.
     */
    private ApiCall<ActionsCacheUsageOrgEnterprise, ApiException> prepareActionsGetActionsCacheUsageForOrgRequest(
            final String org) throws IOException {
        return new ApiCall.Builder<ActionsCacheUsageOrgEnterprise, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/cache/usage")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsCacheUsageOrgEnterprise.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists repositories and their GitHub Actions cache usage for an organization. The data fetched
     * using this API is refreshed approximately every 5 minutes, so values returned from this
     * endpoint may take at least 5 minutes to get updated. You must authenticate using an access
     * token with the `read:org` scope to use this endpoint. GitHub Apps must have the
     * `organization_admistration:read` permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsCacheUsageByRepositoryResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsCacheUsageByRepositoryResponse actionsGetActionsCacheUsageByRepoForOrg(
            final String org,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsGetActionsCacheUsageByRepoForOrgRequest(org, perPage, page).execute();
    }

    /**
     * Lists repositories and their GitHub Actions cache usage for an organization. The data fetched
     * using this API is refreshed approximately every 5 minutes, so values returned from this
     * endpoint may take at least 5 minutes to get updated. You must authenticate using an access
     * token with the `read:org` scope to use this endpoint. GitHub Apps must have the
     * `organization_admistration:read` permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsCacheUsageByRepositoryResponse response from the API call
     */
    public CompletableFuture<OrgsActionsCacheUsageByRepositoryResponse> actionsGetActionsCacheUsageByRepoForOrgAsync(
            final String org,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsGetActionsCacheUsageByRepoForOrgRequest(org, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetActionsCacheUsageByRepoForOrg.
     */
    private ApiCall<OrgsActionsCacheUsageByRepositoryResponse, ApiException> prepareActionsGetActionsCacheUsageByRepoForOrgRequest(
            final String org,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<OrgsActionsCacheUsageByRepositoryResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/cache/usage-by-repository")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsCacheUsageByRepositoryResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the GitHub Actions permissions policy for repositories and allowed actions and reusable
     * workflows in an organization. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the `administration`
     * organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the ActionsOrganizationPermissions response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsOrganizationPermissions actionsGetGithubActionsPermissionsOrganization(
            final String org) throws ApiException, IOException {
        return prepareActionsGetGithubActionsPermissionsOrganizationRequest(org).execute();
    }

    /**
     * Gets the GitHub Actions permissions policy for repositories and allowed actions and reusable
     * workflows in an organization. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the `administration`
     * organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the ActionsOrganizationPermissions response from the API call
     */
    public CompletableFuture<ActionsOrganizationPermissions> actionsGetGithubActionsPermissionsOrganizationAsync(
            final String org) {
        try { 
            return prepareActionsGetGithubActionsPermissionsOrganizationRequest(org).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetGithubActionsPermissionsOrganization.
     */
    private ApiCall<ActionsOrganizationPermissions, ApiException> prepareActionsGetGithubActionsPermissionsOrganizationRequest(
            final String org) throws IOException {
        return new ApiCall.Builder<ActionsOrganizationPermissions, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/permissions")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsOrganizationPermissions.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sets the GitHub Actions permissions policy for repositories and allowed actions and reusable
     * workflows in an organization. If the organization belongs to an enterprise that has set
     * restrictive permissions at the enterprise level, such as `allowed_actions` to `selected`
     * actions and reusable workflows, then you cannot override them for the organization. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub
     * Apps must have the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsSetGithubActionsPermissionsOrganization(
            final String org,
            final OrgsActionsPermissionsRequest body) throws ApiException, IOException {
        prepareActionsSetGithubActionsPermissionsOrganizationRequest(org, body).execute();
    }

    /**
     * Sets the GitHub Actions permissions policy for repositories and allowed actions and reusable
     * workflows in an organization. If the organization belongs to an enterprise that has set
     * restrictive permissions at the enterprise level, such as `allowed_actions` to `selected`
     * actions and reusable workflows, then you cannot override them for the organization. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub
     * Apps must have the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsSetGithubActionsPermissionsOrganizationAsync(
            final String org,
            final OrgsActionsPermissionsRequest body) {
        try { 
            return prepareActionsSetGithubActionsPermissionsOrganizationRequest(org, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetGithubActionsPermissionsOrganization.
     */
    private ApiCall<Void, ApiException> prepareActionsSetGithubActionsPermissionsOrganizationRequest(
            final String org,
            final OrgsActionsPermissionsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/permissions")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the selected repositories that are enabled for GitHub Actions in an organization. To
     * use this endpoint, the organization permission policy for `enabled_repositories` must be
     * configured to `selected`. For more information, see "[Set GitHub Actions permissions for an
     * organization](#set-github-actions-permissions-for-an-organization)." You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have
     * the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsPermissionsRepositoriesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsPermissionsRepositoriesResponse actionsListSelectedRepositoriesEnabledGithubActionsOrganization(
            final String org,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest(org,
                perPage, page).execute();
    }

    /**
     * Lists the selected repositories that are enabled for GitHub Actions in an organization. To
     * use this endpoint, the organization permission policy for `enabled_repositories` must be
     * configured to `selected`. For more information, see "[Set GitHub Actions permissions for an
     * organization](#set-github-actions-permissions-for-an-organization)." You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have
     * the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsPermissionsRepositoriesResponse response from the API call
     */
    public CompletableFuture<OrgsActionsPermissionsRepositoriesResponse> actionsListSelectedRepositoriesEnabledGithubActionsOrganizationAsync(
            final String org,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest(org,
            perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListSelectedRepositoriesEnabledGithubActionsOrganization.
     */
    private ApiCall<OrgsActionsPermissionsRepositoriesResponse, ApiException> prepareActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest(
            final String org,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<OrgsActionsPermissionsRepositoriesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/permissions/repositories")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsPermissionsRepositoriesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Replaces the list of selected repositories that are enabled for GitHub Actions in an
     * organization. To use this endpoint, the organization permission policy for
     * `enabled_repositories` must be configured to `selected`. For more information, see "[Set
     * GitHub Actions permissions for an
     * organization](#set-github-actions-permissions-for-an-organization)." You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have
     * the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsSetSelectedRepositoriesEnabledGithubActionsOrganization(
            final String org,
            final OrgsActionsPermissionsRepositoriesRequest body) throws ApiException, IOException {
        prepareActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(org,
                body).execute();
    }

    /**
     * Replaces the list of selected repositories that are enabled for GitHub Actions in an
     * organization. To use this endpoint, the organization permission policy for
     * `enabled_repositories` must be configured to `selected`. For more information, see "[Set
     * GitHub Actions permissions for an
     * organization](#set-github-actions-permissions-for-an-organization)." You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have
     * the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsSetSelectedRepositoriesEnabledGithubActionsOrganizationAsync(
            final String org,
            final OrgsActionsPermissionsRepositoriesRequest body) {
        try { 
            return prepareActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(org,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetSelectedRepositoriesEnabledGithubActionsOrganization.
     */
    private ApiCall<Void, ApiException> prepareActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(
            final String org,
            final OrgsActionsPermissionsRepositoriesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/permissions/repositories")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Adds a repository to the list of selected repositories that are enabled for GitHub Actions in
     * an organization. To use this endpoint, the organization permission policy for
     * `enabled_repositories` must be must be configured to `selected`. For more information, see
     * "[Set GitHub Actions permissions for an
     * organization](#set-github-actions-permissions-for-an-organization)." You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have
     * the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsEnableSelectedRepositoryGithubActionsOrganization(
            final String org,
            final int repositoryId) throws ApiException, IOException {
        prepareActionsEnableSelectedRepositoryGithubActionsOrganizationRequest(org,
                repositoryId).execute();
    }

    /**
     * Adds a repository to the list of selected repositories that are enabled for GitHub Actions in
     * an organization. To use this endpoint, the organization permission policy for
     * `enabled_repositories` must be must be configured to `selected`. For more information, see
     * "[Set GitHub Actions permissions for an
     * organization](#set-github-actions-permissions-for-an-organization)." You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have
     * the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsEnableSelectedRepositoryGithubActionsOrganizationAsync(
            final String org,
            final int repositoryId) {
        try { 
            return prepareActionsEnableSelectedRepositoryGithubActionsOrganizationRequest(org,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsEnableSelectedRepositoryGithubActionsOrganization.
     */
    private ApiCall<Void, ApiException> prepareActionsEnableSelectedRepositoryGithubActionsOrganizationRequest(
            final String org,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/permissions/repositories/{repository_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes a repository from the list of selected repositories that are enabled for GitHub
     * Actions in an organization. To use this endpoint, the organization permission policy for
     * `enabled_repositories` must be configured to `selected`. For more information, see "[Set
     * GitHub Actions permissions for an
     * organization](#set-github-actions-permissions-for-an-organization)." You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have
     * the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDisableSelectedRepositoryGithubActionsOrganization(
            final String org,
            final int repositoryId) throws ApiException, IOException {
        prepareActionsDisableSelectedRepositoryGithubActionsOrganizationRequest(org,
                repositoryId).execute();
    }

    /**
     * Removes a repository from the list of selected repositories that are enabled for GitHub
     * Actions in an organization. To use this endpoint, the organization permission policy for
     * `enabled_repositories` must be configured to `selected`. For more information, see "[Set
     * GitHub Actions permissions for an
     * organization](#set-github-actions-permissions-for-an-organization)." You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have
     * the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDisableSelectedRepositoryGithubActionsOrganizationAsync(
            final String org,
            final int repositoryId) {
        try { 
            return prepareActionsDisableSelectedRepositoryGithubActionsOrganizationRequest(org,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDisableSelectedRepositoryGithubActionsOrganization.
     */
    private ApiCall<Void, ApiException> prepareActionsDisableSelectedRepositoryGithubActionsOrganizationRequest(
            final String org,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/permissions/repositories/{repository_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the selected actions and reusable workflows that are allowed in an organization. To use
     * this endpoint, the organization permission policy for `allowed_actions` must be configured to
     * `selected`. For more information, see "[Set GitHub Actions permissions for an
     * organization](#set-github-actions-permissions-for-an-organization)."" You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have
     * the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the SelectedActions response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public SelectedActions actionsGetAllowedActionsOrganization(
            final String org) throws ApiException, IOException {
        return prepareActionsGetAllowedActionsOrganizationRequest(org).execute();
    }

    /**
     * Gets the selected actions and reusable workflows that are allowed in an organization. To use
     * this endpoint, the organization permission policy for `allowed_actions` must be configured to
     * `selected`. For more information, see "[Set GitHub Actions permissions for an
     * organization](#set-github-actions-permissions-for-an-organization)."" You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have
     * the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the SelectedActions response from the API call
     */
    public CompletableFuture<SelectedActions> actionsGetAllowedActionsOrganizationAsync(
            final String org) {
        try { 
            return prepareActionsGetAllowedActionsOrganizationRequest(org).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetAllowedActionsOrganization.
     */
    private ApiCall<SelectedActions, ApiException> prepareActionsGetAllowedActionsOrganizationRequest(
            final String org) throws IOException {
        return new ApiCall.Builder<SelectedActions, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/permissions/selected-actions")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, SelectedActions.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sets the actions and reusable workflows that are allowed in an organization. To use this
     * endpoint, the organization permission policy for `allowed_actions` must be configured to
     * `selected`. For more information, see "[Set GitHub Actions permissions for an
     * organization](#set-github-actions-permissions-for-an-organization)." If the organization
     * belongs to an enterprise that has `selected` actions and reusable workflows set at the
     * enterprise level, then you cannot override any of the enterprise's allowed actions and
     * reusable workflows settings. To use the `patterns_allowed` setting for private repositories,
     * the organization must belong to an enterprise. If the organization does not belong to an
     * enterprise, then the `patterns_allowed` setting only applies to public repositories in the
     * organization. You must authenticate using an access token with the `admin:org` scope to use
     * this endpoint. GitHub Apps must have the `administration` organization permission to use this
     * API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsSetAllowedActionsOrganization(
            final String org,
            final SelectedActions body) throws ApiException, IOException {
        prepareActionsSetAllowedActionsOrganizationRequest(org, body).execute();
    }

    /**
     * Sets the actions and reusable workflows that are allowed in an organization. To use this
     * endpoint, the organization permission policy for `allowed_actions` must be configured to
     * `selected`. For more information, see "[Set GitHub Actions permissions for an
     * organization](#set-github-actions-permissions-for-an-organization)." If the organization
     * belongs to an enterprise that has `selected` actions and reusable workflows set at the
     * enterprise level, then you cannot override any of the enterprise's allowed actions and
     * reusable workflows settings. To use the `patterns_allowed` setting for private repositories,
     * the organization must belong to an enterprise. If the organization does not belong to an
     * enterprise, then the `patterns_allowed` setting only applies to public repositories in the
     * organization. You must authenticate using an access token with the `admin:org` scope to use
     * this endpoint. GitHub Apps must have the `administration` organization permission to use this
     * API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsSetAllowedActionsOrganizationAsync(
            final String org,
            final SelectedActions body) {
        try { 
            return prepareActionsSetAllowedActionsOrganizationRequest(org, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetAllowedActionsOrganization.
     */
    private ApiCall<Void, ApiException> prepareActionsSetAllowedActionsOrganizationRequest(
            final String org,
            final SelectedActions body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/permissions/selected-actions")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in
     * an organization, as well as whether GitHub Actions can submit approving pull request reviews.
     * For more information, see "[Setting the permissions of the GITHUB_TOKEN for your
     * organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the ActionsGetDefaultWorkflowPermissions response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsGetDefaultWorkflowPermissions actionsGetGithubActionsDefaultWorkflowPermissionsOrganization(
            final String org) throws ApiException, IOException {
        return prepareActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest(
                org).execute();
    }

    /**
     * Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in
     * an organization, as well as whether GitHub Actions can submit approving pull request reviews.
     * For more information, see "[Setting the permissions of the GITHUB_TOKEN for your
     * organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the ActionsGetDefaultWorkflowPermissions response from the API call
     */
    public CompletableFuture<ActionsGetDefaultWorkflowPermissions> actionsGetGithubActionsDefaultWorkflowPermissionsOrganizationAsync(
            final String org) {
        try { 
            return prepareActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest(
            org).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetGithubActionsDefaultWorkflowPermissionsOrganization.
     */
    private ApiCall<ActionsGetDefaultWorkflowPermissions, ApiException> prepareActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest(
            final String org) throws IOException {
        return new ApiCall.Builder<ActionsGetDefaultWorkflowPermissions, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/permissions/workflow")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsGetDefaultWorkflowPermissions.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in
     * an organization, and sets if GitHub Actions can submit approving pull request reviews. For
     * more information, see "[Setting the permissions of the GITHUB_TOKEN for your
     * organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsSetGithubActionsDefaultWorkflowPermissionsOrganization(
            final String org,
            final ActionsSetDefaultWorkflowPermissions body) throws ApiException, IOException {
        prepareActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest(org,
                body).execute();
    }

    /**
     * Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in
     * an organization, and sets if GitHub Actions can submit approving pull request reviews. For
     * more information, see "[Setting the permissions of the GITHUB_TOKEN for your
     * organization](https://docs.github.com/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#setting-the-permissions-of-the-github_token-for-your-organization)."
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `administration` organization permission to use this API.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsSetGithubActionsDefaultWorkflowPermissionsOrganizationAsync(
            final String org,
            final ActionsSetDefaultWorkflowPermissions body) {
        try { 
            return prepareActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest(org,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetGithubActionsDefaultWorkflowPermissionsOrganization.
     */
    private ApiCall<Void, ApiException> prepareActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest(
            final String org,
            final ActionsSetDefaultWorkflowPermissions body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/permissions/workflow")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict response when changing a setting is prevented by the owning enterprise",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List all required workflows in an organization. You must authenticate using an access token
     * with the `read:org` scope to use this endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsRequiredWorkflowsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsRequiredWorkflowsResponse actionsListRequiredWorkflows(
            final String org,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListRequiredWorkflowsRequest(org, perPage, page).execute();
    }

    /**
     * List all required workflows in an organization. You must authenticate using an access token
     * with the `read:org` scope to use this endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsRequiredWorkflowsResponse response from the API call
     */
    public CompletableFuture<OrgsActionsRequiredWorkflowsResponse> actionsListRequiredWorkflowsAsync(
            final String org,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListRequiredWorkflowsRequest(org, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListRequiredWorkflows.
     */
    private ApiCall<OrgsActionsRequiredWorkflowsResponse, ApiException> prepareActionsListRequiredWorkflowsRequest(
            final String org,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<OrgsActionsRequiredWorkflowsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/required_workflows")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsRequiredWorkflowsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Create a required workflow in an organization. You must authenticate using an access token
     * with the `admin:org` scope to use this endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the RequiredWorkflow response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public RequiredWorkflow actionsCreateRequiredWorkflow(
            final String org,
            final OrgsActionsRequiredWorkflowsRequest body) throws ApiException, IOException {
        return prepareActionsCreateRequiredWorkflowRequest(org, body).execute();
    }

    /**
     * Create a required workflow in an organization. You must authenticate using an access token
     * with the `admin:org` scope to use this endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the RequiredWorkflow response from the API call
     */
    public CompletableFuture<RequiredWorkflow> actionsCreateRequiredWorkflowAsync(
            final String org,
            final OrgsActionsRequiredWorkflowsRequest body) {
        try { 
            return prepareActionsCreateRequiredWorkflowRequest(org, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsCreateRequiredWorkflow.
     */
    private ApiCall<RequiredWorkflow, ApiException> prepareActionsCreateRequiredWorkflowRequest(
            final String org,
            final OrgsActionsRequiredWorkflowsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<RequiredWorkflow, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/required_workflows")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, RequiredWorkflow.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new OrgsActionsRequiredWorkflows422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get a required workflow configured in an organization. You must authenticate using an access
     * token with the `read:org` scope to use this endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  requiredWorkflowId  Required parameter: The unique identifier of the required
     *         workflow.
     * @return    Returns the RequiredWorkflow response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public RequiredWorkflow actionsGetRequiredWorkflow(
            final String org,
            final int requiredWorkflowId) throws ApiException, IOException {
        return prepareActionsGetRequiredWorkflowRequest(org, requiredWorkflowId).execute();
    }

    /**
     * Get a required workflow configured in an organization. You must authenticate using an access
     * token with the `read:org` scope to use this endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  requiredWorkflowId  Required parameter: The unique identifier of the required
     *         workflow.
     * @return    Returns the RequiredWorkflow response from the API call
     */
    public CompletableFuture<RequiredWorkflow> actionsGetRequiredWorkflowAsync(
            final String org,
            final int requiredWorkflowId) {
        try { 
            return prepareActionsGetRequiredWorkflowRequest(org, requiredWorkflowId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetRequiredWorkflow.
     */
    private ApiCall<RequiredWorkflow, ApiException> prepareActionsGetRequiredWorkflowRequest(
            final String org,
            final int requiredWorkflowId) throws IOException {
        return new ApiCall.Builder<RequiredWorkflow, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/required_workflows/{required_workflow_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("required_workflow_id").value(requiredWorkflowId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, RequiredWorkflow.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Update a required workflow in an organization. You must authenticate using an access token
     * with the `admin:org` scope to use this endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  requiredWorkflowId  Required parameter: The unique identifier of the required
     *         workflow.
     * @param  body  Required parameter: Example:
     * @return    Returns the RequiredWorkflow response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public RequiredWorkflow actionsUpdateRequiredWorkflow(
            final String org,
            final int requiredWorkflowId,
            final OrgsActionsRequiredWorkflowsRequest1 body) throws ApiException, IOException {
        return prepareActionsUpdateRequiredWorkflowRequest(org, requiredWorkflowId, body).execute();
    }

    /**
     * Update a required workflow in an organization. You must authenticate using an access token
     * with the `admin:org` scope to use this endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  requiredWorkflowId  Required parameter: The unique identifier of the required
     *         workflow.
     * @param  body  Required parameter: Example:
     * @return    Returns the RequiredWorkflow response from the API call
     */
    public CompletableFuture<RequiredWorkflow> actionsUpdateRequiredWorkflowAsync(
            final String org,
            final int requiredWorkflowId,
            final OrgsActionsRequiredWorkflowsRequest1 body) {
        try { 
            return prepareActionsUpdateRequiredWorkflowRequest(org, requiredWorkflowId,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsUpdateRequiredWorkflow.
     */
    private ApiCall<RequiredWorkflow, ApiException> prepareActionsUpdateRequiredWorkflowRequest(
            final String org,
            final int requiredWorkflowId,
            final OrgsActionsRequiredWorkflowsRequest1 body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<RequiredWorkflow, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/required_workflows/{required_workflow_id}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("required_workflow_id").value(requiredWorkflowId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, RequiredWorkflow.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new OrgsActionsRequiredWorkflows422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a required workflow configured in an organization. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint. For more information, see
     * "[Required Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  requiredWorkflowId  Required parameter: The unique identifier of the required
     *         workflow.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDeleteRequiredWorkflow(
            final String org,
            final int requiredWorkflowId) throws ApiException, IOException {
        prepareActionsDeleteRequiredWorkflowRequest(org, requiredWorkflowId).execute();
    }

    /**
     * Deletes a required workflow configured in an organization. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint. For more information, see
     * "[Required Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  requiredWorkflowId  Required parameter: The unique identifier of the required
     *         workflow.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDeleteRequiredWorkflowAsync(
            final String org,
            final int requiredWorkflowId) {
        try { 
            return prepareActionsDeleteRequiredWorkflowRequest(org, requiredWorkflowId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteRequiredWorkflow.
     */
    private ApiCall<Void, ApiException> prepareActionsDeleteRequiredWorkflowRequest(
            final String org,
            final int requiredWorkflowId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/required_workflows/{required_workflow_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("required_workflow_id").value(requiredWorkflowId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the selected repositories that are configured for a required workflow in an
     * organization. To use this endpoint, the required workflow must be configured to run on
     * selected repositories. You must authenticate using an access token with the `read:org` scope
     * to use this endpoint. GitHub Apps must have the `administration` organization permission to
     * use this endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  requiredWorkflowId  Required parameter: The unique identifier of the required
     *         workflow.
     * @return    Returns the OrgsActionsPermissionsRepositoriesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsPermissionsRepositoriesResponse actionsListSelectedRepositoriesRequiredWorkflow(
            final String org,
            final int requiredWorkflowId) throws ApiException, IOException {
        return prepareActionsListSelectedRepositoriesRequiredWorkflowRequest(org,
                requiredWorkflowId).execute();
    }

    /**
     * Lists the selected repositories that are configured for a required workflow in an
     * organization. To use this endpoint, the required workflow must be configured to run on
     * selected repositories. You must authenticate using an access token with the `read:org` scope
     * to use this endpoint. GitHub Apps must have the `administration` organization permission to
     * use this endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  requiredWorkflowId  Required parameter: The unique identifier of the required
     *         workflow.
     * @return    Returns the OrgsActionsPermissionsRepositoriesResponse response from the API call
     */
    public CompletableFuture<OrgsActionsPermissionsRepositoriesResponse> actionsListSelectedRepositoriesRequiredWorkflowAsync(
            final String org,
            final int requiredWorkflowId) {
        try { 
            return prepareActionsListSelectedRepositoriesRequiredWorkflowRequest(org,
            requiredWorkflowId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListSelectedRepositoriesRequiredWorkflow.
     */
    private ApiCall<OrgsActionsPermissionsRepositoriesResponse, ApiException> prepareActionsListSelectedRepositoriesRequiredWorkflowRequest(
            final String org,
            final int requiredWorkflowId) throws IOException {
        return new ApiCall.Builder<OrgsActionsPermissionsRepositoriesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("required_workflow_id").value(requiredWorkflowId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsPermissionsRepositoriesResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource Not Found",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sets the repositories for a required workflow that is required for selected repositories. You
     * must authenticate using an access token with the `admin:org` scope to use this endpoint. For
     * more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  requiredWorkflowId  Required parameter: The unique identifier of the required
     *         workflow.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsSetSelectedReposToRequiredWorkflow(
            final String org,
            final int requiredWorkflowId,
            final OrgsActionsRequiredWorkflowsRepositoriesRequest body) throws ApiException, IOException {
        prepareActionsSetSelectedReposToRequiredWorkflowRequest(org, requiredWorkflowId,
                body).execute();
    }

    /**
     * Sets the repositories for a required workflow that is required for selected repositories. You
     * must authenticate using an access token with the `admin:org` scope to use this endpoint. For
     * more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  requiredWorkflowId  Required parameter: The unique identifier of the required
     *         workflow.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsSetSelectedReposToRequiredWorkflowAsync(
            final String org,
            final int requiredWorkflowId,
            final OrgsActionsRequiredWorkflowsRepositoriesRequest body) {
        try { 
            return prepareActionsSetSelectedReposToRequiredWorkflowRequest(org, requiredWorkflowId,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetSelectedReposToRequiredWorkflow.
     */
    private ApiCall<Void, ApiException> prepareActionsSetSelectedReposToRequiredWorkflowRequest(
            final String org,
            final int requiredWorkflowId,
            final OrgsActionsRequiredWorkflowsRepositoriesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("required_workflow_id").value(requiredWorkflowId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Adds a repository to a required workflow. To use this endpoint, the required workflow must be
     * configured to run on selected repositories. You must authenticate using an access token with
     * the `admin:org` scope to use this endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  requiredWorkflowId  Required parameter: The unique identifier of the required
     *         workflow.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsAddSelectedRepoToRequiredWorkflow(
            final String org,
            final int requiredWorkflowId,
            final int repositoryId) throws ApiException, IOException {
        prepareActionsAddSelectedRepoToRequiredWorkflowRequest(org, requiredWorkflowId,
                repositoryId).execute();
    }

    /**
     * Adds a repository to a required workflow. To use this endpoint, the required workflow must be
     * configured to run on selected repositories. You must authenticate using an access token with
     * the `admin:org` scope to use this endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  requiredWorkflowId  Required parameter: The unique identifier of the required
     *         workflow.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsAddSelectedRepoToRequiredWorkflowAsync(
            final String org,
            final int requiredWorkflowId,
            final int repositoryId) {
        try { 
            return prepareActionsAddSelectedRepoToRequiredWorkflowRequest(org, requiredWorkflowId,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsAddSelectedRepoToRequiredWorkflow.
     */
    private ApiCall<Void, ApiException> prepareActionsAddSelectedRepoToRequiredWorkflowRequest(
            final String org,
            final int requiredWorkflowId,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories/{repository_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("required_workflow_id").value(requiredWorkflowId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource Not Found",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation Error",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes a repository from a required workflow. To use this endpoint, the required workflow
     * must be configured to run on selected repositories. You must authenticate using an access
     * token with the `admin:org` scope to use this endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  requiredWorkflowId  Required parameter: The unique identifier of the required
     *         workflow.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsRemoveSelectedRepoFromRequiredWorkflow(
            final String org,
            final int requiredWorkflowId,
            final int repositoryId) throws ApiException, IOException {
        prepareActionsRemoveSelectedRepoFromRequiredWorkflowRequest(org, requiredWorkflowId,
                repositoryId).execute();
    }

    /**
     * Removes a repository from a required workflow. To use this endpoint, the required workflow
     * must be configured to run on selected repositories. You must authenticate using an access
     * token with the `admin:org` scope to use this endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  requiredWorkflowId  Required parameter: The unique identifier of the required
     *         workflow.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsRemoveSelectedRepoFromRequiredWorkflowAsync(
            final String org,
            final int requiredWorkflowId,
            final int repositoryId) {
        try { 
            return prepareActionsRemoveSelectedRepoFromRequiredWorkflowRequest(org, requiredWorkflowId,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsRemoveSelectedRepoFromRequiredWorkflow.
     */
    private ApiCall<Void, ApiException> prepareActionsRemoveSelectedRepoFromRequiredWorkflowRequest(
            final String org,
            final int requiredWorkflowId,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/required_workflows/{required_workflow_id}/repositories/{repository_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("required_workflow_id").value(requiredWorkflowId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource Not Found",
                                (reason, context) -> new ApiException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation Error",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all self-hosted runner groups configured in an organization and inherited from an
     * enterprise. You must authenticate using an access token with the `admin:org` scope to use
     * this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  visibleToRepository  Optional parameter: Only return runner groups that are allowed
     *         to be used by this repository.
     * @return    Returns the OrgsActionsRunnerGroupsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsRunnerGroupsResponse actionsListSelfHostedRunnerGroupsForOrg(
            final String org,
            final Integer perPage,
            final Integer page,
            final String visibleToRepository) throws ApiException, IOException {
        return prepareActionsListSelfHostedRunnerGroupsForOrgRequest(org, perPage, page,
                visibleToRepository).execute();
    }

    /**
     * Lists all self-hosted runner groups configured in an organization and inherited from an
     * enterprise. You must authenticate using an access token with the `admin:org` scope to use
     * this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  visibleToRepository  Optional parameter: Only return runner groups that are allowed
     *         to be used by this repository.
     * @return    Returns the OrgsActionsRunnerGroupsResponse response from the API call
     */
    public CompletableFuture<OrgsActionsRunnerGroupsResponse> actionsListSelfHostedRunnerGroupsForOrgAsync(
            final String org,
            final Integer perPage,
            final Integer page,
            final String visibleToRepository) {
        try { 
            return prepareActionsListSelfHostedRunnerGroupsForOrgRequest(org, perPage, page,
            visibleToRepository).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListSelfHostedRunnerGroupsForOrg.
     */
    private ApiCall<OrgsActionsRunnerGroupsResponse, ApiException> prepareActionsListSelfHostedRunnerGroupsForOrgRequest(
            final String org,
            final Integer perPage,
            final Integer page,
            final String visibleToRepository) throws IOException {
        return new ApiCall.Builder<OrgsActionsRunnerGroupsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runner-groups")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("visible_to_repository")
                                .value(visibleToRepository).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsRunnerGroupsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates a new self-hosted runner group for an organization. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the RunnerGroupsOrg response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public RunnerGroupsOrg actionsCreateSelfHostedRunnerGroupForOrg(
            final String org,
            final OrgsActionsRunnerGroupsRequest body) throws ApiException, IOException {
        return prepareActionsCreateSelfHostedRunnerGroupForOrgRequest(org, body).execute();
    }

    /**
     * Creates a new self-hosted runner group for an organization. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the RunnerGroupsOrg response from the API call
     */
    public CompletableFuture<RunnerGroupsOrg> actionsCreateSelfHostedRunnerGroupForOrgAsync(
            final String org,
            final OrgsActionsRunnerGroupsRequest body) {
        try { 
            return prepareActionsCreateSelfHostedRunnerGroupForOrgRequest(org, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsCreateSelfHostedRunnerGroupForOrg.
     */
    private ApiCall<RunnerGroupsOrg, ApiException> prepareActionsCreateSelfHostedRunnerGroupForOrgRequest(
            final String org,
            final OrgsActionsRunnerGroupsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<RunnerGroupsOrg, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runner-groups")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, RunnerGroupsOrg.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific self-hosted runner group for an organization. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @return    Returns the RunnerGroupsOrg response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public RunnerGroupsOrg actionsGetSelfHostedRunnerGroupForOrg(
            final String org,
            final int runnerGroupId) throws ApiException, IOException {
        return prepareActionsGetSelfHostedRunnerGroupForOrgRequest(org, runnerGroupId).execute();
    }

    /**
     * Gets a specific self-hosted runner group for an organization. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @return    Returns the RunnerGroupsOrg response from the API call
     */
    public CompletableFuture<RunnerGroupsOrg> actionsGetSelfHostedRunnerGroupForOrgAsync(
            final String org,
            final int runnerGroupId) {
        try { 
            return prepareActionsGetSelfHostedRunnerGroupForOrgRequest(org, runnerGroupId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetSelfHostedRunnerGroupForOrg.
     */
    private ApiCall<RunnerGroupsOrg, ApiException> prepareActionsGetSelfHostedRunnerGroupForOrgRequest(
            final String org,
            final int runnerGroupId) throws IOException {
        return new ApiCall.Builder<RunnerGroupsOrg, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runner-groups/{runner_group_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_group_id").value(runnerGroupId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, RunnerGroupsOrg.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates the `name` and `visibility` of a self-hosted runner group in an organization. You
     * must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  body  Required parameter: Example:
     * @return    Returns the RunnerGroupsOrg response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public RunnerGroupsOrg actionsUpdateSelfHostedRunnerGroupForOrg(
            final String org,
            final int runnerGroupId,
            final OrgsActionsRunnerGroupsRequest1 body) throws ApiException, IOException {
        return prepareActionsUpdateSelfHostedRunnerGroupForOrgRequest(org, runnerGroupId,
                body).execute();
    }

    /**
     * Updates the `name` and `visibility` of a self-hosted runner group in an organization. You
     * must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  body  Required parameter: Example:
     * @return    Returns the RunnerGroupsOrg response from the API call
     */
    public CompletableFuture<RunnerGroupsOrg> actionsUpdateSelfHostedRunnerGroupForOrgAsync(
            final String org,
            final int runnerGroupId,
            final OrgsActionsRunnerGroupsRequest1 body) {
        try { 
            return prepareActionsUpdateSelfHostedRunnerGroupForOrgRequest(org, runnerGroupId,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsUpdateSelfHostedRunnerGroupForOrg.
     */
    private ApiCall<RunnerGroupsOrg, ApiException> prepareActionsUpdateSelfHostedRunnerGroupForOrgRequest(
            final String org,
            final int runnerGroupId,
            final OrgsActionsRunnerGroupsRequest1 body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<RunnerGroupsOrg, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runner-groups/{runner_group_id}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_group_id").value(runnerGroupId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, RunnerGroupsOrg.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a self-hosted runner group for an organization. You must authenticate using an access
     * token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDeleteSelfHostedRunnerGroupFromOrg(
            final String org,
            final int runnerGroupId) throws ApiException, IOException {
        prepareActionsDeleteSelfHostedRunnerGroupFromOrgRequest(org, runnerGroupId).execute();
    }

    /**
     * Deletes a self-hosted runner group for an organization. You must authenticate using an access
     * token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDeleteSelfHostedRunnerGroupFromOrgAsync(
            final String org,
            final int runnerGroupId) {
        try { 
            return prepareActionsDeleteSelfHostedRunnerGroupFromOrgRequest(org,
            runnerGroupId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteSelfHostedRunnerGroupFromOrg.
     */
    private ApiCall<Void, ApiException> prepareActionsDeleteSelfHostedRunnerGroupFromOrgRequest(
            final String org,
            final int runnerGroupId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runner-groups/{runner_group_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_group_id").value(runnerGroupId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the repositories with access to a self-hosted runner group configured in an
     * organization. You must authenticate using an access token with the `admin:org` scope to use
     * this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the OrgsActionsRunnerGroupsRepositoriesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsRunnerGroupsRepositoriesResponse actionsListRepoAccessToSelfHostedRunnerGroupInOrg(
            final String org,
            final int runnerGroupId,
            final Integer page,
            final Integer perPage) throws ApiException, IOException {
        return prepareActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest(org, runnerGroupId,
                page, perPage).execute();
    }

    /**
     * Lists the repositories with access to a self-hosted runner group configured in an
     * organization. You must authenticate using an access token with the `admin:org` scope to use
     * this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the OrgsActionsRunnerGroupsRepositoriesResponse response from the API call
     */
    public CompletableFuture<OrgsActionsRunnerGroupsRepositoriesResponse> actionsListRepoAccessToSelfHostedRunnerGroupInOrgAsync(
            final String org,
            final int runnerGroupId,
            final Integer page,
            final Integer perPage) {
        try { 
            return prepareActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest(org, runnerGroupId, page,
            perPage).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListRepoAccessToSelfHostedRunnerGroupInOrg.
     */
    private ApiCall<OrgsActionsRunnerGroupsRepositoriesResponse, ApiException> prepareActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest(
            final String org,
            final int runnerGroupId,
            final Integer page,
            final Integer perPage) throws IOException {
        return new ApiCall.Builder<OrgsActionsRunnerGroupsRepositoriesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories")
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_group_id").value(runnerGroupId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsRunnerGroupsRepositoriesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Replaces the list of repositories that have access to a self-hosted runner group configured
     * in an organization. You must authenticate using an access token with the `admin:org` scope to
     * use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsSetRepoAccessToSelfHostedRunnerGroupInOrg(
            final String org,
            final int runnerGroupId,
            final OrgsActionsRunnerGroupsRepositoriesRequest body) throws ApiException, IOException {
        prepareActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(org, runnerGroupId,
                body).execute();
    }

    /**
     * Replaces the list of repositories that have access to a self-hosted runner group configured
     * in an organization. You must authenticate using an access token with the `admin:org` scope to
     * use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsSetRepoAccessToSelfHostedRunnerGroupInOrgAsync(
            final String org,
            final int runnerGroupId,
            final OrgsActionsRunnerGroupsRepositoriesRequest body) {
        try { 
            return prepareActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(org, runnerGroupId,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetRepoAccessToSelfHostedRunnerGroupInOrg.
     */
    private ApiCall<Void, ApiException> prepareActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest(
            final String org,
            final int runnerGroupId,
            final OrgsActionsRunnerGroupsRepositoriesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_group_id").value(runnerGroupId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes a repository from the list of selected repositories that can access a self-hosted
     * runner group. The runner group must have `visibility` set to `selected`. For more
     * information, see "[Create a self-hosted runner group for an
     * organization](#create-a-self-hosted-runner-group-for-an-organization)." You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(
            final String org,
            final int runnerGroupId,
            final int repositoryId) throws ApiException, IOException {
        prepareActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest(org, runnerGroupId,
                repositoryId).execute();
    }

    /**
     * Removes a repository from the list of selected repositories that can access a self-hosted
     * runner group. The runner group must have `visibility` set to `selected`. For more
     * information, see "[Create a self-hosted runner group for an
     * organization](#create-a-self-hosted-runner-group-for-an-organization)." You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgAsync(
            final String org,
            final int runnerGroupId,
            final int repositoryId) {
        try { 
            return prepareActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest(org, runnerGroupId,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg.
     */
    private ApiCall<Void, ApiException> prepareActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest(
            final String org,
            final int runnerGroupId,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_group_id").value(runnerGroupId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists self-hosted runners that are in a specific organization group. You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsRunnerGroupsRunnersResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsRunnerGroupsRunnersResponse actionsListSelfHostedRunnersInGroupForOrg(
            final String org,
            final int runnerGroupId,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListSelfHostedRunnersInGroupForOrgRequest(org, runnerGroupId, perPage,
                page).execute();
    }

    /**
     * Lists self-hosted runners that are in a specific organization group. You must authenticate
     * using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsRunnerGroupsRunnersResponse response from the API call
     */
    public CompletableFuture<OrgsActionsRunnerGroupsRunnersResponse> actionsListSelfHostedRunnersInGroupForOrgAsync(
            final String org,
            final int runnerGroupId,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListSelfHostedRunnersInGroupForOrgRequest(org, runnerGroupId, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListSelfHostedRunnersInGroupForOrg.
     */
    private ApiCall<OrgsActionsRunnerGroupsRunnersResponse, ApiException> prepareActionsListSelfHostedRunnersInGroupForOrgRequest(
            final String org,
            final int runnerGroupId,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<OrgsActionsRunnerGroupsRunnersResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runner-groups/{runner_group_id}/runners")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_group_id").value(runnerGroupId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsRunnerGroupsRunnersResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Replaces the list of self-hosted runners that are part of an organization runner group. You
     * must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsSetSelfHostedRunnersInGroupForOrg(
            final String org,
            final int runnerGroupId,
            final OrgsActionsRunnerGroupsRunnersRequest body) throws ApiException, IOException {
        prepareActionsSetSelfHostedRunnersInGroupForOrgRequest(org, runnerGroupId, body).execute();
    }

    /**
     * Replaces the list of self-hosted runners that are part of an organization runner group. You
     * must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsSetSelfHostedRunnersInGroupForOrgAsync(
            final String org,
            final int runnerGroupId,
            final OrgsActionsRunnerGroupsRunnersRequest body) {
        try { 
            return prepareActionsSetSelfHostedRunnersInGroupForOrgRequest(org, runnerGroupId,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetSelfHostedRunnersInGroupForOrg.
     */
    private ApiCall<Void, ApiException> prepareActionsSetSelfHostedRunnersInGroupForOrgRequest(
            final String org,
            final int runnerGroupId,
            final OrgsActionsRunnerGroupsRunnersRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runner-groups/{runner_group_id}/runners")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_group_id").value(runnerGroupId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Adds a self-hosted runner to a runner group configured in an organization. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsAddSelfHostedRunnerToGroupForOrg(
            final String org,
            final int runnerGroupId,
            final int runnerId) throws ApiException, IOException {
        prepareActionsAddSelfHostedRunnerToGroupForOrgRequest(org, runnerGroupId,
                runnerId).execute();
    }

    /**
     * Adds a self-hosted runner to a runner group configured in an organization. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsAddSelfHostedRunnerToGroupForOrgAsync(
            final String org,
            final int runnerGroupId,
            final int runnerId) {
        try { 
            return prepareActionsAddSelfHostedRunnerToGroupForOrgRequest(org, runnerGroupId,
            runnerId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsAddSelfHostedRunnerToGroupForOrg.
     */
    private ApiCall<Void, ApiException> prepareActionsAddSelfHostedRunnerToGroupForOrgRequest(
            final String org,
            final int runnerGroupId,
            final int runnerId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_group_id").value(runnerGroupId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes a self-hosted runner from a group configured in an organization. The runner is then
     * returned to the default group. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsRemoveSelfHostedRunnerFromGroupForOrg(
            final String org,
            final int runnerGroupId,
            final int runnerId) throws ApiException, IOException {
        prepareActionsRemoveSelfHostedRunnerFromGroupForOrgRequest(org, runnerGroupId,
                runnerId).execute();
    }

    /**
     * Removes a self-hosted runner from a group configured in an organization. The runner is then
     * returned to the default group. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerGroupId  Required parameter: Unique identifier of the self-hosted runner group.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsRemoveSelfHostedRunnerFromGroupForOrgAsync(
            final String org,
            final int runnerGroupId,
            final int runnerId) {
        try { 
            return prepareActionsRemoveSelfHostedRunnerFromGroupForOrgRequest(org, runnerGroupId,
            runnerId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsRemoveSelfHostedRunnerFromGroupForOrg.
     */
    private ApiCall<Void, ApiException> prepareActionsRemoveSelfHostedRunnerFromGroupForOrgRequest(
            final String org,
            final int runnerGroupId,
            final int runnerId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runner-groups/{runner_group_id}/runners/{runner_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_group_id").value(runnerGroupId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all self-hosted runners configured in an organization. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsRunnersResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsRunnersResponse actionsListSelfHostedRunnersForOrg(
            final String org,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListSelfHostedRunnersForOrgRequest(org, perPage, page).execute();
    }

    /**
     * Lists all self-hosted runners configured in an organization. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsRunnersResponse response from the API call
     */
    public CompletableFuture<OrgsActionsRunnersResponse> actionsListSelfHostedRunnersForOrgAsync(
            final String org,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListSelfHostedRunnersForOrgRequest(org, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListSelfHostedRunnersForOrg.
     */
    private ApiCall<OrgsActionsRunnersResponse, ApiException> prepareActionsListSelfHostedRunnersForOrgRequest(
            final String org,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<OrgsActionsRunnersResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runners")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsRunnersResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists binaries for the runner application that you can download and run. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the List of RunnerApplication response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<RunnerApplication> actionsListRunnerApplicationsForOrg(
            final String org) throws ApiException, IOException {
        return prepareActionsListRunnerApplicationsForOrgRequest(org).execute();
    }

    /**
     * Lists binaries for the runner application that you can download and run. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the List of RunnerApplication response from the API call
     */
    public CompletableFuture<List<RunnerApplication>> actionsListRunnerApplicationsForOrgAsync(
            final String org) {
        try { 
            return prepareActionsListRunnerApplicationsForOrgRequest(org).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListRunnerApplicationsForOrg.
     */
    private ApiCall<List<RunnerApplication>, ApiException> prepareActionsListRunnerApplicationsForOrgRequest(
            final String org) throws IOException {
        return new ApiCall.Builder<List<RunnerApplication>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runners/downloads")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        RunnerApplication[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns a token that you can pass to the `config` script. The token expires after one hour.
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * #### Example using registration token Configure your self-hosted runner, replacing `TOKEN`
     * with the registration token provided by this endpoint. ``` ./config.sh --url
     * https://github.com/octo-org --token TOKEN ```.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the OrgsActionsRunnersRegistrationTokenResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsRunnersRegistrationTokenResponse actionsCreateRegistrationTokenForOrg(
            final String org) throws ApiException, IOException {
        return prepareActionsCreateRegistrationTokenForOrgRequest(org).execute();
    }

    /**
     * Returns a token that you can pass to the `config` script. The token expires after one hour.
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * #### Example using registration token Configure your self-hosted runner, replacing `TOKEN`
     * with the registration token provided by this endpoint. ``` ./config.sh --url
     * https://github.com/octo-org --token TOKEN ```.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the OrgsActionsRunnersRegistrationTokenResponse response from the API call
     */
    public CompletableFuture<OrgsActionsRunnersRegistrationTokenResponse> actionsCreateRegistrationTokenForOrgAsync(
            final String org) {
        try { 
            return prepareActionsCreateRegistrationTokenForOrgRequest(org).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsCreateRegistrationTokenForOrg.
     */
    private ApiCall<OrgsActionsRunnersRegistrationTokenResponse, ApiException> prepareActionsCreateRegistrationTokenForOrgRequest(
            final String org) throws IOException {
        return new ApiCall.Builder<OrgsActionsRunnersRegistrationTokenResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runners/registration-token")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsRunnersRegistrationTokenResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns a token that you can pass to the `config` script to remove a self-hosted runner from
     * an organization. The token expires after one hour. You must authenticate using an access
     * token with the `admin:org` scope to use this endpoint. #### Example using remove token To
     * remove your self-hosted runner from an organization, replace `TOKEN` with the remove token
     * provided by this endpoint. ``` ./config.sh remove --token TOKEN ```.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the OrgsActionsRunnersRemoveTokenResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsRunnersRemoveTokenResponse actionsCreateRemoveTokenForOrg(
            final String org) throws ApiException, IOException {
        return prepareActionsCreateRemoveTokenForOrgRequest(org).execute();
    }

    /**
     * Returns a token that you can pass to the `config` script to remove a self-hosted runner from
     * an organization. The token expires after one hour. You must authenticate using an access
     * token with the `admin:org` scope to use this endpoint. #### Example using remove token To
     * remove your self-hosted runner from an organization, replace `TOKEN` with the remove token
     * provided by this endpoint. ``` ./config.sh remove --token TOKEN ```.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the OrgsActionsRunnersRemoveTokenResponse response from the API call
     */
    public CompletableFuture<OrgsActionsRunnersRemoveTokenResponse> actionsCreateRemoveTokenForOrgAsync(
            final String org) {
        try { 
            return prepareActionsCreateRemoveTokenForOrgRequest(org).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsCreateRemoveTokenForOrg.
     */
    private ApiCall<OrgsActionsRunnersRemoveTokenResponse, ApiException> prepareActionsCreateRemoveTokenForOrgRequest(
            final String org) throws IOException {
        return new ApiCall.Builder<OrgsActionsRunnersRemoveTokenResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runners/remove-token")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsRunnersRemoveTokenResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific self-hosted runner configured in an organization. You must authenticate using
     * an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the OrgsActionsRunnersResponse2 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsRunnersResponse2 actionsGetSelfHostedRunnerForOrg(
            final String org,
            final int runnerId) throws ApiException, IOException {
        return prepareActionsGetSelfHostedRunnerForOrgRequest(org, runnerId).execute();
    }

    /**
     * Gets a specific self-hosted runner configured in an organization. You must authenticate using
     * an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the OrgsActionsRunnersResponse2 response from the API call
     */
    public CompletableFuture<OrgsActionsRunnersResponse2> actionsGetSelfHostedRunnerForOrgAsync(
            final String org,
            final int runnerId) {
        try { 
            return prepareActionsGetSelfHostedRunnerForOrgRequest(org, runnerId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetSelfHostedRunnerForOrg.
     */
    private ApiCall<OrgsActionsRunnersResponse2, ApiException> prepareActionsGetSelfHostedRunnerForOrgRequest(
            final String org,
            final int runnerId) throws IOException {
        return new ApiCall.Builder<OrgsActionsRunnersResponse2, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runners/{runner_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsRunnersResponse2.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Forces the removal of a self-hosted runner from an organization. You can use this endpoint to
     * completely remove the runner when the machine you were using no longer exists. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDeleteSelfHostedRunnerFromOrg(
            final String org,
            final int runnerId) throws ApiException, IOException {
        prepareActionsDeleteSelfHostedRunnerFromOrgRequest(org, runnerId).execute();
    }

    /**
     * Forces the removal of a self-hosted runner from an organization. You can use this endpoint to
     * completely remove the runner when the machine you were using no longer exists. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDeleteSelfHostedRunnerFromOrgAsync(
            final String org,
            final int runnerId) {
        try { 
            return prepareActionsDeleteSelfHostedRunnerFromOrgRequest(org, runnerId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteSelfHostedRunnerFromOrg.
     */
    private ApiCall<Void, ApiException> prepareActionsDeleteSelfHostedRunnerFromOrgRequest(
            final String org,
            final int runnerId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runners/{runner_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all labels for a self-hosted runner configured in an organization. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the ActionsRunnerLabels response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsRunnerLabels actionsListLabelsForSelfHostedRunnerForOrg(
            final String org,
            final int runnerId) throws ApiException, IOException {
        return prepareActionsListLabelsForSelfHostedRunnerForOrgRequest(org, runnerId).execute();
    }

    /**
     * Lists all labels for a self-hosted runner configured in an organization. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the ActionsRunnerLabels response from the API call
     */
    public CompletableFuture<ActionsRunnerLabels> actionsListLabelsForSelfHostedRunnerForOrgAsync(
            final String org,
            final int runnerId) {
        try { 
            return prepareActionsListLabelsForSelfHostedRunnerForOrgRequest(org, runnerId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListLabelsForSelfHostedRunnerForOrg.
     */
    private ApiCall<ActionsRunnerLabels, ApiException> prepareActionsListLabelsForSelfHostedRunnerForOrgRequest(
            final String org,
            final int runnerId) throws IOException {
        return new ApiCall.Builder<ActionsRunnerLabels, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runners/{runner_id}/labels")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsRunnerLabels.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsActionsRunnersLabels404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Add custom labels to a self-hosted runner configured in an organization. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @param  body  Required parameter: Example:
     * @return    Returns the ActionsRunnerLabels response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsRunnerLabels actionsAddCustomLabelsToSelfHostedRunnerForOrg(
            final String org,
            final int runnerId,
            final EnterprisesActionsRunnersLabelsRequest body) throws ApiException, IOException {
        return prepareActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest(org, runnerId,
                body).execute();
    }

    /**
     * Add custom labels to a self-hosted runner configured in an organization. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @param  body  Required parameter: Example:
     * @return    Returns the ActionsRunnerLabels response from the API call
     */
    public CompletableFuture<ActionsRunnerLabels> actionsAddCustomLabelsToSelfHostedRunnerForOrgAsync(
            final String org,
            final int runnerId,
            final EnterprisesActionsRunnersLabelsRequest body) {
        try { 
            return prepareActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest(org, runnerId,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsAddCustomLabelsToSelfHostedRunnerForOrg.
     */
    private ApiCall<ActionsRunnerLabels, ApiException> prepareActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest(
            final String org,
            final int runnerId,
            final EnterprisesActionsRunnersLabelsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ActionsRunnerLabels, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runners/{runner_id}/labels")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsRunnerLabels.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsActionsRunnersLabels404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new OrgsActionsRunnersLabels422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Remove all previous custom labels and set the new custom labels for a specific self-hosted
     * runner configured in an organization. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @param  body  Required parameter: Example:
     * @return    Returns the ActionsRunnerLabels response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsRunnerLabels actionsSetCustomLabelsForSelfHostedRunnerForOrg(
            final String org,
            final int runnerId,
            final OrgsActionsRunnersLabelsRequest1 body) throws ApiException, IOException {
        return prepareActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest(org, runnerId,
                body).execute();
    }

    /**
     * Remove all previous custom labels and set the new custom labels for a specific self-hosted
     * runner configured in an organization. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @param  body  Required parameter: Example:
     * @return    Returns the ActionsRunnerLabels response from the API call
     */
    public CompletableFuture<ActionsRunnerLabels> actionsSetCustomLabelsForSelfHostedRunnerForOrgAsync(
            final String org,
            final int runnerId,
            final OrgsActionsRunnersLabelsRequest1 body) {
        try { 
            return prepareActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest(org, runnerId,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetCustomLabelsForSelfHostedRunnerForOrg.
     */
    private ApiCall<ActionsRunnerLabels, ApiException> prepareActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest(
            final String org,
            final int runnerId,
            final OrgsActionsRunnersLabelsRequest1 body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ActionsRunnerLabels, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runners/{runner_id}/labels")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsRunnerLabels.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsActionsRunnersLabels404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new OrgsActionsRunnersLabels422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Remove all custom labels from a self-hosted runner configured in an organization. Returns the
     * remaining read-only labels from the runner. You must authenticate using an access token with
     * the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the ActionsRunnerLabels response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsRunnerLabels actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg(
            final String org,
            final int runnerId) throws ApiException, IOException {
        return prepareActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest(org,
                runnerId).execute();
    }

    /**
     * Remove all custom labels from a self-hosted runner configured in an organization. Returns the
     * remaining read-only labels from the runner. You must authenticate using an access token with
     * the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the ActionsRunnerLabels response from the API call
     */
    public CompletableFuture<ActionsRunnerLabels> actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgAsync(
            final String org,
            final int runnerId) {
        try { 
            return prepareActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest(org,
            runnerId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg.
     */
    private ApiCall<ActionsRunnerLabels, ApiException> prepareActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest(
            final String org,
            final int runnerId) throws IOException {
        return new ApiCall.Builder<ActionsRunnerLabels, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runners/{runner_id}/labels")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsRunnerLabels.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsActionsRunnersLabels404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Remove a custom label from a self-hosted runner configured in an organization. Returns the
     * remaining labels from the runner. This endpoint returns a `404 Not Found` status if the
     * custom label is not present on the runner. You must authenticate using an access token with
     * the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @param  name  Required parameter: The name of a self-hosted runner's custom label.
     * @return    Returns the ActionsRunnerLabels response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsRunnerLabels actionsRemoveCustomLabelFromSelfHostedRunnerForOrg(
            final String org,
            final int runnerId,
            final String name) throws ApiException, IOException {
        return prepareActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest(org, runnerId,
                name).execute();
    }

    /**
     * Remove a custom label from a self-hosted runner configured in an organization. Returns the
     * remaining labels from the runner. This endpoint returns a `404 Not Found` status if the
     * custom label is not present on the runner. You must authenticate using an access token with
     * the `admin:org` scope to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @param  name  Required parameter: The name of a self-hosted runner's custom label.
     * @return    Returns the ActionsRunnerLabels response from the API call
     */
    public CompletableFuture<ActionsRunnerLabels> actionsRemoveCustomLabelFromSelfHostedRunnerForOrgAsync(
            final String org,
            final int runnerId,
            final String name) {
        try { 
            return prepareActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest(org, runnerId,
            name).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsRemoveCustomLabelFromSelfHostedRunnerForOrg.
     */
    private ApiCall<ActionsRunnerLabels, ApiException> prepareActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest(
            final String org,
            final int runnerId,
            final String name) throws IOException {
        return new ApiCall.Builder<ActionsRunnerLabels, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/runners/{runner_id}/labels/{name}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsRunnerLabels.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsActionsRunnersLabelsName404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new OrgsActionsRunnersLabelsName422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all secrets available in an organization without revealing their encrypted values. You
     * must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsSecretsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsSecretsResponse actionsListOrgSecrets(
            final String org,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListOrgSecretsRequest(org, perPage, page).execute();
    }

    /**
     * Lists all secrets available in an organization without revealing their encrypted values. You
     * must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsSecretsResponse response from the API call
     */
    public CompletableFuture<OrgsActionsSecretsResponse> actionsListOrgSecretsAsync(
            final String org,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListOrgSecretsRequest(org, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListOrgSecrets.
     */
    private ApiCall<OrgsActionsSecretsResponse, ApiException> prepareActionsListOrgSecretsRequest(
            final String org,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<OrgsActionsSecretsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/secrets")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsSecretsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
     * you can create or update secrets. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization
     * permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the OrgsActionsSecretsPublicKeyResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsSecretsPublicKeyResponse actionsGetOrgPublicKey(
            final String org) throws ApiException, IOException {
        return prepareActionsGetOrgPublicKeyRequest(org).execute();
    }

    /**
     * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
     * you can create or update secrets. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization
     * permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @return    Returns the OrgsActionsSecretsPublicKeyResponse response from the API call
     */
    public CompletableFuture<OrgsActionsSecretsPublicKeyResponse> actionsGetOrgPublicKeyAsync(
            final String org) {
        try { 
            return prepareActionsGetOrgPublicKeyRequest(org).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetOrgPublicKey.
     */
    private ApiCall<OrgsActionsSecretsPublicKeyResponse, ApiException> prepareActionsGetOrgPublicKeyRequest(
            final String org) throws IOException {
        return new ApiCall.Builder<OrgsActionsSecretsPublicKeyResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/secrets/public-key")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsSecretsPublicKeyResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a single organization secret without revealing its encrypted value. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub
     * Apps must have the `secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the OrgsActionsSecretsResponse2 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsSecretsResponse2 actionsGetOrgSecret(
            final String org,
            final String secretName) throws ApiException, IOException {
        return prepareActionsGetOrgSecretRequest(org, secretName).execute();
    }

    /**
     * Gets a single organization secret without revealing its encrypted value. You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub
     * Apps must have the `secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the OrgsActionsSecretsResponse2 response from the API call
     */
    public CompletableFuture<OrgsActionsSecretsResponse2> actionsGetOrgSecretAsync(
            final String org,
            final String secretName) {
        try { 
            return prepareActionsGetOrgSecretRequest(org, secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetOrgSecret.
     */
    private ApiCall<OrgsActionsSecretsResponse2, ApiException> prepareActionsGetOrgSecretRequest(
            final String org,
            final String secretName) throws IOException {
        return new ApiCall.Builder<OrgsActionsSecretsResponse2, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/secrets/{secret_name}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsSecretsResponse2.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates or updates an organization secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub
     * Apps must have the `secrets` organization permission to use this endpoint. #### Example
     * encrypting a secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example encrypting a secret using Python Encrypt your secret
     * using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with
     * Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example encrypting a
     * secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object actionsCreateOrUpdateOrgSecret(
            final String org,
            final String secretName,
            final OrgsActionsSecretsRequest body) throws ApiException, IOException {
        return prepareActionsCreateOrUpdateOrgSecretRequest(org, secretName, body).execute();
    }

    /**
     * Creates or updates an organization secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must
     * authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub
     * Apps must have the `secrets` organization permission to use this endpoint. #### Example
     * encrypting a secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example encrypting a secret using Python Encrypt your secret
     * using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with
     * Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example encrypting a
     * secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> actionsCreateOrUpdateOrgSecretAsync(
            final String org,
            final String secretName,
            final OrgsActionsSecretsRequest body) {
        try { 
            return prepareActionsCreateOrUpdateOrgSecretRequest(org, secretName, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsCreateOrUpdateOrgSecret.
     */
    private ApiCall<Object, ApiException> prepareActionsCreateOrUpdateOrgSecretRequest(
            final String org,
            final String secretName,
            final OrgsActionsSecretsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/secrets/{secret_name}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a secret in an organization using the secret name. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
     * `secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDeleteOrgSecret(
            final String org,
            final String secretName) throws ApiException, IOException {
        prepareActionsDeleteOrgSecretRequest(org, secretName).execute();
    }

    /**
     * Deletes a secret in an organization using the secret name. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
     * `secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDeleteOrgSecretAsync(
            final String org,
            final String secretName) {
        try { 
            return prepareActionsDeleteOrgSecretRequest(org, secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteOrgSecret.
     */
    private ApiCall<Void, ApiException> prepareActionsDeleteOrgSecretRequest(
            final String org,
            final String secretName) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/secrets/{secret_name}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all repositories that have been selected when the `visibility` for repository access to
     * a secret is set to `selected`. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization
     * permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the OrgsActionsSecretsRepositoriesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsSecretsRepositoriesResponse actionsListSelectedReposForOrgSecret(
            final String org,
            final String secretName,
            final Integer page,
            final Integer perPage) throws ApiException, IOException {
        return prepareActionsListSelectedReposForOrgSecretRequest(org, secretName, page,
                perPage).execute();
    }

    /**
     * Lists all repositories that have been selected when the `visibility` for repository access to
     * a secret is set to `selected`. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization
     * permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the OrgsActionsSecretsRepositoriesResponse response from the API call
     */
    public CompletableFuture<OrgsActionsSecretsRepositoriesResponse> actionsListSelectedReposForOrgSecretAsync(
            final String org,
            final String secretName,
            final Integer page,
            final Integer perPage) {
        try { 
            return prepareActionsListSelectedReposForOrgSecretRequest(org, secretName, page,
            perPage).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListSelectedReposForOrgSecret.
     */
    private ApiCall<OrgsActionsSecretsRepositoriesResponse, ApiException> prepareActionsListSelectedReposForOrgSecretRequest(
            final String org,
            final String secretName,
            final Integer page,
            final Integer perPage) throws IOException {
        return new ApiCall.Builder<OrgsActionsSecretsRepositoriesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/secrets/{secret_name}/repositories")
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsSecretsRepositoriesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Replaces all repositories for an organization secret when the `visibility` for repository
     * access is set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsSetSelectedReposForOrgSecret(
            final String org,
            final String secretName,
            final OrgsActionsSecretsRepositoriesRequest body) throws ApiException, IOException {
        prepareActionsSetSelectedReposForOrgSecretRequest(org, secretName, body).execute();
    }

    /**
     * Replaces all repositories for an organization secret when the `visibility` for repository
     * access is set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsSetSelectedReposForOrgSecretAsync(
            final String org,
            final String secretName,
            final OrgsActionsSecretsRepositoriesRequest body) {
        try { 
            return prepareActionsSetSelectedReposForOrgSecretRequest(org, secretName, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetSelectedReposForOrgSecret.
     */
    private ApiCall<Void, ApiException> prepareActionsSetSelectedReposForOrgSecretRequest(
            final String org,
            final String secretName,
            final OrgsActionsSecretsRepositoriesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/secrets/{secret_name}/repositories")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Adds a repository to an organization secret when the `visibility` for repository access is
     * set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsAddSelectedRepoToOrgSecret(
            final String org,
            final String secretName,
            final int repositoryId) throws ApiException, IOException {
        prepareActionsAddSelectedRepoToOrgSecretRequest(org, secretName, repositoryId).execute();
    }

    /**
     * Adds a repository to an organization secret when the `visibility` for repository access is
     * set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsAddSelectedRepoToOrgSecretAsync(
            final String org,
            final String secretName,
            final int repositoryId) {
        try { 
            return prepareActionsAddSelectedRepoToOrgSecretRequest(org, secretName,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsAddSelectedRepoToOrgSecret.
     */
    private ApiCall<Void, ApiException> prepareActionsAddSelectedRepoToOrgSecretRequest(
            final String org,
            final String secretName,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict when visibility type is not set to selected",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes a repository from an organization secret when the `visibility` for repository access
     * is set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsRemoveSelectedRepoFromOrgSecret(
            final String org,
            final String secretName,
            final int repositoryId) throws ApiException, IOException {
        prepareActionsRemoveSelectedRepoFromOrgSecretRequest(org, secretName,
                repositoryId).execute();
    }

    /**
     * Removes a repository from an organization secret when the `visibility` for repository access
     * is set to `selected`. The visibility is set when you [Create or update an organization
     * secret](https://docs.github.com/rest/reference/actions#create-or-update-an-organization-secret).
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `secrets` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  repositoryId  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsRemoveSelectedRepoFromOrgSecretAsync(
            final String org,
            final String secretName,
            final int repositoryId) {
        try { 
            return prepareActionsRemoveSelectedRepoFromOrgSecretRequest(org, secretName,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsRemoveSelectedRepoFromOrgSecret.
     */
    private ApiCall<Void, ApiException> prepareActionsRemoveSelectedRepoFromOrgSecretRequest(
            final String org,
            final String secretName,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict when visibility type not set to selected",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all organization variables. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the
     * `organization_actions_variables:read` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 30).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsVariablesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsVariablesResponse actionsListOrgVariables(
            final String org,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListOrgVariablesRequest(org, perPage, page).execute();
    }

    /**
     * Lists all organization variables. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the
     * `organization_actions_variables:read` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 30).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsVariablesResponse response from the API call
     */
    public CompletableFuture<OrgsActionsVariablesResponse> actionsListOrgVariablesAsync(
            final String org,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListOrgVariablesRequest(org, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListOrgVariables.
     */
    private ApiCall<OrgsActionsVariablesResponse, ApiException> prepareActionsListOrgVariablesRequest(
            final String org,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<OrgsActionsVariablesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/variables")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 10).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsVariablesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates an organization variable that you can reference in a GitHub Actions workflow. You
     * must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `organization_actions_variables:write` organization permission to
     * use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object actionsCreateOrgVariable(
            final String org,
            final OrgsActionsVariablesRequest body) throws ApiException, IOException {
        return prepareActionsCreateOrgVariableRequest(org, body).execute();
    }

    /**
     * Creates an organization variable that you can reference in a GitHub Actions workflow. You
     * must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `organization_actions_variables:write` organization permission to
     * use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> actionsCreateOrgVariableAsync(
            final String org,
            final OrgsActionsVariablesRequest body) {
        try { 
            return prepareActionsCreateOrgVariableRequest(org, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsCreateOrgVariable.
     */
    private ApiCall<Object, ApiException> prepareActionsCreateOrgVariableRequest(
            final String org,
            final OrgsActionsVariablesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/variables")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific variable in an organization. You must authenticate using an access token with
     * the `admin:org` scope to use this endpoint. GitHub Apps must have the
     * `organization_actions_variables:read` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @return    Returns the OrgsActionsVariablesResponse2 response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsVariablesResponse2 actionsGetOrgVariable(
            final String org,
            final String name) throws ApiException, IOException {
        return prepareActionsGetOrgVariableRequest(org, name).execute();
    }

    /**
     * Gets a specific variable in an organization. You must authenticate using an access token with
     * the `admin:org` scope to use this endpoint. GitHub Apps must have the
     * `organization_actions_variables:read` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @return    Returns the OrgsActionsVariablesResponse2 response from the API call
     */
    public CompletableFuture<OrgsActionsVariablesResponse2> actionsGetOrgVariableAsync(
            final String org,
            final String name) {
        try { 
            return prepareActionsGetOrgVariableRequest(org, name).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetOrgVariable.
     */
    private ApiCall<OrgsActionsVariablesResponse2, ApiException> prepareActionsGetOrgVariableRequest(
            final String org,
            final String name) throws IOException {
        return new ApiCall.Builder<OrgsActionsVariablesResponse2, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/variables/{name}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsVariablesResponse2.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates an organization variable that you can reference in a GitHub Actions workflow. You
     * must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `organization_actions_variables:write` organization permission to
     * use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsUpdateOrgVariable(
            final String org,
            final String name,
            final OrgsActionsVariablesRequest1 body) throws ApiException, IOException {
        prepareActionsUpdateOrgVariableRequest(org, name, body).execute();
    }

    /**
     * Updates an organization variable that you can reference in a GitHub Actions workflow. You
     * must authenticate using an access token with the `admin:org` scope to use this endpoint.
     * GitHub Apps must have the `organization_actions_variables:write` organization permission to
     * use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsUpdateOrgVariableAsync(
            final String org,
            final String name,
            final OrgsActionsVariablesRequest1 body) {
        try { 
            return prepareActionsUpdateOrgVariableRequest(org, name, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsUpdateOrgVariable.
     */
    private ApiCall<Void, ApiException> prepareActionsUpdateOrgVariableRequest(
            final String org,
            final String name,
            final OrgsActionsVariablesRequest1 body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/variables/{name}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes an organization variable using the variable name. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
     * `organization_actions_variables:write` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDeleteOrgVariable(
            final String org,
            final String name) throws ApiException, IOException {
        prepareActionsDeleteOrgVariableRequest(org, name).execute();
    }

    /**
     * Deletes an organization variable using the variable name. You must authenticate using an
     * access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the
     * `organization_actions_variables:write` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDeleteOrgVariableAsync(
            final String org,
            final String name) {
        try { 
            return prepareActionsDeleteOrgVariableRequest(org, name).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteOrgVariable.
     */
    private ApiCall<Void, ApiException> prepareActionsDeleteOrgVariableRequest(
            final String org,
            final String name) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/variables/{name}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all repositories that can access an organization variable that is available to selected
     * repositories. You must authenticate using an access token with the `admin:org` scope to use
     * this endpoint. GitHub Apps must have the `organization_actions_variables:read` organization
     * permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the OrgsActionsSecretsRepositoriesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsSecretsRepositoriesResponse actionsListSelectedReposForOrgVariable(
            final String org,
            final String name,
            final Integer page,
            final Integer perPage) throws ApiException, IOException {
        return prepareActionsListSelectedReposForOrgVariableRequest(org, name, page,
                perPage).execute();
    }

    /**
     * Lists all repositories that can access an organization variable that is available to selected
     * repositories. You must authenticate using an access token with the `admin:org` scope to use
     * this endpoint. GitHub Apps must have the `organization_actions_variables:read` organization
     * permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the OrgsActionsSecretsRepositoriesResponse response from the API call
     */
    public CompletableFuture<OrgsActionsSecretsRepositoriesResponse> actionsListSelectedReposForOrgVariableAsync(
            final String org,
            final String name,
            final Integer page,
            final Integer perPage) {
        try { 
            return prepareActionsListSelectedReposForOrgVariableRequest(org, name, page,
            perPage).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListSelectedReposForOrgVariable.
     */
    private ApiCall<OrgsActionsSecretsRepositoriesResponse, ApiException> prepareActionsListSelectedReposForOrgVariableRequest(
            final String org,
            final String name,
            final Integer page,
            final Integer perPage) throws IOException {
        return new ApiCall.Builder<OrgsActionsSecretsRepositoriesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/variables/{name}/repositories")
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsSecretsRepositoriesResponse.class))
                        .nullify404(false)
                        .localErrorCase("409",
                                 ErrorCase.create("Response when the visibility of the variable is not set to `selected`",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Replaces all repositories for an organization variable that is available to selected
     * repositories. Organization variables that are available to selected repositories have their
     * `visibility` field set to `selected`. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the
     * `organization_actions_variables:write` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsSetSelectedReposForOrgVariable(
            final String org,
            final String name,
            final OrgsActionsVariablesRepositoriesRequest body) throws ApiException, IOException {
        prepareActionsSetSelectedReposForOrgVariableRequest(org, name, body).execute();
    }

    /**
     * Replaces all repositories for an organization variable that is available to selected
     * repositories. Organization variables that are available to selected repositories have their
     * `visibility` field set to `selected`. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the
     * `organization_actions_variables:write` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsSetSelectedReposForOrgVariableAsync(
            final String org,
            final String name,
            final OrgsActionsVariablesRepositoriesRequest body) {
        try { 
            return prepareActionsSetSelectedReposForOrgVariableRequest(org, name, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetSelectedReposForOrgVariable.
     */
    private ApiCall<Void, ApiException> prepareActionsSetSelectedReposForOrgVariableRequest(
            final String org,
            final String name,
            final OrgsActionsVariablesRepositoriesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/variables/{name}/repositories")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("409",
                                 ErrorCase.create("Response when the visibility of the variable is not set to `selected`",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Adds a repository to an organization variable that is available to selected repositories.
     * Organization variables that are available to selected repositories have their `visibility`
     * field set to `selected`. You must authenticate using an access token with the `admin:org`
     * scope to use this endpoint. GitHub Apps must have the `organization_actions_variables:write`
     * organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @param  repositoryId  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsAddSelectedRepoToOrgVariable(
            final String org,
            final String name,
            final int repositoryId) throws ApiException, IOException {
        prepareActionsAddSelectedRepoToOrgVariableRequest(org, name, repositoryId).execute();
    }

    /**
     * Adds a repository to an organization variable that is available to selected repositories.
     * Organization variables that are available to selected repositories have their `visibility`
     * field set to `selected`. You must authenticate using an access token with the `admin:org`
     * scope to use this endpoint. GitHub Apps must have the `organization_actions_variables:write`
     * organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @param  repositoryId  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsAddSelectedRepoToOrgVariableAsync(
            final String org,
            final String name,
            final int repositoryId) {
        try { 
            return prepareActionsAddSelectedRepoToOrgVariableRequest(org, name,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsAddSelectedRepoToOrgVariable.
     */
    private ApiCall<Void, ApiException> prepareActionsAddSelectedRepoToOrgVariableRequest(
            final String org,
            final String name,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/variables/{name}/repositories/{repository_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("409",
                                 ErrorCase.create("Response when the visibility of the variable is not set to `selected`",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes a repository from an organization variable that is available to selected
     * repositories. Organization variables that are available to selected repositories have their
     * `visibility` field set to `selected`. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the
     * `organization_actions_variables:write` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @param  repositoryId  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsRemoveSelectedRepoFromOrgVariable(
            final String org,
            final String name,
            final int repositoryId) throws ApiException, IOException {
        prepareActionsRemoveSelectedRepoFromOrgVariableRequest(org, name, repositoryId).execute();
    }

    /**
     * Removes a repository from an organization variable that is available to selected
     * repositories. Organization variables that are available to selected repositories have their
     * `visibility` field set to `selected`. You must authenticate using an access token with the
     * `admin:org` scope to use this endpoint. GitHub Apps must have the
     * `organization_actions_variables:write` organization permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @param  repositoryId  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsRemoveSelectedRepoFromOrgVariableAsync(
            final String org,
            final String name,
            final int repositoryId) {
        try { 
            return prepareActionsRemoveSelectedRepoFromOrgVariableRequest(org, name,
            repositoryId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsRemoveSelectedRepoFromOrgVariable.
     */
    private ApiCall<Void, ApiException> prepareActionsRemoveSelectedRepoFromOrgVariableRequest(
            final String org,
            final String name,
            final int repositoryId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/actions/variables/{name}/repositories/{repository_id}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("409",
                                 ErrorCase.create("Response when the visibility of the variable is not set to `selected`",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the required workflows in a repository. Anyone with read access to the repository can
     * use this endpoint. If the repository is private you must use an access token with the `repo`
     * scope. GitHub Apps must have the `actions:read` permission to use this endpoint. For more
     * information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsRequiredWorkflowsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsRequiredWorkflowsResponse actionsListRepoRequiredWorkflows(
            final String org,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListRepoRequiredWorkflowsRequest(org, repo, perPage, page).execute();
    }

    /**
     * Lists the required workflows in a repository. Anyone with read access to the repository can
     * use this endpoint. If the repository is private you must use an access token with the `repo`
     * scope. GitHub Apps must have the `actions:read` permission to use this endpoint. For more
     * information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsRequiredWorkflowsResponse response from the API call
     */
    public CompletableFuture<ReposActionsRequiredWorkflowsResponse> actionsListRepoRequiredWorkflowsAsync(
            final String org,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListRepoRequiredWorkflowsRequest(org, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListRepoRequiredWorkflows.
     */
    private ApiCall<ReposActionsRequiredWorkflowsResponse, ApiException> prepareActionsListRepoRequiredWorkflowsRequest(
            final String org,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposActionsRequiredWorkflowsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{org}/{repo}/actions/required_workflows")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsRequiredWorkflowsResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposActionsRequiredWorkflows404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific required workflow present in a repository. Anyone with read access to the
     * repository can use this endpoint. If the repository is private you must use an access token
     * with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this
     * endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  requiredWorkflowIdForRepo  Required parameter: The ID of the required workflow that
     *         has run at least once in a repository.
     * @return    Returns the ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoResponse actionsGetRepoRequiredWorkflow(
            final String org,
            final String repo,
            final int requiredWorkflowIdForRepo) throws ApiException, IOException {
        return prepareActionsGetRepoRequiredWorkflowRequest(org, repo,
                requiredWorkflowIdForRepo).execute();
    }

    /**
     * Gets a specific required workflow present in a repository. Anyone with read access to the
     * repository can use this endpoint. If the repository is private you must use an access token
     * with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this
     * endpoint. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  requiredWorkflowIdForRepo  Required parameter: The ID of the required workflow that
     *         has run at least once in a repository.
     * @return    Returns the ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoResponse response from the API call
     */
    public CompletableFuture<ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoResponse> actionsGetRepoRequiredWorkflowAsync(
            final String org,
            final String repo,
            final int requiredWorkflowIdForRepo) {
        try { 
            return prepareActionsGetRepoRequiredWorkflowRequest(org, repo,
            requiredWorkflowIdForRepo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetRepoRequiredWorkflow.
     */
    private ApiCall<ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoResponse, ApiException> prepareActionsGetRepoRequiredWorkflowRequest(
            final String org,
            final String repo,
            final int requiredWorkflowIdForRepo) throws IOException {
        return new ApiCall.Builder<ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{org}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("required_workflow_id_for_repo").value(requiredWorkflowIdForRepo).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepo404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the number of billable minutes used by a specific required workflow during the current
     * billing cycle. Billable minutes only apply to required workflows running in private
     * repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner
     * operating system in milliseconds. Any job re-runs are also included in the usage. The usage
     * does not include the multiplier for macOS and Windows runners and is not rounded up to the
     * nearest whole minute. For more information, see "[Managing billing for GitHub
     * Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)."
     * Anyone with read access to the repository can use this endpoint. If the repository is private
     * you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
     * permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  requiredWorkflowIdForRepo  Required parameter: The ID of the required workflow that
     *         has run at least once in a repository.
     * @return    Returns the ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoTimingResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoTimingResponse actionsGetRepoRequiredWorkflowUsage(
            final String org,
            final String repo,
            final int requiredWorkflowIdForRepo) throws ApiException, IOException {
        return prepareActionsGetRepoRequiredWorkflowUsageRequest(org, repo,
                requiredWorkflowIdForRepo).execute();
    }

    /**
     * Gets the number of billable minutes used by a specific required workflow during the current
     * billing cycle. Billable minutes only apply to required workflows running in private
     * repositories that use GitHub-hosted runners. Usage is listed for each GitHub-hosted runner
     * operating system in milliseconds. Any job re-runs are also included in the usage. The usage
     * does not include the multiplier for macOS and Windows runners and is not rounded up to the
     * nearest whole minute. For more information, see "[Managing billing for GitHub
     * Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)."
     * Anyone with read access to the repository can use this endpoint. If the repository is private
     * you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
     * permission to use this endpoint.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  requiredWorkflowIdForRepo  Required parameter: The ID of the required workflow that
     *         has run at least once in a repository.
     * @return    Returns the ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoTimingResponse response from the API call
     */
    public CompletableFuture<ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoTimingResponse> actionsGetRepoRequiredWorkflowUsageAsync(
            final String org,
            final String repo,
            final int requiredWorkflowIdForRepo) {
        try { 
            return prepareActionsGetRepoRequiredWorkflowUsageRequest(org, repo,
            requiredWorkflowIdForRepo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetRepoRequiredWorkflowUsage.
     */
    private ApiCall<ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoTimingResponse, ApiException> prepareActionsGetRepoRequiredWorkflowUsageRequest(
            final String org,
            final String repo,
            final int requiredWorkflowIdForRepo) throws IOException {
        return new ApiCall.Builder<ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoTimingResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{org}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}/timing")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("required_workflow_id_for_repo").value(requiredWorkflowIdForRepo).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoTimingResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoTiming404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all artifacts for a repository. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  name  Optional parameter: Filters artifacts by exact match on their name field.
     * @return    Returns the ReposActionsArtifactsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsArtifactsResponse actionsListArtifactsForRepo(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page,
            final String name) throws ApiException, IOException {
        return prepareActionsListArtifactsForRepoRequest(owner, repo, perPage, page,
                name).execute();
    }

    /**
     * Lists all artifacts for a repository. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  name  Optional parameter: Filters artifacts by exact match on their name field.
     * @return    Returns the ReposActionsArtifactsResponse response from the API call
     */
    public CompletableFuture<ReposActionsArtifactsResponse> actionsListArtifactsForRepoAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page,
            final String name) {
        try { 
            return prepareActionsListArtifactsForRepoRequest(owner, repo, perPage, page,
            name).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListArtifactsForRepo.
     */
    private ApiCall<ReposActionsArtifactsResponse, ApiException> prepareActionsListArtifactsForRepoRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page,
            final String name) throws IOException {
        return new ApiCall.Builder<ReposActionsArtifactsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/artifacts")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("name")
                                .value(name).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsArtifactsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific artifact for a workflow run. Anyone with read access to the repository can
     * use this endpoint. If the repository is private you must use an access token with the `repo`
     * scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  artifactId  Required parameter: The unique identifier of the artifact.
     * @return    Returns the ReposActionsArtifactsArtifactIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsArtifactsArtifactIdResponse actionsGetArtifact(
            final String owner,
            final String repo,
            final int artifactId) throws ApiException, IOException {
        return prepareActionsGetArtifactRequest(owner, repo, artifactId).execute();
    }

    /**
     * Gets a specific artifact for a workflow run. Anyone with read access to the repository can
     * use this endpoint. If the repository is private you must use an access token with the `repo`
     * scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  artifactId  Required parameter: The unique identifier of the artifact.
     * @return    Returns the ReposActionsArtifactsArtifactIdResponse response from the API call
     */
    public CompletableFuture<ReposActionsArtifactsArtifactIdResponse> actionsGetArtifactAsync(
            final String owner,
            final String repo,
            final int artifactId) {
        try { 
            return prepareActionsGetArtifactRequest(owner, repo, artifactId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetArtifact.
     */
    private ApiCall<ReposActionsArtifactsArtifactIdResponse, ApiException> prepareActionsGetArtifactRequest(
            final String owner,
            final String repo,
            final int artifactId) throws IOException {
        return new ApiCall.Builder<ReposActionsArtifactsArtifactIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/artifacts/{artifact_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("artifact_id").value(artifactId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsArtifactsArtifactIdResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes an artifact for a workflow run. You must authenticate using an access token with the
     * `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to
     * use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  artifactId  Required parameter: The unique identifier of the artifact.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDeleteArtifact(
            final String owner,
            final String repo,
            final int artifactId) throws ApiException, IOException {
        prepareActionsDeleteArtifactRequest(owner, repo, artifactId).execute();
    }

    /**
     * Deletes an artifact for a workflow run. You must authenticate using an access token with the
     * `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to
     * use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  artifactId  Required parameter: The unique identifier of the artifact.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDeleteArtifactAsync(
            final String owner,
            final String repo,
            final int artifactId) {
        try { 
            return prepareActionsDeleteArtifactRequest(owner, repo, artifactId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteArtifact.
     */
    private ApiCall<Void, ApiException> prepareActionsDeleteArtifactRequest(
            final String owner,
            final String repo,
            final int artifactId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/artifacts/{artifact_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("artifact_id").value(artifactId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute.
     * Look for `Location:` in the response header to find the URL for the download. The
     * `:archive_format` must be `zip`. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  artifactId  Required parameter: The unique identifier of the artifact.
     * @param  archiveFormat  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDownloadArtifact(
            final String owner,
            final String repo,
            final int artifactId,
            final String archiveFormat) throws ApiException, IOException {
        prepareActionsDownloadArtifactRequest(owner, repo, artifactId, archiveFormat).execute();
    }

    /**
     * Gets a redirect URL to download an archive for a repository. This URL expires after 1 minute.
     * Look for `Location:` in the response header to find the URL for the download. The
     * `:archive_format` must be `zip`. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  artifactId  Required parameter: The unique identifier of the artifact.
     * @param  archiveFormat  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDownloadArtifactAsync(
            final String owner,
            final String repo,
            final int artifactId,
            final String archiveFormat) {
        try { 
            return prepareActionsDownloadArtifactRequest(owner, repo, artifactId,
            archiveFormat).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDownloadArtifact.
     */
    private ApiCall<Void, ApiException> prepareActionsDownloadArtifactRequest(
            final String owner,
            final String repo,
            final int artifactId,
            final String archiveFormat) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("artifact_id").value(artifactId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("archive_format").value(archiveFormat)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("410",
                                 ErrorCase.create("Gone",
                                (reason, context) -> new ReposActionsArtifactsArtifactIdArchiveFormat410ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets GitHub Actions cache usage for a repository. The data fetched using this API is
     * refreshed approximately every 5 minutes, so values returned from this endpoint may take at
     * least 5 minutes to get updated. Anyone with read access to the repository can use this
     * endpoint. If the repository is private, you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposActionsCacheUsageResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsCacheUsageResponse actionsGetActionsCacheUsage(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareActionsGetActionsCacheUsageRequest(owner, repo).execute();
    }

    /**
     * Gets GitHub Actions cache usage for a repository. The data fetched using this API is
     * refreshed approximately every 5 minutes, so values returned from this endpoint may take at
     * least 5 minutes to get updated. Anyone with read access to the repository can use this
     * endpoint. If the repository is private, you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposActionsCacheUsageResponse response from the API call
     */
    public CompletableFuture<ReposActionsCacheUsageResponse> actionsGetActionsCacheUsageAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActionsGetActionsCacheUsageRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetActionsCacheUsage.
     */
    private ApiCall<ReposActionsCacheUsageResponse, ApiException> prepareActionsGetActionsCacheUsageRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposActionsCacheUsageResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/cache/usage")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsCacheUsageResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the GitHub Actions caches for a repository. You must authenticate using an access token
     * with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:read`
     * permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  ref  Optional parameter: The Git reference for the results you want to list. The
     *         `ref` for a branch can be formatted either as `refs/heads/&lt;branch name&gt;` or simply
     *         `&lt;branch name&gt;`. To reference a pull request use `refs/pull/&lt;number&gt;/merge`.
     * @param  key  Optional parameter: An explicit key or prefix for identifying the cache
     * @param  sort  Optional parameter: The property to sort the results by. `created_at` means
     *         when the cache was created. `last_accessed_at` means when the cache was last
     *         accessed. `size_in_bytes` is the size of the cache in bytes.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @return    Returns the ReposActionsCachesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsCachesResponse actionsGetActionsCacheList(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page,
            final String ref,
            final String key,
            final Sort71Enum sort,
            final Direction1Enum direction) throws ApiException, IOException {
        return prepareActionsGetActionsCacheListRequest(owner, repo, perPage, page, ref, key, sort,
                direction).execute();
    }

    /**
     * Lists the GitHub Actions caches for a repository. You must authenticate using an access token
     * with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:read`
     * permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  ref  Optional parameter: The Git reference for the results you want to list. The
     *         `ref` for a branch can be formatted either as `refs/heads/&lt;branch name&gt;` or simply
     *         `&lt;branch name&gt;`. To reference a pull request use `refs/pull/&lt;number&gt;/merge`.
     * @param  key  Optional parameter: An explicit key or prefix for identifying the cache
     * @param  sort  Optional parameter: The property to sort the results by. `created_at` means
     *         when the cache was created. `last_accessed_at` means when the cache was last
     *         accessed. `size_in_bytes` is the size of the cache in bytes.
     * @param  direction  Optional parameter: The direction to sort the results by.
     * @return    Returns the ReposActionsCachesResponse response from the API call
     */
    public CompletableFuture<ReposActionsCachesResponse> actionsGetActionsCacheListAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page,
            final String ref,
            final String key,
            final Sort71Enum sort,
            final Direction1Enum direction) {
        try { 
            return prepareActionsGetActionsCacheListRequest(owner, repo, perPage, page, ref, key, sort,
            direction).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetActionsCacheList.
     */
    private ApiCall<ReposActionsCachesResponse, ApiException> prepareActionsGetActionsCacheListRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page,
            final String ref,
            final String key,
            final Sort71Enum sort,
            final Direction1Enum direction) throws IOException {
        return new ApiCall.Builder<ReposActionsCachesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/caches")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("ref")
                                .value(ref).isRequired(false))
                        .queryParam(param -> param.key("key")
                                .value(key).isRequired(false))
                        .queryParam(param -> param.key("sort")
                                .value((sort != null) ? sort.value() : null).isRequired(false))
                        .queryParam(param -> param.key("direction")
                                .value((direction != null) ? direction.value() : null).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsCachesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes one or more GitHub Actions caches for a repository, using a complete cache key. By
     * default, all caches that match the provided key are deleted, but you can optionally provide a
     * Git ref to restrict deletions to caches that match both the provided key and the Git ref. You
     * must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
     * Apps must have the `actions:write` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  key  Required parameter: A key for identifying the cache.
     * @param  ref  Optional parameter: The Git reference for the results you want to list. The
     *         `ref` for a branch can be formatted either as `refs/heads/&lt;branch name&gt;` or simply
     *         `&lt;branch name&gt;`. To reference a pull request use `refs/pull/&lt;number&gt;/merge`.
     * @return    Returns the ReposActionsCachesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsCachesResponse actionsDeleteActionsCacheByKey(
            final String owner,
            final String repo,
            final String key,
            final String ref) throws ApiException, IOException {
        return prepareActionsDeleteActionsCacheByKeyRequest(owner, repo, key, ref).execute();
    }

    /**
     * Deletes one or more GitHub Actions caches for a repository, using a complete cache key. By
     * default, all caches that match the provided key are deleted, but you can optionally provide a
     * Git ref to restrict deletions to caches that match both the provided key and the Git ref. You
     * must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
     * Apps must have the `actions:write` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  key  Required parameter: A key for identifying the cache.
     * @param  ref  Optional parameter: The Git reference for the results you want to list. The
     *         `ref` for a branch can be formatted either as `refs/heads/&lt;branch name&gt;` or simply
     *         `&lt;branch name&gt;`. To reference a pull request use `refs/pull/&lt;number&gt;/merge`.
     * @return    Returns the ReposActionsCachesResponse response from the API call
     */
    public CompletableFuture<ReposActionsCachesResponse> actionsDeleteActionsCacheByKeyAsync(
            final String owner,
            final String repo,
            final String key,
            final String ref) {
        try { 
            return prepareActionsDeleteActionsCacheByKeyRequest(owner, repo, key, ref).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteActionsCacheByKey.
     */
    private ApiCall<ReposActionsCachesResponse, ApiException> prepareActionsDeleteActionsCacheByKeyRequest(
            final String owner,
            final String repo,
            final String key,
            final String ref) throws IOException {
        return new ApiCall.Builder<ReposActionsCachesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/caches")
                        .queryParam(param -> param.key("key")
                                .value(key))
                        .queryParam(param -> param.key("ref")
                                .value(ref).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsCachesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a GitHub Actions cache for a repository, using a cache ID. You must authenticate
     * using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `actions:write` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  cacheId  Required parameter: The unique identifier of the GitHub Actions cache.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDeleteActionsCacheById(
            final String owner,
            final String repo,
            final int cacheId) throws ApiException, IOException {
        prepareActionsDeleteActionsCacheByIdRequest(owner, repo, cacheId).execute();
    }

    /**
     * Deletes a GitHub Actions cache for a repository, using a cache ID. You must authenticate
     * using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `actions:write` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  cacheId  Required parameter: The unique identifier of the GitHub Actions cache.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDeleteActionsCacheByIdAsync(
            final String owner,
            final String repo,
            final int cacheId) {
        try { 
            return prepareActionsDeleteActionsCacheByIdRequest(owner, repo, cacheId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteActionsCacheById.
     */
    private ApiCall<Void, ApiException> prepareActionsDeleteActionsCacheByIdRequest(
            final String owner,
            final String repo,
            final int cacheId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/caches/{cache_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("cache_id").value(cacheId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific job in a workflow run. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  jobId  Required parameter: The unique identifier of the job.
     * @return    Returns the ReposActionsJobsJobIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsJobsJobIdResponse actionsGetJobForWorkflowRun(
            final String owner,
            final String repo,
            final int jobId) throws ApiException, IOException {
        return prepareActionsGetJobForWorkflowRunRequest(owner, repo, jobId).execute();
    }

    /**
     * Gets a specific job in a workflow run. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  jobId  Required parameter: The unique identifier of the job.
     * @return    Returns the ReposActionsJobsJobIdResponse response from the API call
     */
    public CompletableFuture<ReposActionsJobsJobIdResponse> actionsGetJobForWorkflowRunAsync(
            final String owner,
            final String repo,
            final int jobId) {
        try { 
            return prepareActionsGetJobForWorkflowRunRequest(owner, repo, jobId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetJobForWorkflowRun.
     */
    private ApiCall<ReposActionsJobsJobIdResponse, ApiException> prepareActionsGetJobForWorkflowRunRequest(
            final String owner,
            final String repo,
            final int jobId) throws IOException {
        return new ApiCall.Builder<ReposActionsJobsJobIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/jobs/{job_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("job_id").value(jobId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsJobsJobIdResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a redirect URL to download a plain text file of logs for a workflow job. This link
     * expires after 1 minute. Look for `Location:` in the response header to find the URL for the
     * download. Anyone with read access to the repository can use this endpoint. If the repository
     * is private you must use an access token with the `repo` scope. GitHub Apps must have the
     * `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  jobId  Required parameter: The unique identifier of the job.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDownloadJobLogsForWorkflowRun(
            final String owner,
            final String repo,
            final int jobId) throws ApiException, IOException {
        prepareActionsDownloadJobLogsForWorkflowRunRequest(owner, repo, jobId).execute();
    }

    /**
     * Gets a redirect URL to download a plain text file of logs for a workflow job. This link
     * expires after 1 minute. Look for `Location:` in the response header to find the URL for the
     * download. Anyone with read access to the repository can use this endpoint. If the repository
     * is private you must use an access token with the `repo` scope. GitHub Apps must have the
     * `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  jobId  Required parameter: The unique identifier of the job.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDownloadJobLogsForWorkflowRunAsync(
            final String owner,
            final String repo,
            final int jobId) {
        try { 
            return prepareActionsDownloadJobLogsForWorkflowRunRequest(owner, repo, jobId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDownloadJobLogsForWorkflowRun.
     */
    private ApiCall<Void, ApiException> prepareActionsDownloadJobLogsForWorkflowRunRequest(
            final String owner,
            final String repo,
            final int jobId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/jobs/{job_id}/logs")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("job_id").value(jobId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Re-run a job and its dependent jobs in a workflow run. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write`
     * permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  jobId  Required parameter: The unique identifier of the job.
     * @param  body  Optional parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object actionsReRunJobForWorkflowRun(
            final String owner,
            final String repo,
            final int jobId,
            final Object body) throws ApiException, IOException {
        return prepareActionsReRunJobForWorkflowRunRequest(owner, repo, jobId, body).execute();
    }

    /**
     * Re-run a job and its dependent jobs in a workflow run. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write`
     * permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  jobId  Required parameter: The unique identifier of the job.
     * @param  body  Optional parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> actionsReRunJobForWorkflowRunAsync(
            final String owner,
            final String repo,
            final int jobId,
            final Object body) {
        try { 
            return prepareActionsReRunJobForWorkflowRunRequest(owner, repo, jobId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsReRunJobForWorkflowRun.
     */
    private ApiCall<Object, ApiException> prepareActionsReRunJobForWorkflowRunRequest(
            final String owner,
            final String repo,
            final int jobId,
            final Object body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/jobs/{job_id}/rerun")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("job_id").value(jobId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposActionsJobsJobIdRerun403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the customization template for an OpenID Connect (OIDC) subject claim. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `organization_administration:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposActionsOidcCustomizationSubResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsOidcCustomizationSubResponse actionsGetCustomOidcSubClaimForRepo(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareActionsGetCustomOidcSubClaimForRepoRequest(owner, repo).execute();
    }

    /**
     * Gets the customization template for an OpenID Connect (OIDC) subject claim. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `organization_administration:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposActionsOidcCustomizationSubResponse response from the API call
     */
    public CompletableFuture<ReposActionsOidcCustomizationSubResponse> actionsGetCustomOidcSubClaimForRepoAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActionsGetCustomOidcSubClaimForRepoRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetCustomOidcSubClaimForRepo.
     */
    private ApiCall<ReposActionsOidcCustomizationSubResponse, ApiException> prepareActionsGetCustomOidcSubClaimForRepoRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposActionsOidcCustomizationSubResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/oidc/customization/sub")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsOidcCustomizationSubResponse.class))
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new ReposActionsOidcCustomizationSub400ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposActionsOidcCustomizationSub404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sets the customization template and `opt-in` or `opt-out` flag for an OpenID Connect (OIDC)
     * subject claim for a repository. You must authenticate using an access token with the `repo`
     * scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object actionsSetCustomOidcSubClaimForRepo(
            final String owner,
            final String repo,
            final ReposActionsOidcCustomizationSubRequest body) throws ApiException, IOException {
        return prepareActionsSetCustomOidcSubClaimForRepoRequest(owner, repo, body).execute();
    }

    /**
     * Sets the customization template and `opt-in` or `opt-out` flag for an OpenID Connect (OIDC)
     * subject claim for a repository. You must authenticate using an access token with the `repo`
     * scope to use this endpoint. GitHub Apps must have the `actions:write` permission to use this
     * endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> actionsSetCustomOidcSubClaimForRepoAsync(
            final String owner,
            final String repo,
            final ReposActionsOidcCustomizationSubRequest body) {
        try { 
            return prepareActionsSetCustomOidcSubClaimForRepoRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetCustomOidcSubClaimForRepo.
     */
    private ApiCall<Object, ApiException> prepareActionsSetCustomOidcSubClaimForRepoRequest(
            final String owner,
            final String repo,
            final ReposActionsOidcCustomizationSubRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/oidc/customization/sub")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .localErrorCase("400",
                                 ErrorCase.create("Bad Request",
                                (reason, context) -> new ReposActionsOidcCustomizationSub400ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposActionsOidcCustomizationSub404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposActionsOidcCustomizationSub422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions
     * is enabled and the actions and reusable workflows allowed to run in the repository. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `administration` repository permission to use this API.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ActionsRepositoryPermissions response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsRepositoryPermissions actionsGetGithubActionsPermissionsRepository(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareActionsGetGithubActionsPermissionsRepositoryRequest(owner, repo).execute();
    }

    /**
     * Gets the GitHub Actions permissions policy for a repository, including whether GitHub Actions
     * is enabled and the actions and reusable workflows allowed to run in the repository. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `administration` repository permission to use this API.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ActionsRepositoryPermissions response from the API call
     */
    public CompletableFuture<ActionsRepositoryPermissions> actionsGetGithubActionsPermissionsRepositoryAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActionsGetGithubActionsPermissionsRepositoryRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetGithubActionsPermissionsRepository.
     */
    private ApiCall<ActionsRepositoryPermissions, ApiException> prepareActionsGetGithubActionsPermissionsRepositoryRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ActionsRepositoryPermissions, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/permissions")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsRepositoryPermissions.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions
     * and reusable workflows in the repository. If the repository belongs to an organization or
     * enterprise that has set restrictive permissions at the organization or enterprise levels,
     * such as `allowed_actions` to `selected` actions and reusable workflows, then you cannot
     * override them for the repository. You must authenticate using an access token with the `repo`
     * scope to use this endpoint. GitHub Apps must have the `administration` repository permission
     * to use this API.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsSetGithubActionsPermissionsRepository(
            final String owner,
            final String repo,
            final ReposActionsPermissionsRequest body) throws ApiException, IOException {
        prepareActionsSetGithubActionsPermissionsRepositoryRequest(owner, repo, body).execute();
    }

    /**
     * Sets the GitHub Actions permissions policy for enabling GitHub Actions and allowed actions
     * and reusable workflows in the repository. If the repository belongs to an organization or
     * enterprise that has set restrictive permissions at the organization or enterprise levels,
     * such as `allowed_actions` to `selected` actions and reusable workflows, then you cannot
     * override them for the repository. You must authenticate using an access token with the `repo`
     * scope to use this endpoint. GitHub Apps must have the `administration` repository permission
     * to use this API.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsSetGithubActionsPermissionsRepositoryAsync(
            final String owner,
            final String repo,
            final ReposActionsPermissionsRequest body) {
        try { 
            return prepareActionsSetGithubActionsPermissionsRepositoryRequest(owner, repo,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetGithubActionsPermissionsRepository.
     */
    private ApiCall<Void, ApiException> prepareActionsSetGithubActionsPermissionsRepositoryRequest(
            final String owner,
            final String repo,
            final ReposActionsPermissionsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/permissions")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the level of access that workflows outside of the repository have to actions and
     * reusable workflows in the repository. This endpoint only applies to private repositories. For
     * more information, see "[Allowing access to components in a private
     * repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository)."
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     * GitHub Apps must have the repository `administration` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ActionsWorkflowAccessToRepository response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsWorkflowAccessToRepository actionsGetWorkflowAccessToRepository(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareActionsGetWorkflowAccessToRepositoryRequest(owner, repo).execute();
    }

    /**
     * Gets the level of access that workflows outside of the repository have to actions and
     * reusable workflows in the repository. This endpoint only applies to private repositories. For
     * more information, see "[Allowing access to components in a private
     * repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository)."
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     * GitHub Apps must have the repository `administration` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ActionsWorkflowAccessToRepository response from the API call
     */
    public CompletableFuture<ActionsWorkflowAccessToRepository> actionsGetWorkflowAccessToRepositoryAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActionsGetWorkflowAccessToRepositoryRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetWorkflowAccessToRepository.
     */
    private ApiCall<ActionsWorkflowAccessToRepository, ApiException> prepareActionsGetWorkflowAccessToRepositoryRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ActionsWorkflowAccessToRepository, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/permissions/access")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsWorkflowAccessToRepository.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sets the level of access that workflows outside of the repository have to actions and
     * reusable workflows in the repository. This endpoint only applies to private repositories. For
     * more information, see "[Allowing access to components in a private
     * repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository)".
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     * GitHub Apps must have the repository `administration` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsSetWorkflowAccessToRepository(
            final String owner,
            final String repo,
            final ActionsWorkflowAccessToRepository body) throws ApiException, IOException {
        prepareActionsSetWorkflowAccessToRepositoryRequest(owner, repo, body).execute();
    }

    /**
     * Sets the level of access that workflows outside of the repository have to actions and
     * reusable workflows in the repository. This endpoint only applies to private repositories. For
     * more information, see "[Allowing access to components in a private
     * repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository)".
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     * GitHub Apps must have the repository `administration` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsSetWorkflowAccessToRepositoryAsync(
            final String owner,
            final String repo,
            final ActionsWorkflowAccessToRepository body) {
        try { 
            return prepareActionsSetWorkflowAccessToRepositoryRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetWorkflowAccessToRepository.
     */
    private ApiCall<Void, ApiException> prepareActionsSetWorkflowAccessToRepositoryRequest(
            final String owner,
            final String repo,
            final ActionsWorkflowAccessToRepository body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/permissions/access")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the settings for selected actions and reusable workflows that are allowed in a
     * repository. To use this endpoint, the repository policy for `allowed_actions` must be
     * configured to `selected`. For more information, see "[Set GitHub Actions permissions for a
     * repository](#set-github-actions-permissions-for-a-repository)." You must authenticate using
     * an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `administration` repository permission to use this API.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the SelectedActions response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public SelectedActions actionsGetAllowedActionsRepository(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareActionsGetAllowedActionsRepositoryRequest(owner, repo).execute();
    }

    /**
     * Gets the settings for selected actions and reusable workflows that are allowed in a
     * repository. To use this endpoint, the repository policy for `allowed_actions` must be
     * configured to `selected`. For more information, see "[Set GitHub Actions permissions for a
     * repository](#set-github-actions-permissions-for-a-repository)." You must authenticate using
     * an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `administration` repository permission to use this API.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the SelectedActions response from the API call
     */
    public CompletableFuture<SelectedActions> actionsGetAllowedActionsRepositoryAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActionsGetAllowedActionsRepositoryRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetAllowedActionsRepository.
     */
    private ApiCall<SelectedActions, ApiException> prepareActionsGetAllowedActionsRepositoryRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<SelectedActions, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/permissions/selected-actions")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, SelectedActions.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sets the actions and reusable workflows that are allowed in a repository. To use this
     * endpoint, the repository permission policy for `allowed_actions` must be configured to
     * `selected`. For more information, see "[Set GitHub Actions permissions for a
     * repository](#set-github-actions-permissions-for-a-repository)." If the repository belongs to
     * an organization or enterprise that has `selected` actions and reusable workflows set at the
     * organization or enterprise levels, then you cannot override any of the allowed actions and
     * reusable workflows settings. To use the `patterns_allowed` setting for private repositories,
     * the repository must belong to an enterprise. If the repository does not belong to an
     * enterprise, then the `patterns_allowed` setting only applies to public repositories. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `administration` repository permission to use this API.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsSetAllowedActionsRepository(
            final String owner,
            final String repo,
            final SelectedActions body) throws ApiException, IOException {
        prepareActionsSetAllowedActionsRepositoryRequest(owner, repo, body).execute();
    }

    /**
     * Sets the actions and reusable workflows that are allowed in a repository. To use this
     * endpoint, the repository permission policy for `allowed_actions` must be configured to
     * `selected`. For more information, see "[Set GitHub Actions permissions for a
     * repository](#set-github-actions-permissions-for-a-repository)." If the repository belongs to
     * an organization or enterprise that has `selected` actions and reusable workflows set at the
     * organization or enterprise levels, then you cannot override any of the allowed actions and
     * reusable workflows settings. To use the `patterns_allowed` setting for private repositories,
     * the repository must belong to an enterprise. If the repository does not belong to an
     * enterprise, then the `patterns_allowed` setting only applies to public repositories. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `administration` repository permission to use this API.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsSetAllowedActionsRepositoryAsync(
            final String owner,
            final String repo,
            final SelectedActions body) {
        try { 
            return prepareActionsSetAllowedActionsRepositoryRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetAllowedActionsRepository.
     */
    private ApiCall<Void, ApiException> prepareActionsSetAllowedActionsRepositoryRequest(
            final String owner,
            final String repo,
            final SelectedActions body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/permissions/selected-actions")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in
     * a repository, as well as if GitHub Actions can submit approving pull request reviews. For
     * more information, see "[Setting the permissions of the GITHUB_TOKEN for your
     * repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     * GitHub Apps must have the repository `administration` permission to use this API.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ActionsGetDefaultWorkflowPermissions response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsGetDefaultWorkflowPermissions actionsGetGithubActionsDefaultWorkflowPermissionsRepository(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest(owner,
                repo).execute();
    }

    /**
     * Gets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in
     * a repository, as well as if GitHub Actions can submit approving pull request reviews. For
     * more information, see "[Setting the permissions of the GITHUB_TOKEN for your
     * repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     * GitHub Apps must have the repository `administration` permission to use this API.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ActionsGetDefaultWorkflowPermissions response from the API call
     */
    public CompletableFuture<ActionsGetDefaultWorkflowPermissions> actionsGetGithubActionsDefaultWorkflowPermissionsRepositoryAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest(owner,
            repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetGithubActionsDefaultWorkflowPermissionsRepository.
     */
    private ApiCall<ActionsGetDefaultWorkflowPermissions, ApiException> prepareActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ActionsGetDefaultWorkflowPermissions, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/permissions/workflow")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsGetDefaultWorkflowPermissions.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in
     * a repository, and sets if GitHub Actions can submit approving pull request reviews. For more
     * information, see "[Setting the permissions of the GITHUB_TOKEN for your
     * repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     * GitHub Apps must have the repository `administration` permission to use this API.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsSetGithubActionsDefaultWorkflowPermissionsRepository(
            final String owner,
            final String repo,
            final ActionsSetDefaultWorkflowPermissions body) throws ApiException, IOException {
        prepareActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest(owner, repo,
                body).execute();
    }

    /**
     * Sets the default workflow permissions granted to the `GITHUB_TOKEN` when running workflows in
     * a repository, and sets if GitHub Actions can submit approving pull request reviews. For more
     * information, see "[Setting the permissions of the GITHUB_TOKEN for your
     * repository](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository)."
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     * GitHub Apps must have the repository `administration` permission to use this API.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsSetGithubActionsDefaultWorkflowPermissionsRepositoryAsync(
            final String owner,
            final String repo,
            final ActionsSetDefaultWorkflowPermissions body) {
        try { 
            return prepareActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest(owner, repo,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetGithubActionsDefaultWorkflowPermissionsRepository.
     */
    private ApiCall<Void, ApiException> prepareActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest(
            final String owner,
            final String repo,
            final ActionsSetDefaultWorkflowPermissions body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/permissions/workflow")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict response when changing a setting is prevented by the owning organization or enterprise",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List all workflow runs for a required workflow. You can use parameters to narrow the list of
     * results. For more information about using parameters, see
     * [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
     * Anyone with read access to the repository can use this endpoint. If the repository is private
     * you must use an access token with the `repo` scope. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  requiredWorkflowIdForRepo  Required parameter: The ID of the required workflow that
     *         has run at least once in a repository.
     * @param  actor  Optional parameter: Returns someone's workflow runs. Use the login for the
     *         user who created the `push` associated with the check suite or workflow run.
     * @param  branch  Optional parameter: Returns workflow runs associated with a branch. Use the
     *         name of the branch of the `push`.
     * @param  event  Optional parameter: Returns workflow run triggered by the event you specify.
     *         For example, `push`, `pull_request` or `issue`. For more information, see "[Events
     *         that trigger
     *         workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
     * @param  status  Optional parameter: Returns workflow runs with the check run `status` or
     *         `conclusion` that you specify. For example, a conclusion can be `success` or a status
     *         can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  created  Optional parameter: Returns workflow runs created within the given date-time
     *         range. For more information on the syntax, see "[Understanding the search
     *         syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
     * @param  excludePullRequests  Optional parameter: If `true` pull requests are omitted from the
     *         response (empty array).
     * @param  checkSuiteId  Optional parameter: Returns workflow runs with the `check_suite_id`
     *         that you specify.
     * @param  headSha  Optional parameter: Only returns workflow runs that are associated with the
     *         specified `head_sha`.
     * @return    Returns the ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoRunsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoRunsResponse actionsListRequiredWorkflowRuns(
            final String owner,
            final String repo,
            final int requiredWorkflowIdForRepo,
            final String actor,
            final String branch,
            final String event,
            final Status81Enum status,
            final Integer perPage,
            final Integer page,
            final LocalDateTime created,
            final Boolean excludePullRequests,
            final Integer checkSuiteId,
            final String headSha) throws ApiException, IOException {
        return prepareActionsListRequiredWorkflowRunsRequest(owner, repo, requiredWorkflowIdForRepo,
                actor, branch, event, status, perPage, page, created, excludePullRequests,
                checkSuiteId, headSha).execute();
    }

    /**
     * List all workflow runs for a required workflow. You can use parameters to narrow the list of
     * results. For more information about using parameters, see
     * [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
     * Anyone with read access to the repository can use this endpoint. If the repository is private
     * you must use an access token with the `repo` scope. For more information, see "[Required
     * Workflows](https://docs.github.com/actions/using-workflows/required-workflows).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  requiredWorkflowIdForRepo  Required parameter: The ID of the required workflow that
     *         has run at least once in a repository.
     * @param  actor  Optional parameter: Returns someone's workflow runs. Use the login for the
     *         user who created the `push` associated with the check suite or workflow run.
     * @param  branch  Optional parameter: Returns workflow runs associated with a branch. Use the
     *         name of the branch of the `push`.
     * @param  event  Optional parameter: Returns workflow run triggered by the event you specify.
     *         For example, `push`, `pull_request` or `issue`. For more information, see "[Events
     *         that trigger
     *         workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
     * @param  status  Optional parameter: Returns workflow runs with the check run `status` or
     *         `conclusion` that you specify. For example, a conclusion can be `success` or a status
     *         can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  created  Optional parameter: Returns workflow runs created within the given date-time
     *         range. For more information on the syntax, see "[Understanding the search
     *         syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
     * @param  excludePullRequests  Optional parameter: If `true` pull requests are omitted from the
     *         response (empty array).
     * @param  checkSuiteId  Optional parameter: Returns workflow runs with the `check_suite_id`
     *         that you specify.
     * @param  headSha  Optional parameter: Only returns workflow runs that are associated with the
     *         specified `head_sha`.
     * @return    Returns the ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoRunsResponse response from the API call
     */
    public CompletableFuture<ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoRunsResponse> actionsListRequiredWorkflowRunsAsync(
            final String owner,
            final String repo,
            final int requiredWorkflowIdForRepo,
            final String actor,
            final String branch,
            final String event,
            final Status81Enum status,
            final Integer perPage,
            final Integer page,
            final LocalDateTime created,
            final Boolean excludePullRequests,
            final Integer checkSuiteId,
            final String headSha) {
        try { 
            return prepareActionsListRequiredWorkflowRunsRequest(owner, repo, requiredWorkflowIdForRepo,
            actor, branch, event, status, perPage, page, created, excludePullRequests, checkSuiteId,
            headSha).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListRequiredWorkflowRuns.
     */
    private ApiCall<ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoRunsResponse, ApiException> prepareActionsListRequiredWorkflowRunsRequest(
            final String owner,
            final String repo,
            final int requiredWorkflowIdForRepo,
            final String actor,
            final String branch,
            final String event,
            final Status81Enum status,
            final Integer perPage,
            final Integer page,
            final LocalDateTime created,
            final Boolean excludePullRequests,
            final Integer checkSuiteId,
            final String headSha) throws IOException {
        return new ApiCall.Builder<ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoRunsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/required_workflows/{required_workflow_id_for_repo}/runs")
                        .queryParam(param -> param.key("actor")
                                .value(actor).isRequired(false))
                        .queryParam(param -> param.key("branch")
                                .value(branch).isRequired(false))
                        .queryParam(param -> param.key("event")
                                .value(event).isRequired(false))
                        .queryParam(param -> param.key("status")
                                .value((status != null) ? status.value() : null).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("created")
                                .value(DateTimeHelper.toRfc8601DateTime(created)).isRequired(false))
                        .queryParam(param -> param.key("exclude_pull_requests")
                                .value((excludePullRequests != null) ? excludePullRequests : false).isRequired(false))
                        .queryParam(param -> param.key("check_suite_id")
                                .value(checkSuiteId).isRequired(false))
                        .queryParam(param -> param.key("head_sha")
                                .value(headSha).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("required_workflow_id_for_repo").value(requiredWorkflowIdForRepo).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsRequiredWorkflowsRequiredWorkflowIdForRepoRunsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all self-hosted runners configured in a repository. You must authenticate using an
     * access token with the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsRunnersResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsActionsRunnersResponse actionsListSelfHostedRunnersForRepo(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListSelfHostedRunnersForRepoRequest(owner, repo, perPage,
                page).execute();
    }

    /**
     * Lists all self-hosted runners configured in a repository. You must authenticate using an
     * access token with the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the OrgsActionsRunnersResponse response from the API call
     */
    public CompletableFuture<OrgsActionsRunnersResponse> actionsListSelfHostedRunnersForRepoAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListSelfHostedRunnersForRepoRequest(owner, repo, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListSelfHostedRunnersForRepo.
     */
    private ApiCall<OrgsActionsRunnersResponse, ApiException> prepareActionsListSelfHostedRunnersForRepoRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<OrgsActionsRunnersResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runners")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsActionsRunnersResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists binaries for the runner application that you can download and run. You must
     * authenticate using an access token with the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of RunnerApplication response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<RunnerApplication> actionsListRunnerApplicationsForRepo(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareActionsListRunnerApplicationsForRepoRequest(owner, repo).execute();
    }

    /**
     * Lists binaries for the runner application that you can download and run. You must
     * authenticate using an access token with the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of RunnerApplication response from the API call
     */
    public CompletableFuture<List<RunnerApplication>> actionsListRunnerApplicationsForRepoAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActionsListRunnerApplicationsForRepoRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListRunnerApplicationsForRepo.
     */
    private ApiCall<List<RunnerApplication>, ApiException> prepareActionsListRunnerApplicationsForRepoRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<List<RunnerApplication>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runners/downloads")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        RunnerApplication[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns a token that you can pass to the `config` script. The token expires after one hour.
     * You must authenticate using an access token with the `repo` scope to use this endpoint. ####
     * Example using registration token Configure your self-hosted runner, replacing `TOKEN` with
     * the registration token provided by this endpoint. ``` ./config.sh --url
     * https://github.com/octo-org/octo-repo-artifacts --token TOKEN ```.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposActionsRunnersRegistrationTokenResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsRunnersRegistrationTokenResponse actionsCreateRegistrationTokenForRepo(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareActionsCreateRegistrationTokenForRepoRequest(owner, repo).execute();
    }

    /**
     * Returns a token that you can pass to the `config` script. The token expires after one hour.
     * You must authenticate using an access token with the `repo` scope to use this endpoint. ####
     * Example using registration token Configure your self-hosted runner, replacing `TOKEN` with
     * the registration token provided by this endpoint. ``` ./config.sh --url
     * https://github.com/octo-org/octo-repo-artifacts --token TOKEN ```.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposActionsRunnersRegistrationTokenResponse response from the API call
     */
    public CompletableFuture<ReposActionsRunnersRegistrationTokenResponse> actionsCreateRegistrationTokenForRepoAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActionsCreateRegistrationTokenForRepoRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsCreateRegistrationTokenForRepo.
     */
    private ApiCall<ReposActionsRunnersRegistrationTokenResponse, ApiException> prepareActionsCreateRegistrationTokenForRepoRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposActionsRunnersRegistrationTokenResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runners/registration-token")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsRunnersRegistrationTokenResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Returns a token that you can pass to remove a self-hosted runner from a repository. The token
     * expires after one hour. You must authenticate using an access token with the `repo` scope to
     * use this endpoint. #### Example using remove token To remove your self-hosted runner from a
     * repository, replace TOKEN with the remove token provided by this endpoint. ``` ./config.sh
     * remove --token TOKEN ```.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposActionsRunnersRemoveTokenResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsRunnersRemoveTokenResponse actionsCreateRemoveTokenForRepo(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareActionsCreateRemoveTokenForRepoRequest(owner, repo).execute();
    }

    /**
     * Returns a token that you can pass to remove a self-hosted runner from a repository. The token
     * expires after one hour. You must authenticate using an access token with the `repo` scope to
     * use this endpoint. #### Example using remove token To remove your self-hosted runner from a
     * repository, replace TOKEN with the remove token provided by this endpoint. ``` ./config.sh
     * remove --token TOKEN ```.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposActionsRunnersRemoveTokenResponse response from the API call
     */
    public CompletableFuture<ReposActionsRunnersRemoveTokenResponse> actionsCreateRemoveTokenForRepoAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActionsCreateRemoveTokenForRepoRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsCreateRemoveTokenForRepo.
     */
    private ApiCall<ReposActionsRunnersRemoveTokenResponse, ApiException> prepareActionsCreateRemoveTokenForRepoRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposActionsRunnersRemoveTokenResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runners/remove-token")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsRunnersRemoveTokenResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific self-hosted runner configured in a repository. You must authenticate using an
     * access token with the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the ReposActionsRunnersRunnerIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsRunnersRunnerIdResponse actionsGetSelfHostedRunnerForRepo(
            final String owner,
            final String repo,
            final int runnerId) throws ApiException, IOException {
        return prepareActionsGetSelfHostedRunnerForRepoRequest(owner, repo, runnerId).execute();
    }

    /**
     * Gets a specific self-hosted runner configured in a repository. You must authenticate using an
     * access token with the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the ReposActionsRunnersRunnerIdResponse response from the API call
     */
    public CompletableFuture<ReposActionsRunnersRunnerIdResponse> actionsGetSelfHostedRunnerForRepoAsync(
            final String owner,
            final String repo,
            final int runnerId) {
        try { 
            return prepareActionsGetSelfHostedRunnerForRepoRequest(owner, repo, runnerId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetSelfHostedRunnerForRepo.
     */
    private ApiCall<ReposActionsRunnersRunnerIdResponse, ApiException> prepareActionsGetSelfHostedRunnerForRepoRequest(
            final String owner,
            final String repo,
            final int runnerId) throws IOException {
        return new ApiCall.Builder<ReposActionsRunnersRunnerIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runners/{runner_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsRunnersRunnerIdResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Forces the removal of a self-hosted runner from a repository. You can use this endpoint to
     * completely remove the runner when the machine you were using no longer exists. You must
     * authenticate using an access token with the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDeleteSelfHostedRunnerFromRepo(
            final String owner,
            final String repo,
            final int runnerId) throws ApiException, IOException {
        prepareActionsDeleteSelfHostedRunnerFromRepoRequest(owner, repo, runnerId).execute();
    }

    /**
     * Forces the removal of a self-hosted runner from a repository. You can use this endpoint to
     * completely remove the runner when the machine you were using no longer exists. You must
     * authenticate using an access token with the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDeleteSelfHostedRunnerFromRepoAsync(
            final String owner,
            final String repo,
            final int runnerId) {
        try { 
            return prepareActionsDeleteSelfHostedRunnerFromRepoRequest(owner, repo,
            runnerId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteSelfHostedRunnerFromRepo.
     */
    private ApiCall<Void, ApiException> prepareActionsDeleteSelfHostedRunnerFromRepoRequest(
            final String owner,
            final String repo,
            final int runnerId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runners/{runner_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all labels for a self-hosted runner configured in a repository. You must authenticate
     * using an access token with the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the ActionsRunnerLabels response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsRunnerLabels actionsListLabelsForSelfHostedRunnerForRepo(
            final String owner,
            final String repo,
            final int runnerId) throws ApiException, IOException {
        return prepareActionsListLabelsForSelfHostedRunnerForRepoRequest(owner, repo,
                runnerId).execute();
    }

    /**
     * Lists all labels for a self-hosted runner configured in a repository. You must authenticate
     * using an access token with the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the ActionsRunnerLabels response from the API call
     */
    public CompletableFuture<ActionsRunnerLabels> actionsListLabelsForSelfHostedRunnerForRepoAsync(
            final String owner,
            final String repo,
            final int runnerId) {
        try { 
            return prepareActionsListLabelsForSelfHostedRunnerForRepoRequest(owner, repo,
            runnerId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListLabelsForSelfHostedRunnerForRepo.
     */
    private ApiCall<ActionsRunnerLabels, ApiException> prepareActionsListLabelsForSelfHostedRunnerForRepoRequest(
            final String owner,
            final String repo,
            final int runnerId) throws IOException {
        return new ApiCall.Builder<ActionsRunnerLabels, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runners/{runner_id}/labels")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsRunnerLabels.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposActionsRunnersRunnerIdLabels404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Add custom labels to a self-hosted runner configured in a repository. You must authenticate
     * using an access token with the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @param  body  Required parameter: Example:
     * @return    Returns the ActionsRunnerLabels response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsRunnerLabels actionsAddCustomLabelsToSelfHostedRunnerForRepo(
            final String owner,
            final String repo,
            final int runnerId,
            final EnterprisesActionsRunnersLabelsRequest body) throws ApiException, IOException {
        return prepareActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest(owner, repo, runnerId,
                body).execute();
    }

    /**
     * Add custom labels to a self-hosted runner configured in a repository. You must authenticate
     * using an access token with the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @param  body  Required parameter: Example:
     * @return    Returns the ActionsRunnerLabels response from the API call
     */
    public CompletableFuture<ActionsRunnerLabels> actionsAddCustomLabelsToSelfHostedRunnerForRepoAsync(
            final String owner,
            final String repo,
            final int runnerId,
            final EnterprisesActionsRunnersLabelsRequest body) {
        try { 
            return prepareActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest(owner, repo, runnerId,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsAddCustomLabelsToSelfHostedRunnerForRepo.
     */
    private ApiCall<ActionsRunnerLabels, ApiException> prepareActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest(
            final String owner,
            final String repo,
            final int runnerId,
            final EnterprisesActionsRunnersLabelsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ActionsRunnerLabels, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runners/{runner_id}/labels")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsRunnerLabels.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposActionsRunnersRunnerIdLabels404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposActionsRunnersRunnerIdLabels422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Remove all previous custom labels and set the new custom labels for a specific self-hosted
     * runner configured in a repository. You must authenticate using an access token with the
     * `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @param  body  Required parameter: Example:
     * @return    Returns the ActionsRunnerLabels response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsRunnerLabels actionsSetCustomLabelsForSelfHostedRunnerForRepo(
            final String owner,
            final String repo,
            final int runnerId,
            final OrgsActionsRunnersLabelsRequest1 body) throws ApiException, IOException {
        return prepareActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest(owner, repo, runnerId,
                body).execute();
    }

    /**
     * Remove all previous custom labels and set the new custom labels for a specific self-hosted
     * runner configured in a repository. You must authenticate using an access token with the
     * `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @param  body  Required parameter: Example:
     * @return    Returns the ActionsRunnerLabels response from the API call
     */
    public CompletableFuture<ActionsRunnerLabels> actionsSetCustomLabelsForSelfHostedRunnerForRepoAsync(
            final String owner,
            final String repo,
            final int runnerId,
            final OrgsActionsRunnersLabelsRequest1 body) {
        try { 
            return prepareActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest(owner, repo, runnerId,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsSetCustomLabelsForSelfHostedRunnerForRepo.
     */
    private ApiCall<ActionsRunnerLabels, ApiException> prepareActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest(
            final String owner,
            final String repo,
            final int runnerId,
            final OrgsActionsRunnersLabelsRequest1 body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ActionsRunnerLabels, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runners/{runner_id}/labels")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsRunnerLabels.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposActionsRunnersRunnerIdLabels404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposActionsRunnersRunnerIdLabels422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Remove all custom labels from a self-hosted runner configured in a repository. Returns the
     * remaining read-only labels from the runner. You must authenticate using an access token with
     * the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the ActionsRunnerLabels response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsRunnerLabels actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo(
            final String owner,
            final String repo,
            final int runnerId) throws ApiException, IOException {
        return prepareActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest(owner, repo,
                runnerId).execute();
    }

    /**
     * Remove all custom labels from a self-hosted runner configured in a repository. Returns the
     * remaining read-only labels from the runner. You must authenticate using an access token with
     * the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @return    Returns the ActionsRunnerLabels response from the API call
     */
    public CompletableFuture<ActionsRunnerLabels> actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoAsync(
            final String owner,
            final String repo,
            final int runnerId) {
        try { 
            return prepareActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest(owner, repo,
            runnerId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo.
     */
    private ApiCall<ActionsRunnerLabels, ApiException> prepareActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest(
            final String owner,
            final String repo,
            final int runnerId) throws IOException {
        return new ApiCall.Builder<ActionsRunnerLabels, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runners/{runner_id}/labels")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsRunnerLabels.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposActionsRunnersRunnerIdLabels404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Remove a custom label from a self-hosted runner configured in a repository. Returns the
     * remaining labels from the runner. This endpoint returns a `404 Not Found` status if the
     * custom label is not present on the runner. You must authenticate using an access token with
     * the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @param  name  Required parameter: The name of a self-hosted runner's custom label.
     * @return    Returns the ActionsRunnerLabels response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsRunnerLabels actionsRemoveCustomLabelFromSelfHostedRunnerForRepo(
            final String owner,
            final String repo,
            final int runnerId,
            final String name) throws ApiException, IOException {
        return prepareActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest(owner, repo,
                runnerId, name).execute();
    }

    /**
     * Remove a custom label from a self-hosted runner configured in a repository. Returns the
     * remaining labels from the runner. This endpoint returns a `404 Not Found` status if the
     * custom label is not present on the runner. You must authenticate using an access token with
     * the `repo` scope to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runnerId  Required parameter: Unique identifier of the self-hosted runner.
     * @param  name  Required parameter: The name of a self-hosted runner's custom label.
     * @return    Returns the ActionsRunnerLabels response from the API call
     */
    public CompletableFuture<ActionsRunnerLabels> actionsRemoveCustomLabelFromSelfHostedRunnerForRepoAsync(
            final String owner,
            final String repo,
            final int runnerId,
            final String name) {
        try { 
            return prepareActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest(owner, repo, runnerId,
            name).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsRemoveCustomLabelFromSelfHostedRunnerForRepo.
     */
    private ApiCall<ActionsRunnerLabels, ApiException> prepareActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest(
            final String owner,
            final String repo,
            final int runnerId,
            final String name) throws IOException {
        return new ApiCall.Builder<ActionsRunnerLabels, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("runner_id").value(runnerId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsRunnerLabels.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposActionsRunnersRunnerIdLabelsName404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposActionsRunnersRunnerIdLabelsName422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all workflow runs for a repository. You can use parameters to narrow the list of
     * results. For more information about using parameters, see
     * [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
     * Anyone with read access to the repository can use this endpoint. If the repository is private
     * you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
     * permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  actor  Optional parameter: Returns someone's workflow runs. Use the login for the
     *         user who created the `push` associated with the check suite or workflow run.
     * @param  branch  Optional parameter: Returns workflow runs associated with a branch. Use the
     *         name of the branch of the `push`.
     * @param  event  Optional parameter: Returns workflow run triggered by the event you specify.
     *         For example, `push`, `pull_request` or `issue`. For more information, see "[Events
     *         that trigger
     *         workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
     * @param  status  Optional parameter: Returns workflow runs with the check run `status` or
     *         `conclusion` that you specify. For example, a conclusion can be `success` or a status
     *         can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  created  Optional parameter: Returns workflow runs created within the given date-time
     *         range. For more information on the syntax, see "[Understanding the search
     *         syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
     * @param  excludePullRequests  Optional parameter: If `true` pull requests are omitted from the
     *         response (empty array).
     * @param  checkSuiteId  Optional parameter: Returns workflow runs with the `check_suite_id`
     *         that you specify.
     * @param  headSha  Optional parameter: Only returns workflow runs that are associated with the
     *         specified `head_sha`.
     * @return    Returns the ReposActionsRunsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsRunsResponse actionsListWorkflowRunsForRepo(
            final String owner,
            final String repo,
            final String actor,
            final String branch,
            final String event,
            final Status81Enum status,
            final Integer perPage,
            final Integer page,
            final LocalDateTime created,
            final Boolean excludePullRequests,
            final Integer checkSuiteId,
            final String headSha) throws ApiException, IOException {
        return prepareActionsListWorkflowRunsForRepoRequest(owner, repo, actor, branch, event,
                status, perPage, page, created, excludePullRequests, checkSuiteId,
                headSha).execute();
    }

    /**
     * Lists all workflow runs for a repository. You can use parameters to narrow the list of
     * results. For more information about using parameters, see
     * [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
     * Anyone with read access to the repository can use this endpoint. If the repository is private
     * you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
     * permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  actor  Optional parameter: Returns someone's workflow runs. Use the login for the
     *         user who created the `push` associated with the check suite or workflow run.
     * @param  branch  Optional parameter: Returns workflow runs associated with a branch. Use the
     *         name of the branch of the `push`.
     * @param  event  Optional parameter: Returns workflow run triggered by the event you specify.
     *         For example, `push`, `pull_request` or `issue`. For more information, see "[Events
     *         that trigger
     *         workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
     * @param  status  Optional parameter: Returns workflow runs with the check run `status` or
     *         `conclusion` that you specify. For example, a conclusion can be `success` or a status
     *         can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  created  Optional parameter: Returns workflow runs created within the given date-time
     *         range. For more information on the syntax, see "[Understanding the search
     *         syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
     * @param  excludePullRequests  Optional parameter: If `true` pull requests are omitted from the
     *         response (empty array).
     * @param  checkSuiteId  Optional parameter: Returns workflow runs with the `check_suite_id`
     *         that you specify.
     * @param  headSha  Optional parameter: Only returns workflow runs that are associated with the
     *         specified `head_sha`.
     * @return    Returns the ReposActionsRunsResponse response from the API call
     */
    public CompletableFuture<ReposActionsRunsResponse> actionsListWorkflowRunsForRepoAsync(
            final String owner,
            final String repo,
            final String actor,
            final String branch,
            final String event,
            final Status81Enum status,
            final Integer perPage,
            final Integer page,
            final LocalDateTime created,
            final Boolean excludePullRequests,
            final Integer checkSuiteId,
            final String headSha) {
        try { 
            return prepareActionsListWorkflowRunsForRepoRequest(owner, repo, actor, branch, event, status,
            perPage, page, created, excludePullRequests, checkSuiteId, headSha).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListWorkflowRunsForRepo.
     */
    private ApiCall<ReposActionsRunsResponse, ApiException> prepareActionsListWorkflowRunsForRepoRequest(
            final String owner,
            final String repo,
            final String actor,
            final String branch,
            final String event,
            final Status81Enum status,
            final Integer perPage,
            final Integer page,
            final LocalDateTime created,
            final Boolean excludePullRequests,
            final Integer checkSuiteId,
            final String headSha) throws IOException {
        return new ApiCall.Builder<ReposActionsRunsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs")
                        .queryParam(param -> param.key("actor")
                                .value(actor).isRequired(false))
                        .queryParam(param -> param.key("branch")
                                .value(branch).isRequired(false))
                        .queryParam(param -> param.key("event")
                                .value(event).isRequired(false))
                        .queryParam(param -> param.key("status")
                                .value((status != null) ? status.value() : null).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("created")
                                .value(DateTimeHelper.toRfc8601DateTime(created)).isRequired(false))
                        .queryParam(param -> param.key("exclude_pull_requests")
                                .value((excludePullRequests != null) ? excludePullRequests : false).isRequired(false))
                        .queryParam(param -> param.key("check_suite_id")
                                .value(checkSuiteId).isRequired(false))
                        .queryParam(param -> param.key("head_sha")
                                .value(headSha).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsRunsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific workflow run. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  excludePullRequests  Optional parameter: If `true` pull requests are omitted from the
     *         response (empty array).
     * @return    Returns the ReposActionsRunsRunIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsRunsRunIdResponse actionsGetWorkflowRun(
            final String owner,
            final String repo,
            final int runId,
            final Boolean excludePullRequests) throws ApiException, IOException {
        return prepareActionsGetWorkflowRunRequest(owner, repo, runId,
                excludePullRequests).execute();
    }

    /**
     * Gets a specific workflow run. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  excludePullRequests  Optional parameter: If `true` pull requests are omitted from the
     *         response (empty array).
     * @return    Returns the ReposActionsRunsRunIdResponse response from the API call
     */
    public CompletableFuture<ReposActionsRunsRunIdResponse> actionsGetWorkflowRunAsync(
            final String owner,
            final String repo,
            final int runId,
            final Boolean excludePullRequests) {
        try { 
            return prepareActionsGetWorkflowRunRequest(owner, repo, runId,
            excludePullRequests).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetWorkflowRun.
     */
    private ApiCall<ReposActionsRunsRunIdResponse, ApiException> prepareActionsGetWorkflowRunRequest(
            final String owner,
            final String repo,
            final int runId,
            final Boolean excludePullRequests) throws IOException {
        return new ApiCall.Builder<ReposActionsRunsRunIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}")
                        .queryParam(param -> param.key("exclude_pull_requests")
                                .value((excludePullRequests != null) ? excludePullRequests : false).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsRunsRunIdResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Delete a specific workflow run. Anyone with write access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:write` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDeleteWorkflowRun(
            final String owner,
            final String repo,
            final int runId) throws ApiException, IOException {
        prepareActionsDeleteWorkflowRunRequest(owner, repo, runId).execute();
    }

    /**
     * Delete a specific workflow run. Anyone with write access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:write` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDeleteWorkflowRunAsync(
            final String owner,
            final String repo,
            final int runId) {
        try { 
            return prepareActionsDeleteWorkflowRunRequest(owner, repo, runId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteWorkflowRun.
     */
    private ApiCall<Void, ApiException> prepareActionsDeleteWorkflowRunRequest(
            final String owner,
            final String repo,
            final int runId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Anyone with read access to the repository can use this endpoint. If the repository is
     * private, you must use an access token with the `repo` scope. GitHub Apps must have the
     * `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @return    Returns the List of EnvironmentApproval response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<EnvironmentApproval> actionsGetReviewsForRun(
            final String owner,
            final String repo,
            final int runId) throws ApiException, IOException {
        return prepareActionsGetReviewsForRunRequest(owner, repo, runId).execute();
    }

    /**
     * Anyone with read access to the repository can use this endpoint. If the repository is
     * private, you must use an access token with the `repo` scope. GitHub Apps must have the
     * `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @return    Returns the List of EnvironmentApproval response from the API call
     */
    public CompletableFuture<List<EnvironmentApproval>> actionsGetReviewsForRunAsync(
            final String owner,
            final String repo,
            final int runId) {
        try { 
            return prepareActionsGetReviewsForRunRequest(owner, repo, runId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetReviewsForRun.
     */
    private ApiCall<List<EnvironmentApproval>, ApiException> prepareActionsGetReviewsForRunRequest(
            final String owner,
            final String repo,
            final int runId) throws IOException {
        return new ApiCall.Builder<List<EnvironmentApproval>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/approvals")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        EnvironmentApproval[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Approves a workflow run for a pull request from a public fork of a first time contributor.
     * For more information, see ["Approving workflow runs from public
     * forks](https://docs.github.com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)."
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     * GitHub Apps must have the `actions:write` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object actionsApproveWorkflowRun(
            final String owner,
            final String repo,
            final int runId) throws ApiException, IOException {
        return prepareActionsApproveWorkflowRunRequest(owner, repo, runId).execute();
    }

    /**
     * Approves a workflow run for a pull request from a public fork of a first time contributor.
     * For more information, see ["Approving workflow runs from public
     * forks](https://docs.github.com/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks)."
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     * GitHub Apps must have the `actions:write` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> actionsApproveWorkflowRunAsync(
            final String owner,
            final String repo,
            final int runId) {
        try { 
            return prepareActionsApproveWorkflowRunRequest(owner, repo, runId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsApproveWorkflowRun.
     */
    private ApiCall<Object, ApiException> prepareActionsApproveWorkflowRunRequest(
            final String owner,
            final String repo,
            final int runId) throws IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/approve")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposActionsRunsRunIdApprove403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposActionsRunsRunIdApprove404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists artifacts for a workflow run. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsArtifactsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsArtifactsResponse actionsListWorkflowRunArtifacts(
            final String owner,
            final String repo,
            final int runId,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListWorkflowRunArtifactsRequest(owner, repo, runId, perPage,
                page).execute();
    }

    /**
     * Lists artifacts for a workflow run. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsArtifactsResponse response from the API call
     */
    public CompletableFuture<ReposActionsArtifactsResponse> actionsListWorkflowRunArtifactsAsync(
            final String owner,
            final String repo,
            final int runId,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListWorkflowRunArtifactsRequest(owner, repo, runId, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListWorkflowRunArtifacts.
     */
    private ApiCall<ReposActionsArtifactsResponse, ApiException> prepareActionsListWorkflowRunArtifactsRequest(
            final String owner,
            final String repo,
            final int runId,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposActionsArtifactsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/artifacts")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsArtifactsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific workflow run attempt. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  attemptNumber  Required parameter: The attempt number of the workflow run.
     * @param  excludePullRequests  Optional parameter: If `true` pull requests are omitted from the
     *         response (empty array).
     * @return    Returns the ReposActionsRunsRunIdAttemptsAttemptNumberResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsRunsRunIdAttemptsAttemptNumberResponse actionsGetWorkflowRunAttempt(
            final String owner,
            final String repo,
            final int runId,
            final int attemptNumber,
            final Boolean excludePullRequests) throws ApiException, IOException {
        return prepareActionsGetWorkflowRunAttemptRequest(owner, repo, runId, attemptNumber,
                excludePullRequests).execute();
    }

    /**
     * Gets a specific workflow run attempt. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  attemptNumber  Required parameter: The attempt number of the workflow run.
     * @param  excludePullRequests  Optional parameter: If `true` pull requests are omitted from the
     *         response (empty array).
     * @return    Returns the ReposActionsRunsRunIdAttemptsAttemptNumberResponse response from the API call
     */
    public CompletableFuture<ReposActionsRunsRunIdAttemptsAttemptNumberResponse> actionsGetWorkflowRunAttemptAsync(
            final String owner,
            final String repo,
            final int runId,
            final int attemptNumber,
            final Boolean excludePullRequests) {
        try { 
            return prepareActionsGetWorkflowRunAttemptRequest(owner, repo, runId, attemptNumber,
            excludePullRequests).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetWorkflowRunAttempt.
     */
    private ApiCall<ReposActionsRunsRunIdAttemptsAttemptNumberResponse, ApiException> prepareActionsGetWorkflowRunAttemptRequest(
            final String owner,
            final String repo,
            final int runId,
            final int attemptNumber,
            final Boolean excludePullRequests) throws IOException {
        return new ApiCall.Builder<ReposActionsRunsRunIdAttemptsAttemptNumberResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}")
                        .queryParam(param -> param.key("exclude_pull_requests")
                                .value((excludePullRequests != null) ? excludePullRequests : false).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("attempt_number").value(attemptNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsRunsRunIdAttemptsAttemptNumberResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists jobs for a specific workflow run attempt. Anyone with read access to the repository can
     * use this endpoint. If the repository is private you must use an access token with the `repo`
     * scope. GitHub Apps must have the `actions:read` permission to use this endpoint. You can use
     * parameters to narrow the list of results. For more information about using parameters, see
     * [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  attemptNumber  Required parameter: The attempt number of the workflow run.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse actionsListJobsForWorkflowRunAttempt(
            final String owner,
            final String repo,
            final int runId,
            final int attemptNumber,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListJobsForWorkflowRunAttemptRequest(owner, repo, runId, attemptNumber,
                perPage, page).execute();
    }

    /**
     * Lists jobs for a specific workflow run attempt. Anyone with read access to the repository can
     * use this endpoint. If the repository is private you must use an access token with the `repo`
     * scope. GitHub Apps must have the `actions:read` permission to use this endpoint. You can use
     * parameters to narrow the list of results. For more information about using parameters, see
     * [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  attemptNumber  Required parameter: The attempt number of the workflow run.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse response from the API call
     */
    public CompletableFuture<ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse> actionsListJobsForWorkflowRunAttemptAsync(
            final String owner,
            final String repo,
            final int runId,
            final int attemptNumber,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListJobsForWorkflowRunAttemptRequest(owner, repo, runId, attemptNumber,
            perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListJobsForWorkflowRunAttempt.
     */
    private ApiCall<ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse, ApiException> prepareActionsListJobsForWorkflowRunAttemptRequest(
            final String owner,
            final String repo,
            final int runId,
            final int attemptNumber,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("attempt_number").value(attemptNumber).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposActionsRunsRunIdAttemptsAttemptNumberJobs404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a redirect URL to download an archive of log files for a specific workflow run attempt.
     * This link expires after 1 minute. Look for `Location:` in the response header to find the URL
     * for the download. Anyone with read access to the repository can use this endpoint. If the
     * repository is private you must use an access token with the `repo` scope. GitHub Apps must
     * have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  attemptNumber  Required parameter: The attempt number of the workflow run.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDownloadWorkflowRunAttemptLogs(
            final String owner,
            final String repo,
            final int runId,
            final int attemptNumber) throws ApiException, IOException {
        prepareActionsDownloadWorkflowRunAttemptLogsRequest(owner, repo, runId,
                attemptNumber).execute();
    }

    /**
     * Gets a redirect URL to download an archive of log files for a specific workflow run attempt.
     * This link expires after 1 minute. Look for `Location:` in the response header to find the URL
     * for the download. Anyone with read access to the repository can use this endpoint. If the
     * repository is private you must use an access token with the `repo` scope. GitHub Apps must
     * have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  attemptNumber  Required parameter: The attempt number of the workflow run.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDownloadWorkflowRunAttemptLogsAsync(
            final String owner,
            final String repo,
            final int runId,
            final int attemptNumber) {
        try { 
            return prepareActionsDownloadWorkflowRunAttemptLogsRequest(owner, repo, runId,
            attemptNumber).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDownloadWorkflowRunAttemptLogs.
     */
    private ApiCall<Void, ApiException> prepareActionsDownloadWorkflowRunAttemptLogsRequest(
            final String owner,
            final String repo,
            final int runId,
            final int attemptNumber) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("attempt_number").value(attemptNumber).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Cancels a workflow run using its `id`. You must authenticate using an access token with the
     * `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to
     * use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object actionsCancelWorkflowRun(
            final String owner,
            final String repo,
            final int runId) throws ApiException, IOException {
        return prepareActionsCancelWorkflowRunRequest(owner, repo, runId).execute();
    }

    /**
     * Cancels a workflow run using its `id`. You must authenticate using an access token with the
     * `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to
     * use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> actionsCancelWorkflowRunAsync(
            final String owner,
            final String repo,
            final int runId) {
        try { 
            return prepareActionsCancelWorkflowRunRequest(owner, repo, runId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsCancelWorkflowRun.
     */
    private ApiCall<Object, ApiException> prepareActionsCancelWorkflowRunRequest(
            final String owner,
            final String repo,
            final int runId) throws IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/cancel")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .localErrorCase("409",
                                 ErrorCase.create("Conflict",
                                (reason, context) -> new ReposActionsRunsRunIdCancel409ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists jobs for a workflow run. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint. You can use
     * parameters to narrow the list of results. For more information about using parameters, see
     * [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  filter  Optional parameter: Filters jobs by their `completed_at` timestamp. `latest`
     *         returns jobs from the most recent execution of the workflow run. `all` returns all
     *         jobs for a workflow run, including from old executions of the workflow run.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse actionsListJobsForWorkflowRun(
            final String owner,
            final String repo,
            final int runId,
            final Filter41Enum filter,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListJobsForWorkflowRunRequest(owner, repo, runId, filter, perPage,
                page).execute();
    }

    /**
     * Lists jobs for a workflow run. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint. You can use
     * parameters to narrow the list of results. For more information about using parameters, see
     * [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  filter  Optional parameter: Filters jobs by their `completed_at` timestamp. `latest`
     *         returns jobs from the most recent execution of the workflow run. `all` returns all
     *         jobs for a workflow run, including from old executions of the workflow run.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse response from the API call
     */
    public CompletableFuture<ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse> actionsListJobsForWorkflowRunAsync(
            final String owner,
            final String repo,
            final int runId,
            final Filter41Enum filter,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListJobsForWorkflowRunRequest(owner, repo, runId, filter, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListJobsForWorkflowRun.
     */
    private ApiCall<ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse, ApiException> prepareActionsListJobsForWorkflowRunRequest(
            final String owner,
            final String repo,
            final int runId,
            final Filter41Enum filter,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/jobs")
                        .queryParam(param -> param.key("filter")
                                .value((filter != null) ? filter.value() : null).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsRunsRunIdAttemptsAttemptNumberJobsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a redirect URL to download an archive of log files for a workflow run. This link expires
     * after 1 minute. Look for `Location:` in the response header to find the URL for the download.
     * Anyone with read access to the repository can use this endpoint. If the repository is private
     * you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
     * permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDownloadWorkflowRunLogs(
            final String owner,
            final String repo,
            final int runId) throws ApiException, IOException {
        prepareActionsDownloadWorkflowRunLogsRequest(owner, repo, runId).execute();
    }

    /**
     * Gets a redirect URL to download an archive of log files for a workflow run. This link expires
     * after 1 minute. Look for `Location:` in the response header to find the URL for the download.
     * Anyone with read access to the repository can use this endpoint. If the repository is private
     * you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
     * permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDownloadWorkflowRunLogsAsync(
            final String owner,
            final String repo,
            final int runId) {
        try { 
            return prepareActionsDownloadWorkflowRunLogsRequest(owner, repo, runId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDownloadWorkflowRunLogs.
     */
    private ApiCall<Void, ApiException> prepareActionsDownloadWorkflowRunLogsRequest(
            final String owner,
            final String repo,
            final int runId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/logs")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes all logs for a workflow run. You must authenticate using an access token with the
     * `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to
     * use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDeleteWorkflowRunLogs(
            final String owner,
            final String repo,
            final int runId) throws ApiException, IOException {
        prepareActionsDeleteWorkflowRunLogsRequest(owner, repo, runId).execute();
    }

    /**
     * Deletes all logs for a workflow run. You must authenticate using an access token with the
     * `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission to
     * use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDeleteWorkflowRunLogsAsync(
            final String owner,
            final String repo,
            final int runId) {
        try { 
            return prepareActionsDeleteWorkflowRunLogsRequest(owner, repo, runId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteWorkflowRunLogs.
     */
    private ApiCall<Void, ApiException> prepareActionsDeleteWorkflowRunLogsRequest(
            final String owner,
            final String repo,
            final int runId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/logs")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new ReposActionsRunsRunIdLogs403ErrorException(reason, context)))
                        .localErrorCase("500",
                                 ErrorCase.create("Internal Error",
                                (reason, context) -> new ReposActionsRunsRunIdLogs500ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get all deployment environments for a workflow run that are waiting for protection rules to
     * pass. Anyone with read access to the repository can use this endpoint. If the repository is
     * private, you must use an access token with the `repo` scope. GitHub Apps must have the
     * `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @return    Returns the List of PendingDeployment response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<PendingDeployment> actionsGetPendingDeploymentsForRun(
            final String owner,
            final String repo,
            final int runId) throws ApiException, IOException {
        return prepareActionsGetPendingDeploymentsForRunRequest(owner, repo, runId).execute();
    }

    /**
     * Get all deployment environments for a workflow run that are waiting for protection rules to
     * pass. Anyone with read access to the repository can use this endpoint. If the repository is
     * private, you must use an access token with the `repo` scope. GitHub Apps must have the
     * `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @return    Returns the List of PendingDeployment response from the API call
     */
    public CompletableFuture<List<PendingDeployment>> actionsGetPendingDeploymentsForRunAsync(
            final String owner,
            final String repo,
            final int runId) {
        try { 
            return prepareActionsGetPendingDeploymentsForRunRequest(owner, repo, runId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetPendingDeploymentsForRun.
     */
    private ApiCall<List<PendingDeployment>, ApiException> prepareActionsGetPendingDeploymentsForRunRequest(
            final String owner,
            final String repo,
            final int runId) throws IOException {
        return new ApiCall.Builder<List<PendingDeployment>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        PendingDeployment[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Approve or reject pending deployments that are waiting on approval by a required reviewer.
     * Required reviewers with read access to the repository contents and deployments can use this
     * endpoint. Required reviewers must authenticate using an access token with the `repo` scope to
     * use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  body  Required parameter: Example:
     * @return    Returns the List of Deployment response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Deployment> actionsReviewPendingDeploymentsForRun(
            final String owner,
            final String repo,
            final int runId,
            final ReposActionsRunsRunIdPendingDeploymentsRequest body) throws ApiException, IOException {
        return prepareActionsReviewPendingDeploymentsForRunRequest(owner, repo, runId,
                body).execute();
    }

    /**
     * Approve or reject pending deployments that are waiting on approval by a required reviewer.
     * Required reviewers with read access to the repository contents and deployments can use this
     * endpoint. Required reviewers must authenticate using an access token with the `repo` scope to
     * use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  body  Required parameter: Example:
     * @return    Returns the List of Deployment response from the API call
     */
    public CompletableFuture<List<Deployment>> actionsReviewPendingDeploymentsForRunAsync(
            final String owner,
            final String repo,
            final int runId,
            final ReposActionsRunsRunIdPendingDeploymentsRequest body) {
        try { 
            return prepareActionsReviewPendingDeploymentsForRunRequest(owner, repo, runId,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsReviewPendingDeploymentsForRun.
     */
    private ApiCall<List<Deployment>, ApiException> prepareActionsReviewPendingDeploymentsForRunRequest(
            final String owner,
            final String repo,
            final int runId,
            final ReposActionsRunsRunIdPendingDeploymentsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<List<Deployment>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Deployment[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Re-runs your workflow run using its `id`. You must authenticate using an access token with
     * the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission
     * to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  body  Optional parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object actionsReRunWorkflow(
            final String owner,
            final String repo,
            final int runId,
            final Object body) throws ApiException, IOException {
        return prepareActionsReRunWorkflowRequest(owner, repo, runId, body).execute();
    }

    /**
     * Re-runs your workflow run using its `id`. You must authenticate using an access token with
     * the `repo` scope to use this endpoint. GitHub Apps must have the `actions:write` permission
     * to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  body  Optional parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> actionsReRunWorkflowAsync(
            final String owner,
            final String repo,
            final int runId,
            final Object body) {
        try { 
            return prepareActionsReRunWorkflowRequest(owner, repo, runId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsReRunWorkflow.
     */
    private ApiCall<Object, ApiException> prepareActionsReRunWorkflowRequest(
            final String owner,
            final String repo,
            final int runId,
            final Object body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/rerun")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Re-run all of the failed jobs and their dependent jobs in a workflow run using the `id` of
     * the workflow run. You must authenticate using an access token with the `repo` scope to use
     * this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  body  Optional parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object actionsReRunWorkflowFailedJobs(
            final String owner,
            final String repo,
            final int runId,
            final Object body) throws ApiException, IOException {
        return prepareActionsReRunWorkflowFailedJobsRequest(owner, repo, runId, body).execute();
    }

    /**
     * Re-run all of the failed jobs and their dependent jobs in a workflow run using the `id` of
     * the workflow run. You must authenticate using an access token with the `repo` scope to use
     * this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @param  body  Optional parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> actionsReRunWorkflowFailedJobsAsync(
            final String owner,
            final String repo,
            final int runId,
            final Object body) {
        try { 
            return prepareActionsReRunWorkflowFailedJobsRequest(owner, repo, runId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsReRunWorkflowFailedJobs.
     */
    private ApiCall<Object, ApiException> prepareActionsReRunWorkflowFailedJobsRequest(
            final String owner,
            final String repo,
            final int runId,
            final Object body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the number of billable minutes and total run time for a specific workflow run. Billable
     * minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage
     * is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are
     * also included in the usage. The usage does not include the multiplier for macOS and Windows
     * runners and is not rounded up to the nearest whole minute. For more information, see
     * "[Managing billing for GitHub
     * Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
     * Anyone with read access to the repository can use this endpoint. If the repository is private
     * you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
     * permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @return    Returns the ReposActionsRunsRunIdTimingResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsRunsRunIdTimingResponse actionsGetWorkflowRunUsage(
            final String owner,
            final String repo,
            final int runId) throws ApiException, IOException {
        return prepareActionsGetWorkflowRunUsageRequest(owner, repo, runId).execute();
    }

    /**
     * Gets the number of billable minutes and total run time for a specific workflow run. Billable
     * minutes only apply to workflows in private repositories that use GitHub-hosted runners. Usage
     * is listed for each GitHub-hosted runner operating system in milliseconds. Any job re-runs are
     * also included in the usage. The usage does not include the multiplier for macOS and Windows
     * runners and is not rounded up to the nearest whole minute. For more information, see
     * "[Managing billing for GitHub
     * Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
     * Anyone with read access to the repository can use this endpoint. If the repository is private
     * you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read`
     * permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  runId  Required parameter: The unique identifier of the workflow run.
     * @return    Returns the ReposActionsRunsRunIdTimingResponse response from the API call
     */
    public CompletableFuture<ReposActionsRunsRunIdTimingResponse> actionsGetWorkflowRunUsageAsync(
            final String owner,
            final String repo,
            final int runId) {
        try { 
            return prepareActionsGetWorkflowRunUsageRequest(owner, repo, runId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetWorkflowRunUsage.
     */
    private ApiCall<ReposActionsRunsRunIdTimingResponse, ApiException> prepareActionsGetWorkflowRunUsageRequest(
            final String owner,
            final String repo,
            final int runId) throws IOException {
        return new ApiCall.Builder<ReposActionsRunsRunIdTimingResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/runs/{run_id}/timing")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("run_id").value(runId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsRunsRunIdTimingResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all secrets available in a repository without revealing their encrypted values. You
     * must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
     * Apps must have the `secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsSecretsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsSecretsResponse actionsListRepoSecrets(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListRepoSecretsRequest(owner, repo, perPage, page).execute();
    }

    /**
     * Lists all secrets available in a repository without revealing their encrypted values. You
     * must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
     * Apps must have the `secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsSecretsResponse response from the API call
     */
    public CompletableFuture<ReposActionsSecretsResponse> actionsListRepoSecretsAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListRepoSecretsRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListRepoSecrets.
     */
    private ApiCall<ReposActionsSecretsResponse, ApiException> prepareActionsListRepoSecretsRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposActionsSecretsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/secrets")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsSecretsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
     * you can create or update secrets. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposActionsSecretsPublicKeyResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsSecretsPublicKeyResponse actionsGetRepoPublicKey(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareActionsGetRepoPublicKeyRequest(owner, repo).execute();
    }

    /**
     * Gets your public key, which you need to encrypt secrets. You need to encrypt a secret before
     * you can create or update secrets. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposActionsSecretsPublicKeyResponse response from the API call
     */
    public CompletableFuture<ReposActionsSecretsPublicKeyResponse> actionsGetRepoPublicKeyAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareActionsGetRepoPublicKeyRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetRepoPublicKey.
     */
    private ApiCall<ReposActionsSecretsPublicKeyResponse, ApiException> prepareActionsGetRepoPublicKeyRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposActionsSecretsPublicKeyResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/secrets/public-key")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsSecretsPublicKeyResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a single repository secret without revealing its encrypted value. You must authenticate
     * using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the ReposActionsSecretsSecretNameResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsSecretsSecretNameResponse actionsGetRepoSecret(
            final String owner,
            final String repo,
            final String secretName) throws ApiException, IOException {
        return prepareActionsGetRepoSecretRequest(owner, repo, secretName).execute();
    }

    /**
     * Gets a single repository secret without revealing its encrypted value. You must authenticate
     * using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `secrets` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the ReposActionsSecretsSecretNameResponse response from the API call
     */
    public CompletableFuture<ReposActionsSecretsSecretNameResponse> actionsGetRepoSecretAsync(
            final String owner,
            final String repo,
            final String secretName) {
        try { 
            return prepareActionsGetRepoSecretRequest(owner, repo, secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetRepoSecret.
     */
    private ApiCall<ReposActionsSecretsSecretNameResponse, ApiException> prepareActionsGetRepoSecretRequest(
            final String owner,
            final String repo,
            final String secretName) throws IOException {
        return new ApiCall.Builder<ReposActionsSecretsSecretNameResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/secrets/{secret_name}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsSecretsSecretNameResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates or updates a repository secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `secrets` repository permission to use this endpoint. #### Example encrypting a
     * secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example encrypting a secret using Python Encrypt your secret
     * using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with
     * Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example encrypting a
     * secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object actionsCreateOrUpdateRepoSecret(
            final String owner,
            final String repo,
            final String secretName,
            final ReposActionsSecretsSecretNameRequest body) throws ApiException, IOException {
        return prepareActionsCreateOrUpdateRepoSecretRequest(owner, repo, secretName,
                body).execute();
    }

    /**
     * Creates or updates a repository secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `secrets` repository permission to use this endpoint. #### Example encrypting a
     * secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example encrypting a secret using Python Encrypt your secret
     * using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with
     * Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example encrypting a
     * secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> actionsCreateOrUpdateRepoSecretAsync(
            final String owner,
            final String repo,
            final String secretName,
            final ReposActionsSecretsSecretNameRequest body) {
        try { 
            return prepareActionsCreateOrUpdateRepoSecretRequest(owner, repo, secretName,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsCreateOrUpdateRepoSecret.
     */
    private ApiCall<Object, ApiException> prepareActionsCreateOrUpdateRepoSecretRequest(
            final String owner,
            final String repo,
            final String secretName,
            final ReposActionsSecretsSecretNameRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/secrets/{secret_name}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a secret in a repository using the secret name. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets`
     * repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDeleteRepoSecret(
            final String owner,
            final String repo,
            final String secretName) throws ApiException, IOException {
        prepareActionsDeleteRepoSecretRequest(owner, repo, secretName).execute();
    }

    /**
     * Deletes a secret in a repository using the secret name. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets`
     * repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDeleteRepoSecretAsync(
            final String owner,
            final String repo,
            final String secretName) {
        try { 
            return prepareActionsDeleteRepoSecretRequest(owner, repo, secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteRepoSecret.
     */
    private ApiCall<Void, ApiException> prepareActionsDeleteRepoSecretRequest(
            final String owner,
            final String repo,
            final String secretName) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/secrets/{secret_name}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all repository variables. You must authenticate using an access token with the `repo`
     * scope to use this endpoint. GitHub Apps must have the `actions_variables:read` repository
     * permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 30).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsVariablesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsVariablesResponse actionsListRepoVariables(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListRepoVariablesRequest(owner, repo, perPage, page).execute();
    }

    /**
     * Lists all repository variables. You must authenticate using an access token with the `repo`
     * scope to use this endpoint. GitHub Apps must have the `actions_variables:read` repository
     * permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 30).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsVariablesResponse response from the API call
     */
    public CompletableFuture<ReposActionsVariablesResponse> actionsListRepoVariablesAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListRepoVariablesRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListRepoVariables.
     */
    private ApiCall<ReposActionsVariablesResponse, ApiException> prepareActionsListRepoVariablesRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposActionsVariablesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/variables")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 10).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsVariablesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates a repository variable that you can reference in a GitHub Actions workflow. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `actions_variables:write` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object actionsCreateRepoVariable(
            final String owner,
            final String repo,
            final ReposActionsVariablesRequest body) throws ApiException, IOException {
        return prepareActionsCreateRepoVariableRequest(owner, repo, body).execute();
    }

    /**
     * Creates a repository variable that you can reference in a GitHub Actions workflow. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `actions_variables:write` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> actionsCreateRepoVariableAsync(
            final String owner,
            final String repo,
            final ReposActionsVariablesRequest body) {
        try { 
            return prepareActionsCreateRepoVariableRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsCreateRepoVariable.
     */
    private ApiCall<Object, ApiException> prepareActionsCreateRepoVariableRequest(
            final String owner,
            final String repo,
            final ReposActionsVariablesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/variables")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific variable in a repository. You must authenticate using an access token with
     * the `repo` scope to use this endpoint. GitHub Apps must have the `actions_variables:read`
     * repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @return    Returns the ActionsVariable response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsVariable actionsGetRepoVariable(
            final String owner,
            final String repo,
            final String name) throws ApiException, IOException {
        return prepareActionsGetRepoVariableRequest(owner, repo, name).execute();
    }

    /**
     * Gets a specific variable in a repository. You must authenticate using an access token with
     * the `repo` scope to use this endpoint. GitHub Apps must have the `actions_variables:read`
     * repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @return    Returns the ActionsVariable response from the API call
     */
    public CompletableFuture<ActionsVariable> actionsGetRepoVariableAsync(
            final String owner,
            final String repo,
            final String name) {
        try { 
            return prepareActionsGetRepoVariableRequest(owner, repo, name).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetRepoVariable.
     */
    private ApiCall<ActionsVariable, ApiException> prepareActionsGetRepoVariableRequest(
            final String owner,
            final String repo,
            final String name) throws IOException {
        return new ApiCall.Builder<ActionsVariable, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/variables/{name}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsVariable.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates a repository variable that you can reference in a GitHub Actions workflow. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `actions_variables:write` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsUpdateRepoVariable(
            final String owner,
            final String repo,
            final String name,
            final ReposActionsVariablesNameRequest body) throws ApiException, IOException {
        prepareActionsUpdateRepoVariableRequest(owner, repo, name, body).execute();
    }

    /**
     * Updates a repository variable that you can reference in a GitHub Actions workflow. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `actions_variables:write` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsUpdateRepoVariableAsync(
            final String owner,
            final String repo,
            final String name,
            final ReposActionsVariablesNameRequest body) {
        try { 
            return prepareActionsUpdateRepoVariableRequest(owner, repo, name, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsUpdateRepoVariable.
     */
    private ApiCall<Void, ApiException> prepareActionsUpdateRepoVariableRequest(
            final String owner,
            final String repo,
            final String name,
            final ReposActionsVariablesNameRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/variables/{name}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a repository variable using the variable name. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `actions_variables:write` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDeleteRepoVariable(
            final String owner,
            final String repo,
            final String name) throws ApiException, IOException {
        prepareActionsDeleteRepoVariableRequest(owner, repo, name).execute();
    }

    /**
     * Deletes a repository variable using the variable name. You must authenticate using an access
     * token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `actions_variables:write` repository permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  name  Required parameter: The name of the variable.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDeleteRepoVariableAsync(
            final String owner,
            final String repo,
            final String name) {
        try { 
            return prepareActionsDeleteRepoVariableRequest(owner, repo, name).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteRepoVariable.
     */
    private ApiCall<Void, ApiException> prepareActionsDeleteRepoVariableRequest(
            final String owner,
            final String repo,
            final String name) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/variables/{name}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the workflows in a repository. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsWorkflowsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsWorkflowsResponse actionsListRepoWorkflows(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListRepoWorkflowsRequest(owner, repo, perPage, page).execute();
    }

    /**
     * Lists the workflows in a repository. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsWorkflowsResponse response from the API call
     */
    public CompletableFuture<ReposActionsWorkflowsResponse> actionsListRepoWorkflowsAsync(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListRepoWorkflowsRequest(owner, repo, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListRepoWorkflows.
     */
    private ApiCall<ReposActionsWorkflowsResponse, ApiException> prepareActionsListRepoWorkflowsRequest(
            final String owner,
            final String repo,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposActionsWorkflowsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/workflows")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsWorkflowsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific workflow. You can replace `workflow_id` with the workflow file name. For
     * example, you could use `main.yaml`. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  workflowId  Required parameter: The ID of the workflow. You can also pass the
     *         workflow file name as a string.
     * @return    Returns the ReposActionsWorkflowsWorkflowIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsWorkflowsWorkflowIdResponse actionsGetWorkflow(
            final String owner,
            final String repo,
            final ActionsGetWorkflowWorkflowId workflowId) throws ApiException, IOException {
        return prepareActionsGetWorkflowRequest(owner, repo, workflowId).execute();
    }

    /**
     * Gets a specific workflow. You can replace `workflow_id` with the workflow file name. For
     * example, you could use `main.yaml`. Anyone with read access to the repository can use this
     * endpoint. If the repository is private you must use an access token with the `repo` scope.
     * GitHub Apps must have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  workflowId  Required parameter: The ID of the workflow. You can also pass the
     *         workflow file name as a string.
     * @return    Returns the ReposActionsWorkflowsWorkflowIdResponse response from the API call
     */
    public CompletableFuture<ReposActionsWorkflowsWorkflowIdResponse> actionsGetWorkflowAsync(
            final String owner,
            final String repo,
            final ActionsGetWorkflowWorkflowId workflowId) {
        try { 
            return prepareActionsGetWorkflowRequest(owner, repo, workflowId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetWorkflow.
     */
    private ApiCall<ReposActionsWorkflowsWorkflowIdResponse, ApiException> prepareActionsGetWorkflowRequest(
            final String owner,
            final String repo,
            final ActionsGetWorkflowWorkflowId workflowId) throws IOException {
        return new ApiCall.Builder<ReposActionsWorkflowsWorkflowIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/workflows/{workflow_id}")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("workflow_id").value(workflowId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsWorkflowsWorkflowIdResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Disables a workflow and sets the `state` of the workflow to `disabled_manually`. You can
     * replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     * GitHub Apps must have the `actions:write` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  workflowId  Required parameter: The ID of the workflow. You can also pass the
     *         workflow file name as a string.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDisableWorkflow(
            final String owner,
            final String repo,
            final ActionsDisableWorkflowWorkflowId workflowId) throws ApiException, IOException {
        prepareActionsDisableWorkflowRequest(owner, repo, workflowId).execute();
    }

    /**
     * Disables a workflow and sets the `state` of the workflow to `disabled_manually`. You can
     * replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`.
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     * GitHub Apps must have the `actions:write` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  workflowId  Required parameter: The ID of the workflow. You can also pass the
     *         workflow file name as a string.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDisableWorkflowAsync(
            final String owner,
            final String repo,
            final ActionsDisableWorkflowWorkflowId workflowId) {
        try { 
            return prepareActionsDisableWorkflowRequest(owner, repo, workflowId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDisableWorkflow.
     */
    private ApiCall<Void, ApiException> prepareActionsDisableWorkflowRequest(
            final String owner,
            final String repo,
            final ActionsDisableWorkflowWorkflowId workflowId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("workflow_id").value(workflowId)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * You can use this endpoint to manually trigger a GitHub Actions workflow run. You can replace
     * `workflow_id` with the workflow file name. For example, you could use `main.yaml`. You must
     * configure your GitHub Actions workflow to run when the [`workflow_dispatch`
     * webhook](/developers/webhooks-and-events/webhook-events-and-payloads#workflow_dispatch) event
     * occurs. The `inputs` are configured in the workflow file. For more information about how to
     * configure the `workflow_dispatch` event in the workflow file, see "[Events that trigger
     * workflows](/actions/reference/events-that-trigger-workflows#workflow_dispatch)." You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `actions:write` permission to use this endpoint. For more information, see
     * "[Creating a personal access token for the command
     * line](https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  workflowId  Required parameter: The ID of the workflow. You can also pass the
     *         workflow file name as a string.
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsCreateWorkflowDispatch(
            final String owner,
            final String repo,
            final ActionsCreateWorkflowDispatchWorkflowId workflowId,
            final ReposActionsWorkflowsWorkflowIdDispatchesRequest body) throws ApiException, IOException {
        prepareActionsCreateWorkflowDispatchRequest(owner, repo, workflowId, body).execute();
    }

    /**
     * You can use this endpoint to manually trigger a GitHub Actions workflow run. You can replace
     * `workflow_id` with the workflow file name. For example, you could use `main.yaml`. You must
     * configure your GitHub Actions workflow to run when the [`workflow_dispatch`
     * webhook](/developers/webhooks-and-events/webhook-events-and-payloads#workflow_dispatch) event
     * occurs. The `inputs` are configured in the workflow file. For more information about how to
     * configure the `workflow_dispatch` event in the workflow file, see "[Events that trigger
     * workflows](/actions/reference/events-that-trigger-workflows#workflow_dispatch)." You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `actions:write` permission to use this endpoint. For more information, see
     * "[Creating a personal access token for the command
     * line](https://docs.github.com/articles/creating-a-personal-access-token-for-the-command-line).".
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  workflowId  Required parameter: The ID of the workflow. You can also pass the
     *         workflow file name as a string.
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsCreateWorkflowDispatchAsync(
            final String owner,
            final String repo,
            final ActionsCreateWorkflowDispatchWorkflowId workflowId,
            final ReposActionsWorkflowsWorkflowIdDispatchesRequest body) {
        try { 
            return prepareActionsCreateWorkflowDispatchRequest(owner, repo, workflowId,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsCreateWorkflowDispatch.
     */
    private ApiCall<Void, ApiException> prepareActionsCreateWorkflowDispatchRequest(
            final String owner,
            final String repo,
            final ActionsCreateWorkflowDispatchWorkflowId workflowId,
            final ReposActionsWorkflowsWorkflowIdDispatchesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("workflow_id").value(workflowId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Enables a workflow and sets the `state` of the workflow to `active`. You can replace
     * `workflow_id` with the workflow file name. For example, you could use `main.yaml`. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `actions:write` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  workflowId  Required parameter: The ID of the workflow. You can also pass the
     *         workflow file name as a string.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsEnableWorkflow(
            final String owner,
            final String repo,
            final ActionsEnableWorkflowWorkflowId workflowId) throws ApiException, IOException {
        prepareActionsEnableWorkflowRequest(owner, repo, workflowId).execute();
    }

    /**
     * Enables a workflow and sets the `state` of the workflow to `active`. You can replace
     * `workflow_id` with the workflow file name. For example, you could use `main.yaml`. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `actions:write` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  workflowId  Required parameter: The ID of the workflow. You can also pass the
     *         workflow file name as a string.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsEnableWorkflowAsync(
            final String owner,
            final String repo,
            final ActionsEnableWorkflowWorkflowId workflowId) {
        try { 
            return prepareActionsEnableWorkflowRequest(owner, repo, workflowId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsEnableWorkflow.
     */
    private ApiCall<Void, ApiException> prepareActionsEnableWorkflowRequest(
            final String owner,
            final String repo,
            final ActionsEnableWorkflowWorkflowId workflowId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("workflow_id").value(workflowId)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List all workflow runs for a workflow. You can replace `workflow_id` with the workflow file
     * name. For example, you could use `main.yaml`. You can use parameters to narrow the list of
     * results. For more information about using parameters, see
     * [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
     * Anyone with read access to the repository can use this endpoint. If the repository is private
     * you must use an access token with the `repo` scope.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  workflowId  Required parameter: The ID of the workflow. You can also pass the
     *         workflow file name as a string.
     * @param  actor  Optional parameter: Returns someone's workflow runs. Use the login for the
     *         user who created the `push` associated with the check suite or workflow run.
     * @param  branch  Optional parameter: Returns workflow runs associated with a branch. Use the
     *         name of the branch of the `push`.
     * @param  event  Optional parameter: Returns workflow run triggered by the event you specify.
     *         For example, `push`, `pull_request` or `issue`. For more information, see "[Events
     *         that trigger
     *         workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
     * @param  status  Optional parameter: Returns workflow runs with the check run `status` or
     *         `conclusion` that you specify. For example, a conclusion can be `success` or a status
     *         can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  created  Optional parameter: Returns workflow runs created within the given date-time
     *         range. For more information on the syntax, see "[Understanding the search
     *         syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
     * @param  excludePullRequests  Optional parameter: If `true` pull requests are omitted from the
     *         response (empty array).
     * @param  checkSuiteId  Optional parameter: Returns workflow runs with the `check_suite_id`
     *         that you specify.
     * @param  headSha  Optional parameter: Only returns workflow runs that are associated with the
     *         specified `head_sha`.
     * @return    Returns the ReposActionsWorkflowsWorkflowIdRunsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsWorkflowsWorkflowIdRunsResponse actionsListWorkflowRuns(
            final String owner,
            final String repo,
            final ActionsListWorkflowRunsWorkflowId workflowId,
            final String actor,
            final String branch,
            final String event,
            final Status81Enum status,
            final Integer perPage,
            final Integer page,
            final LocalDateTime created,
            final Boolean excludePullRequests,
            final Integer checkSuiteId,
            final String headSha) throws ApiException, IOException {
        return prepareActionsListWorkflowRunsRequest(owner, repo, workflowId, actor, branch, event,
                status, perPage, page, created, excludePullRequests, checkSuiteId,
                headSha).execute();
    }

    /**
     * List all workflow runs for a workflow. You can replace `workflow_id` with the workflow file
     * name. For example, you could use `main.yaml`. You can use parameters to narrow the list of
     * results. For more information about using parameters, see
     * [Parameters](https://docs.github.com/rest/overview/resources-in-the-rest-api#parameters).
     * Anyone with read access to the repository can use this endpoint. If the repository is private
     * you must use an access token with the `repo` scope.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  workflowId  Required parameter: The ID of the workflow. You can also pass the
     *         workflow file name as a string.
     * @param  actor  Optional parameter: Returns someone's workflow runs. Use the login for the
     *         user who created the `push` associated with the check suite or workflow run.
     * @param  branch  Optional parameter: Returns workflow runs associated with a branch. Use the
     *         name of the branch of the `push`.
     * @param  event  Optional parameter: Returns workflow run triggered by the event you specify.
     *         For example, `push`, `pull_request` or `issue`. For more information, see "[Events
     *         that trigger
     *         workflows](https://docs.github.com/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
     * @param  status  Optional parameter: Returns workflow runs with the check run `status` or
     *         `conclusion` that you specify. For example, a conclusion can be `success` or a status
     *         can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  created  Optional parameter: Returns workflow runs created within the given date-time
     *         range. For more information on the syntax, see "[Understanding the search
     *         syntax](https://docs.github.com/search-github/getting-started-with-searching-on-github/understanding-the-search-syntax#query-for-dates)."
     * @param  excludePullRequests  Optional parameter: If `true` pull requests are omitted from the
     *         response (empty array).
     * @param  checkSuiteId  Optional parameter: Returns workflow runs with the `check_suite_id`
     *         that you specify.
     * @param  headSha  Optional parameter: Only returns workflow runs that are associated with the
     *         specified `head_sha`.
     * @return    Returns the ReposActionsWorkflowsWorkflowIdRunsResponse response from the API call
     */
    public CompletableFuture<ReposActionsWorkflowsWorkflowIdRunsResponse> actionsListWorkflowRunsAsync(
            final String owner,
            final String repo,
            final ActionsListWorkflowRunsWorkflowId workflowId,
            final String actor,
            final String branch,
            final String event,
            final Status81Enum status,
            final Integer perPage,
            final Integer page,
            final LocalDateTime created,
            final Boolean excludePullRequests,
            final Integer checkSuiteId,
            final String headSha) {
        try { 
            return prepareActionsListWorkflowRunsRequest(owner, repo, workflowId, actor, branch, event,
            status, perPage, page, created, excludePullRequests, checkSuiteId,
            headSha).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListWorkflowRuns.
     */
    private ApiCall<ReposActionsWorkflowsWorkflowIdRunsResponse, ApiException> prepareActionsListWorkflowRunsRequest(
            final String owner,
            final String repo,
            final ActionsListWorkflowRunsWorkflowId workflowId,
            final String actor,
            final String branch,
            final String event,
            final Status81Enum status,
            final Integer perPage,
            final Integer page,
            final LocalDateTime created,
            final Boolean excludePullRequests,
            final Integer checkSuiteId,
            final String headSha) throws IOException {
        return new ApiCall.Builder<ReposActionsWorkflowsWorkflowIdRunsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs")
                        .queryParam(param -> param.key("actor")
                                .value(actor).isRequired(false))
                        .queryParam(param -> param.key("branch")
                                .value(branch).isRequired(false))
                        .queryParam(param -> param.key("event")
                                .value(event).isRequired(false))
                        .queryParam(param -> param.key("status")
                                .value((status != null) ? status.value() : null).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("created")
                                .value(DateTimeHelper.toRfc8601DateTime(created)).isRequired(false))
                        .queryParam(param -> param.key("exclude_pull_requests")
                                .value((excludePullRequests != null) ? excludePullRequests : false).isRequired(false))
                        .queryParam(param -> param.key("check_suite_id")
                                .value(checkSuiteId).isRequired(false))
                        .queryParam(param -> param.key("head_sha")
                                .value(headSha).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("workflow_id").value(workflowId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsWorkflowsWorkflowIdRunsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets the number of billable minutes used by a specific workflow during the current billing
     * cycle. Billable minutes only apply to workflows in private repositories that use
     * GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in
     * milliseconds. Any job re-runs are also included in the usage. The usage does not include the
     * multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute.
     * For more information, see "[Managing billing for GitHub
     * Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
     * You can replace `workflow_id` with the workflow file name. For example, you could use
     * `main.yaml`. Anyone with read access to the repository can use this endpoint. If the
     * repository is private you must use an access token with the `repo` scope. GitHub Apps must
     * have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  workflowId  Required parameter: The ID of the workflow. You can also pass the
     *         workflow file name as a string.
     * @return    Returns the ReposActionsWorkflowsWorkflowIdTimingResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsWorkflowsWorkflowIdTimingResponse actionsGetWorkflowUsage(
            final String owner,
            final String repo,
            final ActionsGetWorkflowUsageWorkflowId workflowId) throws ApiException, IOException {
        return prepareActionsGetWorkflowUsageRequest(owner, repo, workflowId).execute();
    }

    /**
     * Gets the number of billable minutes used by a specific workflow during the current billing
     * cycle. Billable minutes only apply to workflows in private repositories that use
     * GitHub-hosted runners. Usage is listed for each GitHub-hosted runner operating system in
     * milliseconds. Any job re-runs are also included in the usage. The usage does not include the
     * multiplier for macOS and Windows runners and is not rounded up to the nearest whole minute.
     * For more information, see "[Managing billing for GitHub
     * Actions](https://docs.github.com/github/setting-up-and-managing-billing-and-payments-on-github/managing-billing-for-github-actions)".
     * You can replace `workflow_id` with the workflow file name. For example, you could use
     * `main.yaml`. Anyone with read access to the repository can use this endpoint. If the
     * repository is private you must use an access token with the `repo` scope. GitHub Apps must
     * have the `actions:read` permission to use this endpoint.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  workflowId  Required parameter: The ID of the workflow. You can also pass the
     *         workflow file name as a string.
     * @return    Returns the ReposActionsWorkflowsWorkflowIdTimingResponse response from the API call
     */
    public CompletableFuture<ReposActionsWorkflowsWorkflowIdTimingResponse> actionsGetWorkflowUsageAsync(
            final String owner,
            final String repo,
            final ActionsGetWorkflowUsageWorkflowId workflowId) {
        try { 
            return prepareActionsGetWorkflowUsageRequest(owner, repo, workflowId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetWorkflowUsage.
     */
    private ApiCall<ReposActionsWorkflowsWorkflowIdTimingResponse, ApiException> prepareActionsGetWorkflowUsageRequest(
            final String owner,
            final String repo,
            final ActionsGetWorkflowUsageWorkflowId workflowId) throws IOException {
        return new ApiCall.Builder<ReposActionsWorkflowsWorkflowIdTimingResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("workflow_id").value(workflowId)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsWorkflowsWorkflowIdTimingResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all secrets available in an environment without revealing their encrypted values. You
     * must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
     * Apps must have the `secrets` repository permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsSecretsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsSecretsResponse actionsListEnvironmentSecrets(
            final int repositoryId,
            final String environmentName,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListEnvironmentSecretsRequest(repositoryId, environmentName, perPage,
                page).execute();
    }

    /**
     * Lists all secrets available in an environment without revealing their encrypted values. You
     * must authenticate using an access token with the `repo` scope to use this endpoint. GitHub
     * Apps must have the `secrets` repository permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsSecretsResponse response from the API call
     */
    public CompletableFuture<ReposActionsSecretsResponse> actionsListEnvironmentSecretsAsync(
            final int repositoryId,
            final String environmentName,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListEnvironmentSecretsRequest(repositoryId, environmentName, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListEnvironmentSecrets.
     */
    private ApiCall<ReposActionsSecretsResponse, ApiException> prepareActionsListEnvironmentSecretsRequest(
            final int repositoryId,
            final String environmentName,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposActionsSecretsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repositories/{repository_id}/environments/{environment_name}/secrets")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsSecretsResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Get the public key for an environment, which you need to encrypt environment secrets. You
     * need to encrypt a secret before you can create or update secrets. Anyone with read access to
     * the repository can use this endpoint. If the repository is private you must use an access
     * token with the `repo` scope. GitHub Apps must have the `secrets` repository permission to use
     * this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @return    Returns the RepositoriesEnvironmentsSecretsPublicKeyResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public RepositoriesEnvironmentsSecretsPublicKeyResponse actionsGetEnvironmentPublicKey(
            final int repositoryId,
            final String environmentName) throws ApiException, IOException {
        return prepareActionsGetEnvironmentPublicKeyRequest(repositoryId,
                environmentName).execute();
    }

    /**
     * Get the public key for an environment, which you need to encrypt environment secrets. You
     * need to encrypt a secret before you can create or update secrets. Anyone with read access to
     * the repository can use this endpoint. If the repository is private you must use an access
     * token with the `repo` scope. GitHub Apps must have the `secrets` repository permission to use
     * this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @return    Returns the RepositoriesEnvironmentsSecretsPublicKeyResponse response from the API call
     */
    public CompletableFuture<RepositoriesEnvironmentsSecretsPublicKeyResponse> actionsGetEnvironmentPublicKeyAsync(
            final int repositoryId,
            final String environmentName) {
        try { 
            return prepareActionsGetEnvironmentPublicKeyRequest(repositoryId,
            environmentName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetEnvironmentPublicKey.
     */
    private ApiCall<RepositoriesEnvironmentsSecretsPublicKeyResponse, ApiException> prepareActionsGetEnvironmentPublicKeyRequest(
            final int repositoryId,
            final String environmentName) throws IOException {
        return new ApiCall.Builder<RepositoriesEnvironmentsSecretsPublicKeyResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repositories/{repository_id}/environments/{environment_name}/secrets/public-key")
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, RepositoriesEnvironmentsSecretsPublicKeyResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a single environment secret without revealing its encrypted value. You must authenticate
     * using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `secrets` repository permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the RepositoriesEnvironmentsSecretsSecretNameResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public RepositoriesEnvironmentsSecretsSecretNameResponse actionsGetEnvironmentSecret(
            final int repositoryId,
            final String environmentName,
            final String secretName) throws ApiException, IOException {
        return prepareActionsGetEnvironmentSecretRequest(repositoryId, environmentName,
                secretName).execute();
    }

    /**
     * Gets a single environment secret without revealing its encrypted value. You must authenticate
     * using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `secrets` repository permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the RepositoriesEnvironmentsSecretsSecretNameResponse response from the API call
     */
    public CompletableFuture<RepositoriesEnvironmentsSecretsSecretNameResponse> actionsGetEnvironmentSecretAsync(
            final int repositoryId,
            final String environmentName,
            final String secretName) {
        try { 
            return prepareActionsGetEnvironmentSecretRequest(repositoryId, environmentName,
            secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetEnvironmentSecret.
     */
    private ApiCall<RepositoriesEnvironmentsSecretsSecretNameResponse, ApiException> prepareActionsGetEnvironmentSecretRequest(
            final int repositoryId,
            final String environmentName,
            final String secretName) throws IOException {
        return new ApiCall.Builder<RepositoriesEnvironmentsSecretsSecretNameResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}")
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, RepositoriesEnvironmentsSecretsSecretNameResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates or updates an environment secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `secrets` repository permission to use this endpoint. #### Example encrypting a
     * secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example encrypting a secret using Python Encrypt your secret
     * using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with
     * Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example encrypting a
     * secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object actionsCreateOrUpdateEnvironmentSecret(
            final int repositoryId,
            final String environmentName,
            final String secretName,
            final RepositoriesEnvironmentsSecretsSecretNameRequest body) throws ApiException, IOException {
        return prepareActionsCreateOrUpdateEnvironmentSecretRequest(repositoryId, environmentName,
                secretName, body).execute();
    }

    /**
     * Creates or updates an environment secret with an encrypted value. Encrypt your secret using
     * [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages). You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `secrets` repository permission to use this endpoint. #### Example encrypting a
     * secret using Node.js Encrypt your secret using the
     * [libsodium-wrappers](https://www.npmjs.com/package/libsodium-wrappers) library. ``` const
     * sodium = require('libsodium-wrappers') const secret = 'plain-text-secret' // replace with the
     * secret you want to encrypt const key = 'base64-encoded-public-key' // replace with the Base64
     * encoded public key //Check if libsodium is ready and then proceed. sodium.ready.then(() =&gt; {
     * // Convert Secret & Base64 key to Uint8Array. let binkey = sodium.from_base64(key,
     * sodium.base64_variants.ORIGINAL) let binsec = sodium.from_string(secret) //Encrypt the secret
     * using LibSodium let encBytes = sodium.crypto_box_seal(binsec, binkey) // Convert encrypted
     * Uint8Array to Base64 let output = sodium.to_base64(encBytes, sodium.base64_variants.ORIGINAL)
     * console.log(output) }); ``` #### Example encrypting a secret using Python Encrypt your secret
     * using [pynacl](https://pynacl.readthedocs.io/en/latest/public/#nacl-public-sealedbox) with
     * Python 3. ``` from base64 import b64encode from nacl import encoding, public def
     * encrypt(public_key: str, secret_value: str) -&gt; str: """Encrypt a Unicode string using the
     * public key.""" public_key = public.PublicKey(public_key.encode("utf-8"),
     * encoding.Base64Encoder()) sealed_box = public.SealedBox(public_key) encrypted =
     * sealed_box.encrypt(secret_value.encode("utf-8")) return b64encode(encrypted).decode("utf-8")
     * ``` #### Example encrypting a secret using C# Encrypt your secret using the
     * [Sodium.Core](https://www.nuget.org/packages/Sodium.Core/) package. ``` var secretValue =
     * System.Text.Encoding.UTF8.GetBytes("mySecret"); var publicKey =
     * Convert.FromBase64String("2Sg8iYjAxxmI2LvUXpJjkYrMxURPc8r+dB7TJyvvcCU="); var
     * sealedPublicKeyBox = Sodium.SealedPublicKeyBox.Create(secretValue, publicKey);
     * Console.WriteLine(Convert.ToBase64String(sealedPublicKeyBox)); ``` #### Example encrypting a
     * secret using Ruby Encrypt your secret using the
     * [rbnacl](https://github.com/RubyCrypto/rbnacl) gem. ```ruby require "rbnacl" require "base64"
     * key = Base64.decode64("+ZYvJDZMHUfBkJdyq5Zm9SKqeuBQ4sj+6sfjlH4CgG0=") public_key =
     * RbNaCl::PublicKey.new(key) box = RbNaCl::Boxes::Sealed.from_public_key(public_key)
     * encrypted_secret = box.encrypt("my_secret") # Print the base64 encoded secret puts
     * Base64.strict_encode64(encrypted_secret) ```.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  secretName  Required parameter: The name of the secret.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> actionsCreateOrUpdateEnvironmentSecretAsync(
            final int repositoryId,
            final String environmentName,
            final String secretName,
            final RepositoriesEnvironmentsSecretsSecretNameRequest body) {
        try { 
            return prepareActionsCreateOrUpdateEnvironmentSecretRequest(repositoryId, environmentName,
            secretName, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsCreateOrUpdateEnvironmentSecret.
     */
    private ApiCall<Object, ApiException> prepareActionsCreateOrUpdateEnvironmentSecretRequest(
            final int repositoryId,
            final String environmentName,
            final String secretName,
            final RepositoriesEnvironmentsSecretsSecretNameRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a secret in an environment using the secret name. You must authenticate using an
     * access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets`
     * repository permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  secretName  Required parameter: The name of the secret.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDeleteEnvironmentSecret(
            final int repositoryId,
            final String environmentName,
            final String secretName) throws ApiException, IOException {
        prepareActionsDeleteEnvironmentSecretRequest(repositoryId, environmentName,
                secretName).execute();
    }

    /**
     * Deletes a secret in an environment using the secret name. You must authenticate using an
     * access token with the `repo` scope to use this endpoint. GitHub Apps must have the `secrets`
     * repository permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  secretName  Required parameter: The name of the secret.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDeleteEnvironmentSecretAsync(
            final int repositoryId,
            final String environmentName,
            final String secretName) {
        try { 
            return prepareActionsDeleteEnvironmentSecretRequest(repositoryId, environmentName,
            secretName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteEnvironmentSecret.
     */
    private ApiCall<Void, ApiException> prepareActionsDeleteEnvironmentSecretRequest(
            final int repositoryId,
            final String environmentName,
            final String secretName) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}")
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("secret_name").value(secretName)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all environment variables. You must authenticate using an access token with the `repo`
     * scope to use this endpoint. GitHub Apps must have the `environments:read` repository
     * permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  perPage  Optional parameter: The number of results per page (max 30).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsVariablesResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposActionsVariablesResponse actionsListEnvironmentVariables(
            final int repositoryId,
            final String environmentName,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareActionsListEnvironmentVariablesRequest(repositoryId, environmentName, perPage,
                page).execute();
    }

    /**
     * Lists all environment variables. You must authenticate using an access token with the `repo`
     * scope to use this endpoint. GitHub Apps must have the `environments:read` repository
     * permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  perPage  Optional parameter: The number of results per page (max 30).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the ReposActionsVariablesResponse response from the API call
     */
    public CompletableFuture<ReposActionsVariablesResponse> actionsListEnvironmentVariablesAsync(
            final int repositoryId,
            final String environmentName,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareActionsListEnvironmentVariablesRequest(repositoryId, environmentName, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsListEnvironmentVariables.
     */
    private ApiCall<ReposActionsVariablesResponse, ApiException> prepareActionsListEnvironmentVariablesRequest(
            final int repositoryId,
            final String environmentName,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<ReposActionsVariablesResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repositories/{repository_id}/environments/{environment_name}/variables")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 10).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposActionsVariablesResponse.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Create an environment variable that you can reference in a GitHub Actions workflow. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `environment:write` repository permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public Object actionsCreateEnvironmentVariable(
            final int repositoryId,
            final String environmentName,
            final ReposActionsVariablesRequest body) throws ApiException, IOException {
        return prepareActionsCreateEnvironmentVariableRequest(repositoryId, environmentName,
                body).execute();
    }

    /**
     * Create an environment variable that you can reference in a GitHub Actions workflow. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `environment:write` repository permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  body  Required parameter: Example:
     * @return    Returns the Object response from the API call
     */
    public CompletableFuture<Object> actionsCreateEnvironmentVariableAsync(
            final int repositoryId,
            final String environmentName,
            final ReposActionsVariablesRequest body) {
        try { 
            return prepareActionsCreateEnvironmentVariableRequest(repositoryId, environmentName,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsCreateEnvironmentVariable.
     */
    private ApiCall<Object, ApiException> prepareActionsCreateEnvironmentVariableRequest(
            final int repositoryId,
            final String environmentName,
            final ReposActionsVariablesRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Object, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repositories/{repository_id}/environments/{environment_name}/variables")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> response)
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets a specific variable in an environment. You must authenticate using an access token with
     * the `repo` scope to use this endpoint. GitHub Apps must have the `environments:read`
     * repository permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  name  Required parameter: The name of the variable.
     * @return    Returns the ActionsVariable response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ActionsVariable actionsGetEnvironmentVariable(
            final int repositoryId,
            final String environmentName,
            final String name) throws ApiException, IOException {
        return prepareActionsGetEnvironmentVariableRequest(repositoryId, environmentName,
                name).execute();
    }

    /**
     * Gets a specific variable in an environment. You must authenticate using an access token with
     * the `repo` scope to use this endpoint. GitHub Apps must have the `environments:read`
     * repository permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  environmentName  Required parameter: The name of the environment.
     * @param  name  Required parameter: The name of the variable.
     * @return    Returns the ActionsVariable response from the API call
     */
    public CompletableFuture<ActionsVariable> actionsGetEnvironmentVariableAsync(
            final int repositoryId,
            final String environmentName,
            final String name) {
        try { 
            return prepareActionsGetEnvironmentVariableRequest(repositoryId, environmentName,
            name).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsGetEnvironmentVariable.
     */
    private ApiCall<ActionsVariable, ApiException> prepareActionsGetEnvironmentVariableRequest(
            final int repositoryId,
            final String environmentName,
            final String name) throws IOException {
        return new ApiCall.Builder<ActionsVariable, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repositories/{repository_id}/environments/{environment_name}/variables/{name}")
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ActionsVariable.class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Updates an environment variable that you can reference in a GitHub Actions workflow. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `environment:write` repository permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  name  Required parameter: The name of the variable.
     * @param  environmentName  Required parameter: Example:
     * @param  body  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsUpdateEnvironmentVariable(
            final int repositoryId,
            final String name,
            final String environmentName,
            final ReposActionsVariablesNameRequest body) throws ApiException, IOException {
        prepareActionsUpdateEnvironmentVariableRequest(repositoryId, name, environmentName,
                body).execute();
    }

    /**
     * Updates an environment variable that you can reference in a GitHub Actions workflow. You must
     * authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps
     * must have the `environment:write` repository permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  name  Required parameter: The name of the variable.
     * @param  environmentName  Required parameter: Example:
     * @param  body  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsUpdateEnvironmentVariableAsync(
            final int repositoryId,
            final String name,
            final String environmentName,
            final ReposActionsVariablesNameRequest body) {
        try { 
            return prepareActionsUpdateEnvironmentVariableRequest(repositoryId, name, environmentName,
            body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsUpdateEnvironmentVariable.
     */
    private ApiCall<Void, ApiException> prepareActionsUpdateEnvironmentVariableRequest(
            final int repositoryId,
            final String name,
            final String environmentName,
            final ReposActionsVariablesNameRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repositories/{repository_id}/environments/{environment_name}/variables/{name}")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes an environment variable using the variable name. You must authenticate using an
     * access token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `environment:write` repository permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  name  Required parameter: The name of the variable.
     * @param  environmentName  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void actionsDeleteEnvironmentVariable(
            final int repositoryId,
            final String name,
            final String environmentName) throws ApiException, IOException {
        prepareActionsDeleteEnvironmentVariableRequest(repositoryId, name,
                environmentName).execute();
    }

    /**
     * Deletes an environment variable using the variable name. You must authenticate using an
     * access token with the `repo` scope to use this endpoint. GitHub Apps must have the
     * `environment:write` repository permission to use this endpoint.
     * @param  repositoryId  Required parameter: The unique identifier of the repository.
     * @param  name  Required parameter: The name of the variable.
     * @param  environmentName  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> actionsDeleteEnvironmentVariableAsync(
            final int repositoryId,
            final String name,
            final String environmentName) {
        try { 
            return prepareActionsDeleteEnvironmentVariableRequest(repositoryId, name,
            environmentName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for actionsDeleteEnvironmentVariable.
     */
    private ApiCall<Void, ApiException> prepareActionsDeleteEnvironmentVariableRequest(
            final int repositoryId,
            final String name,
            final String environmentName) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repositories/{repository_id}/environments/{environment_name}/variables/{name}")
                        .templateParam(param -> param.key("repository_id").value(repositoryId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("name").value(name)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("environment_name").value(environmentName)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}