/*
 * GitHubAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.github.api.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.github.api.ApiHelper;
import com.github.api.Server;
import com.github.api.exceptions.ApiException;
import com.github.api.exceptions.OrgsMigrations404ErrorException;
import com.github.api.exceptions.OrgsMigrations422ErrorException;
import com.github.api.exceptions.OrgsMigrationsArchive404ErrorException;
import com.github.api.exceptions.OrgsMigrationsReposRepoNameLock404ErrorException;
import com.github.api.exceptions.OrgsMigrationsRepositories404ErrorException;
import com.github.api.exceptions.ReposImport404ErrorException;
import com.github.api.exceptions.ReposImport422ErrorException;
import com.github.api.exceptions.ReposImport503ErrorException;
import com.github.api.exceptions.ReposImportAuthors404ErrorException;
import com.github.api.exceptions.ReposImportAuthors503ErrorException;
import com.github.api.exceptions.ReposImportAuthorsAuthorId404ErrorException;
import com.github.api.exceptions.ReposImportAuthorsAuthorId422ErrorException;
import com.github.api.exceptions.ReposImportAuthorsAuthorId503ErrorException;
import com.github.api.exceptions.ReposImportLargeFiles503ErrorException;
import com.github.api.exceptions.ReposImportLfs422ErrorException;
import com.github.api.exceptions.ReposImportLfs503ErrorException;
import com.github.api.exceptions.UserMigrations401ErrorException;
import com.github.api.exceptions.UserMigrations403ErrorException;
import com.github.api.exceptions.UserMigrations404ErrorException;
import com.github.api.exceptions.UserMigrations422ErrorException;
import com.github.api.exceptions.UserMigrationsArchive401ErrorException;
import com.github.api.exceptions.UserMigrationsArchive403ErrorException;
import com.github.api.exceptions.UserMigrationsArchive404ErrorException;
import com.github.api.exceptions.UserMigrationsReposLock401ErrorException;
import com.github.api.exceptions.UserMigrationsReposLock403ErrorException;
import com.github.api.exceptions.UserMigrationsReposLock404ErrorException;
import com.github.api.exceptions.UserMigrationsRepositories404ErrorException;
import com.github.api.http.request.HttpMethod;
import com.github.api.models.ExcludeEnum;
import com.github.api.models.Migration;
import com.github.api.models.MinimalRepository;
import com.github.api.models.OrgsMigrationsRequest;
import com.github.api.models.OrgsMigrationsResponse;
import com.github.api.models.PorterAuthor;
import com.github.api.models.PorterLargeFile;
import com.github.api.models.ReposImportAuthorsAuthorIdRequest;
import com.github.api.models.ReposImportAuthorsAuthorIdResponse;
import com.github.api.models.ReposImportLfsRequest;
import com.github.api.models.ReposImportLfsResponse;
import com.github.api.models.ReposImportRequest;
import com.github.api.models.ReposImportResponse;
import com.github.api.models.UserMigrationsRequest;
import com.github.api.models.UserMigrationsResponse;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class MigrationsController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public MigrationsController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * Lists the most recent migrations.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  exclude  Optional parameter: Exclude attributes from the API response to improve
     *         performance
     * @return    Returns the List of Migration response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Migration> migrationsListForOrg(
            final String org,
            final Integer perPage,
            final Integer page,
            final List<ExcludeEnum> exclude) throws ApiException, IOException {
        return prepareMigrationsListForOrgRequest(org, perPage, page, exclude).execute();
    }

    /**
     * Lists the most recent migrations.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @param  exclude  Optional parameter: Exclude attributes from the API response to improve
     *         performance
     * @return    Returns the List of Migration response from the API call
     */
    public CompletableFuture<List<Migration>> migrationsListForOrgAsync(
            final String org,
            final Integer perPage,
            final Integer page,
            final List<ExcludeEnum> exclude) {
        try { 
            return prepareMigrationsListForOrgRequest(org, perPage, page, exclude).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsListForOrg.
     */
    private ApiCall<List<Migration>, ApiException> prepareMigrationsListForOrgRequest(
            final String org,
            final Integer perPage,
            final Integer page,
            final List<ExcludeEnum> exclude) throws IOException {
        return new ApiCall.Builder<List<Migration>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/migrations")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .queryParam(param -> param.key("exclude")
                                .value(ExcludeEnum.toValue(exclude)).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Migration[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Initiates the generation of a migration archive.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the OrgsMigrationsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsMigrationsResponse migrationsStartForOrg(
            final String org,
            final OrgsMigrationsRequest body) throws ApiException, IOException {
        return prepareMigrationsStartForOrgRequest(org, body).execute();
    }

    /**
     * Initiates the generation of a migration archive.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the OrgsMigrationsResponse response from the API call
     */
    public CompletableFuture<OrgsMigrationsResponse> migrationsStartForOrgAsync(
            final String org,
            final OrgsMigrationsRequest body) {
        try { 
            return prepareMigrationsStartForOrgRequest(org, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsStartForOrg.
     */
    private ApiCall<OrgsMigrationsResponse, ApiException> prepareMigrationsStartForOrgRequest(
            final String org,
            final OrgsMigrationsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<OrgsMigrationsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/migrations")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsMigrationsResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsMigrations404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new OrgsMigrations422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Fetches the status of a migration. The `state` of a migration can be one of the following
     * values: * `pending`, which means the migration hasn't started yet. * `exporting`, which means
     * the migration is in progress. * `exported`, which means the migration finished successfully.
     * * `failed`, which means the migration failed.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @param  exclude  Optional parameter: Exclude attributes from the API response to improve
     *         performance
     * @return    Returns the OrgsMigrationsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public OrgsMigrationsResponse migrationsGetStatusForOrg(
            final String org,
            final int migrationId,
            final List<ExcludeEnum> exclude) throws ApiException, IOException {
        return prepareMigrationsGetStatusForOrgRequest(org, migrationId, exclude).execute();
    }

    /**
     * Fetches the status of a migration. The `state` of a migration can be one of the following
     * values: * `pending`, which means the migration hasn't started yet. * `exporting`, which means
     * the migration is in progress. * `exported`, which means the migration finished successfully.
     * * `failed`, which means the migration failed.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @param  exclude  Optional parameter: Exclude attributes from the API response to improve
     *         performance
     * @return    Returns the OrgsMigrationsResponse response from the API call
     */
    public CompletableFuture<OrgsMigrationsResponse> migrationsGetStatusForOrgAsync(
            final String org,
            final int migrationId,
            final List<ExcludeEnum> exclude) {
        try { 
            return prepareMigrationsGetStatusForOrgRequest(org, migrationId, exclude).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsGetStatusForOrg.
     */
    private ApiCall<OrgsMigrationsResponse, ApiException> prepareMigrationsGetStatusForOrgRequest(
            final String org,
            final int migrationId,
            final List<ExcludeEnum> exclude) throws IOException {
        return new ApiCall.Builder<OrgsMigrationsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/migrations/{migration_id}")
                        .queryParam(param -> param.key("exclude")
                                .value(ExcludeEnum.toValue(exclude)).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("migration_id").value(migrationId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, OrgsMigrationsResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsMigrations404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Fetches the URL to a migration archive.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void migrationsDownloadArchiveForOrg(
            final String org,
            final int migrationId) throws ApiException, IOException {
        prepareMigrationsDownloadArchiveForOrgRequest(org, migrationId).execute();
    }

    /**
     * Fetches the URL to a migration archive.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> migrationsDownloadArchiveForOrgAsync(
            final String org,
            final int migrationId) {
        try { 
            return prepareMigrationsDownloadArchiveForOrgRequest(org, migrationId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsDownloadArchiveForOrg.
     */
    private ApiCall<Void, ApiException> prepareMigrationsDownloadArchiveForOrgRequest(
            final String org,
            final int migrationId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/migrations/{migration_id}/archive")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("migration_id").value(migrationId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsMigrationsArchive404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a previous migration archive. Migration archives are automatically deleted after
     * seven days.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void migrationsDeleteArchiveForOrg(
            final String org,
            final int migrationId) throws ApiException, IOException {
        prepareMigrationsDeleteArchiveForOrgRequest(org, migrationId).execute();
    }

    /**
     * Deletes a previous migration archive. Migration archives are automatically deleted after
     * seven days.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> migrationsDeleteArchiveForOrgAsync(
            final String org,
            final int migrationId) {
        try { 
            return prepareMigrationsDeleteArchiveForOrgRequest(org, migrationId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsDeleteArchiveForOrg.
     */
    private ApiCall<Void, ApiException> prepareMigrationsDeleteArchiveForOrgRequest(
            final String org,
            final int migrationId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/migrations/{migration_id}/archive")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("migration_id").value(migrationId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsMigrationsArchive404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Unlocks a repository that was locked for migration. You should unlock each migrated
     * repository and [delete
     * them](https://docs.github.com/rest/reference/repos#delete-a-repository) when the migration is
     * complete and you no longer need the source data.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @param  repoName  Required parameter: repo_name parameter
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void migrationsUnlockRepoForOrg(
            final String org,
            final int migrationId,
            final String repoName) throws ApiException, IOException {
        prepareMigrationsUnlockRepoForOrgRequest(org, migrationId, repoName).execute();
    }

    /**
     * Unlocks a repository that was locked for migration. You should unlock each migrated
     * repository and [delete
     * them](https://docs.github.com/rest/reference/repos#delete-a-repository) when the migration is
     * complete and you no longer need the source data.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @param  repoName  Required parameter: repo_name parameter
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> migrationsUnlockRepoForOrgAsync(
            final String org,
            final int migrationId,
            final String repoName) {
        try { 
            return prepareMigrationsUnlockRepoForOrgRequest(org, migrationId, repoName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsUnlockRepoForOrg.
     */
    private ApiCall<Void, ApiException> prepareMigrationsUnlockRepoForOrgRequest(
            final String org,
            final int migrationId,
            final String repoName) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock")
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("migration_id").value(migrationId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo_name").value(repoName)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsMigrationsReposRepoNameLock404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List all the repositories for this organization migration.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MinimalRepository response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<MinimalRepository> migrationsListReposForOrg(
            final String org,
            final int migrationId,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareMigrationsListReposForOrgRequest(org, migrationId, perPage, page).execute();
    }

    /**
     * List all the repositories for this organization migration.
     * @param  org  Required parameter: The organization name. The name is not case sensitive.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MinimalRepository response from the API call
     */
    public CompletableFuture<List<MinimalRepository>> migrationsListReposForOrgAsync(
            final String org,
            final int migrationId,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareMigrationsListReposForOrgRequest(org, migrationId, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsListReposForOrg.
     */
    private ApiCall<List<MinimalRepository>, ApiException> prepareMigrationsListReposForOrgRequest(
            final String org,
            final int migrationId,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<MinimalRepository>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/orgs/{org}/migrations/{migration_id}/repositories")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("org").value(org)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("migration_id").value(migrationId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        MinimalRepository[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new OrgsMigrationsRepositories404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * View the progress of an import. **Import status** This section includes details about the
     * possible values of the `status` field of the Import Progress response. An import that does
     * not have errors will progress through these steps: * `detecting` - the "detection" step of
     * the import is in progress because the request did not include a `vcs` parameter. The import
     * is identifying the type of source control present at the URL. * `importing` - the "raw" step
     * of the import is in progress. This is where commit data is fetched from the original
     * repository. The import progress response will include `commit_count` (the total number of raw
     * commits that will be imported) and `percent` (0 - 100, the current progress through the
     * import). * `mapping` - the "rewrite" step of the import is in progress. This is where SVN
     * branches are converted to Git branches, and where author updates are applied. The import
     * progress response does not include progress information. * `pushing` - the "push" step of the
     * import is in progress. This is where the importer updates the repository on GitHub. The
     * import progress response will include `push_percent`, which is the percent value reported by
     * `git push` when it is "Writing objects". * `complete` - the import is complete, and the
     * repository is ready on GitHub. If there are problems, you will see one of these in the
     * `status` field: * `auth_failed` - the import requires authentication in order to connect to
     * the original repository. To update authentication for the import, please see the [Update an
     * import](https://docs.github.com/rest/reference/migrations#update-an-import) section. *
     * `error` - the import encountered an error. The import progress response will include the
     * `failed_step` and an error message. Contact [GitHub
     * Support](https://support.github.com/contact?tags=dotcom-rest-api) for more information. *
     * `detection_needs_auth` - the importer requires authentication for the originating repository
     * to continue detection. To update authentication for the import, please see the [Update an
     * import](https://docs.github.com/rest/reference/migrations#update-an-import) section. *
     * `detection_found_nothing` - the importer didn't recognize any source control at the URL. To
     * resolve, [Cancel the
     * import](https://docs.github.com/rest/reference/migrations#cancel-an-import) and
     * [retry](https://docs.github.com/rest/reference/migrations#start-an-import) with the correct
     * URL. * `detection_found_multiple` - the importer found several projects or repositories at
     * the provided URL. When this is the case, the Import Progress response will also include a
     * `project_choices` field with the possible project choices as values. To update project
     * choice, please see the [Update an
     * import](https://docs.github.com/rest/reference/migrations#update-an-import) section. **The
     * project_choices field** When multiple projects are found at the provided URL, the response
     * hash will include a `project_choices` field, the value of which is an array of hashes each
     * representing a project choice. The exact key/value pairs of the project hashes will differ
     * depending on the version control type. **Git LFS related fields** This section includes
     * details about Git LFS related fields that may be present in the Import Progress response. *
     * `use_lfs` - describes whether the import has been opted in or out of using Git LFS. The value
     * can be `opt_in`, `opt_out`, or `undecided` if no action has been taken. * `has_large_files` -
     * the boolean value describing whether files larger than 100MB were found during the
     * `importing` step. * `large_files_size` - the total size in gigabytes of files larger than
     * 100MB found in the originating repository. * `large_files_count` - the total number of files
     * larger than 100MB found in the originating repository. To see a list of these files, make a
     * "Get Large Files" request.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposImportResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposImportResponse migrationsGetImportStatus(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareMigrationsGetImportStatusRequest(owner, repo).execute();
    }

    /**
     * View the progress of an import. **Import status** This section includes details about the
     * possible values of the `status` field of the Import Progress response. An import that does
     * not have errors will progress through these steps: * `detecting` - the "detection" step of
     * the import is in progress because the request did not include a `vcs` parameter. The import
     * is identifying the type of source control present at the URL. * `importing` - the "raw" step
     * of the import is in progress. This is where commit data is fetched from the original
     * repository. The import progress response will include `commit_count` (the total number of raw
     * commits that will be imported) and `percent` (0 - 100, the current progress through the
     * import). * `mapping` - the "rewrite" step of the import is in progress. This is where SVN
     * branches are converted to Git branches, and where author updates are applied. The import
     * progress response does not include progress information. * `pushing` - the "push" step of the
     * import is in progress. This is where the importer updates the repository on GitHub. The
     * import progress response will include `push_percent`, which is the percent value reported by
     * `git push` when it is "Writing objects". * `complete` - the import is complete, and the
     * repository is ready on GitHub. If there are problems, you will see one of these in the
     * `status` field: * `auth_failed` - the import requires authentication in order to connect to
     * the original repository. To update authentication for the import, please see the [Update an
     * import](https://docs.github.com/rest/reference/migrations#update-an-import) section. *
     * `error` - the import encountered an error. The import progress response will include the
     * `failed_step` and an error message. Contact [GitHub
     * Support](https://support.github.com/contact?tags=dotcom-rest-api) for more information. *
     * `detection_needs_auth` - the importer requires authentication for the originating repository
     * to continue detection. To update authentication for the import, please see the [Update an
     * import](https://docs.github.com/rest/reference/migrations#update-an-import) section. *
     * `detection_found_nothing` - the importer didn't recognize any source control at the URL. To
     * resolve, [Cancel the
     * import](https://docs.github.com/rest/reference/migrations#cancel-an-import) and
     * [retry](https://docs.github.com/rest/reference/migrations#start-an-import) with the correct
     * URL. * `detection_found_multiple` - the importer found several projects or repositories at
     * the provided URL. When this is the case, the Import Progress response will also include a
     * `project_choices` field with the possible project choices as values. To update project
     * choice, please see the [Update an
     * import](https://docs.github.com/rest/reference/migrations#update-an-import) section. **The
     * project_choices field** When multiple projects are found at the provided URL, the response
     * hash will include a `project_choices` field, the value of which is an array of hashes each
     * representing a project choice. The exact key/value pairs of the project hashes will differ
     * depending on the version control type. **Git LFS related fields** This section includes
     * details about Git LFS related fields that may be present in the Import Progress response. *
     * `use_lfs` - describes whether the import has been opted in or out of using Git LFS. The value
     * can be `opt_in`, `opt_out`, or `undecided` if no action has been taken. * `has_large_files` -
     * the boolean value describing whether files larger than 100MB were found during the
     * `importing` step. * `large_files_size` - the total size in gigabytes of files larger than
     * 100MB found in the originating repository. * `large_files_count` - the total number of files
     * larger than 100MB found in the originating repository. To see a list of these files, make a
     * "Get Large Files" request.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the ReposImportResponse response from the API call
     */
    public CompletableFuture<ReposImportResponse> migrationsGetImportStatusAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareMigrationsGetImportStatusRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsGetImportStatus.
     */
    private ApiCall<ReposImportResponse, ApiException> prepareMigrationsGetImportStatusRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<ReposImportResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/import")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposImportResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposImport404ErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.create("Unavailable due to service under maintenance.",
                                (reason, context) -> new ReposImport503ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Start a source import to a GitHub repository using GitHub Importer.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposImportResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposImportResponse migrationsStartImport(
            final String owner,
            final String repo,
            final ReposImportRequest body) throws ApiException, IOException {
        return prepareMigrationsStartImportRequest(owner, repo, body).execute();
    }

    /**
     * Start a source import to a GitHub repository using GitHub Importer.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposImportResponse response from the API call
     */
    public CompletableFuture<ReposImportResponse> migrationsStartImportAsync(
            final String owner,
            final String repo,
            final ReposImportRequest body) {
        try { 
            return prepareMigrationsStartImportRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsStartImport.
     */
    private ApiCall<ReposImportResponse, ApiException> prepareMigrationsStartImportRequest(
            final String owner,
            final String repo,
            final ReposImportRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposImportResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/import")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposImportResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposImport404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposImport422ErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.create("Unavailable due to service under maintenance.",
                                (reason, context) -> new ReposImport503ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * An import can be updated with credentials or a project choice by passing in the appropriate
     * parameters in this API request. If no parameters are provided, the import will be restarted.
     * Some servers (e.g. TFS servers) can have several projects at a single URL. In those cases the
     * import progress will have the status `detection_found_multiple` and the Import Progress
     * response will include a `project_choices` array. You can select the project to import by
     * providing one of the objects in the `project_choices` array in the update request.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposImportResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposImportResponse migrationsUpdateImport(
            final String owner,
            final String repo,
            final Object body) throws ApiException, IOException {
        return prepareMigrationsUpdateImportRequest(owner, repo, body).execute();
    }

    /**
     * An import can be updated with credentials or a project choice by passing in the appropriate
     * parameters in this API request. If no parameters are provided, the import will be restarted.
     * Some servers (e.g. TFS servers) can have several projects at a single URL. In those cases the
     * import progress will have the status `detection_found_multiple` and the Import Progress
     * response will include a `project_choices` array. You can select the project to import by
     * providing one of the objects in the `project_choices` array in the update request.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposImportResponse response from the API call
     */
    public CompletableFuture<ReposImportResponse> migrationsUpdateImportAsync(
            final String owner,
            final String repo,
            final Object body) {
        try { 
            return prepareMigrationsUpdateImportRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsUpdateImport.
     */
    private ApiCall<ReposImportResponse, ApiException> prepareMigrationsUpdateImportRequest(
            final String owner,
            final String repo,
            final Object body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposImportResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/import")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposImportResponse.class))
                        .nullify404(false)
                        .localErrorCase("503",
                                 ErrorCase.create("Unavailable due to service under maintenance.",
                                (reason, context) -> new ReposImport503ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Stop an import for a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void migrationsCancelImport(
            final String owner,
            final String repo) throws ApiException, IOException {
        prepareMigrationsCancelImportRequest(owner, repo).execute();
    }

    /**
     * Stop an import for a repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> migrationsCancelImportAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareMigrationsCancelImportRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsCancelImport.
     */
    private ApiCall<Void, ApiException> prepareMigrationsCancelImportRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/import")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("503",
                                 ErrorCase.create("Unavailable due to service under maintenance.",
                                (reason, context) -> new ReposImport503ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Each type of source control system represents authors in a different way. For example, a Git
     * commit author has a display name and an email address, but a Subversion commit author just
     * has a username. The GitHub Importer will make the author information valid, but the author
     * might not be correct. For example, it will change the bare Subversion username `hubot` into
     * something like `hubot &lt;hubot@12341234-abab-fefe-8787-fedcba987654&gt;`. This endpoint and the
     * [Map a commit author](https://docs.github.com/rest/reference/migrations#map-a-commit-author)
     * endpoint allow you to provide correct Git author information.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  since  Optional parameter: A user ID. Only return users with an ID greater than this
     *         ID.
     * @return    Returns the List of PorterAuthor response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<PorterAuthor> migrationsGetCommitAuthors(
            final String owner,
            final String repo,
            final Integer since) throws ApiException, IOException {
        return prepareMigrationsGetCommitAuthorsRequest(owner, repo, since).execute();
    }

    /**
     * Each type of source control system represents authors in a different way. For example, a Git
     * commit author has a display name and an email address, but a Subversion commit author just
     * has a username. The GitHub Importer will make the author information valid, but the author
     * might not be correct. For example, it will change the bare Subversion username `hubot` into
     * something like `hubot &lt;hubot@12341234-abab-fefe-8787-fedcba987654&gt;`. This endpoint and the
     * [Map a commit author](https://docs.github.com/rest/reference/migrations#map-a-commit-author)
     * endpoint allow you to provide correct Git author information.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  since  Optional parameter: A user ID. Only return users with an ID greater than this
     *         ID.
     * @return    Returns the List of PorterAuthor response from the API call
     */
    public CompletableFuture<List<PorterAuthor>> migrationsGetCommitAuthorsAsync(
            final String owner,
            final String repo,
            final Integer since) {
        try { 
            return prepareMigrationsGetCommitAuthorsRequest(owner, repo, since).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsGetCommitAuthors.
     */
    private ApiCall<List<PorterAuthor>, ApiException> prepareMigrationsGetCommitAuthorsRequest(
            final String owner,
            final String repo,
            final Integer since) throws IOException {
        return new ApiCall.Builder<List<PorterAuthor>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/import/authors")
                        .queryParam(param -> param.key("since")
                                .value(since).isRequired(false))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        PorterAuthor[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposImportAuthors404ErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.create("Unavailable due to service under maintenance.",
                                (reason, context) -> new ReposImportAuthors503ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Update an author's identity for the import. Your application can continue updating authors
     * any time before you push new commits to the repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  authorId  Required parameter: Example:
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposImportAuthorsAuthorIdResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposImportAuthorsAuthorIdResponse migrationsMapCommitAuthor(
            final String owner,
            final String repo,
            final int authorId,
            final ReposImportAuthorsAuthorIdRequest body) throws ApiException, IOException {
        return prepareMigrationsMapCommitAuthorRequest(owner, repo, authorId, body).execute();
    }

    /**
     * Update an author's identity for the import. Your application can continue updating authors
     * any time before you push new commits to the repository.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  authorId  Required parameter: Example:
     * @param  body  Optional parameter: Example:
     * @return    Returns the ReposImportAuthorsAuthorIdResponse response from the API call
     */
    public CompletableFuture<ReposImportAuthorsAuthorIdResponse> migrationsMapCommitAuthorAsync(
            final String owner,
            final String repo,
            final int authorId,
            final ReposImportAuthorsAuthorIdRequest body) {
        try { 
            return prepareMigrationsMapCommitAuthorRequest(owner, repo, authorId, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsMapCommitAuthor.
     */
    private ApiCall<ReposImportAuthorsAuthorIdResponse, ApiException> prepareMigrationsMapCommitAuthorRequest(
            final String owner,
            final String repo,
            final int authorId,
            final ReposImportAuthorsAuthorIdRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposImportAuthorsAuthorIdResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/import/authors/{author_id}")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("author_id").value(authorId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposImportAuthorsAuthorIdResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new ReposImportAuthorsAuthorId404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposImportAuthorsAuthorId422ErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.create("Unavailable due to service under maintenance.",
                                (reason, context) -> new ReposImportAuthorsAuthorId503ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List files larger than 100MB found during the import.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of PorterLargeFile response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<PorterLargeFile> migrationsGetLargeFiles(
            final String owner,
            final String repo) throws ApiException, IOException {
        return prepareMigrationsGetLargeFilesRequest(owner, repo).execute();
    }

    /**
     * List files larger than 100MB found during the import.
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @return    Returns the List of PorterLargeFile response from the API call
     */
    public CompletableFuture<List<PorterLargeFile>> migrationsGetLargeFilesAsync(
            final String owner,
            final String repo) {
        try { 
            return prepareMigrationsGetLargeFilesRequest(owner, repo).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsGetLargeFiles.
     */
    private ApiCall<List<PorterLargeFile>, ApiException> prepareMigrationsGetLargeFilesRequest(
            final String owner,
            final String repo) throws IOException {
        return new ApiCall.Builder<List<PorterLargeFile>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/import/large_files")
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        PorterLargeFile[].class))
                        .nullify404(false)
                        .localErrorCase("503",
                                 ErrorCase.create("Unavailable due to service under maintenance.",
                                (reason, context) -> new ReposImportLargeFiles503ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * You can import repositories from Subversion, Mercurial, and TFS that include files larger
     * than 100MB. This ability is powered by [Git LFS](https://git-lfs.github.com). You can learn
     * more about our LFS feature and working with large files [on our help
     * site](https://docs.github.com/articles/versioning-large-files/).
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposImportLfsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public ReposImportLfsResponse migrationsSetLfsPreference(
            final String owner,
            final String repo,
            final ReposImportLfsRequest body) throws ApiException, IOException {
        return prepareMigrationsSetLfsPreferenceRequest(owner, repo, body).execute();
    }

    /**
     * You can import repositories from Subversion, Mercurial, and TFS that include files larger
     * than 100MB. This ability is powered by [Git LFS](https://git-lfs.github.com). You can learn
     * more about our LFS feature and working with large files [on our help
     * site](https://docs.github.com/articles/versioning-large-files/).
     * @param  owner  Required parameter: The account owner of the repository. The name is not case
     *         sensitive.
     * @param  repo  Required parameter: The name of the repository. The name is not case sensitive.
     * @param  body  Required parameter: Example:
     * @return    Returns the ReposImportLfsResponse response from the API call
     */
    public CompletableFuture<ReposImportLfsResponse> migrationsSetLfsPreferenceAsync(
            final String owner,
            final String repo,
            final ReposImportLfsRequest body) {
        try { 
            return prepareMigrationsSetLfsPreferenceRequest(owner, repo, body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsSetLfsPreference.
     */
    private ApiCall<ReposImportLfsResponse, ApiException> prepareMigrationsSetLfsPreferenceRequest(
            final String owner,
            final String repo,
            final ReposImportLfsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<ReposImportLfsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/repos/{owner}/{repo}/import/lfs")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .templateParam(param -> param.key("owner").value(owner)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo").value(repo)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, ReposImportLfsResponse.class))
                        .nullify404(false)
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new ReposImportLfs422ErrorException(reason, context)))
                        .localErrorCase("503",
                                 ErrorCase.create("Unavailable due to service under maintenance.",
                                (reason, context) -> new ReposImportLfs503ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all migrations a user has started.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Migration response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Migration> migrationsListForAuthenticatedUser(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareMigrationsListForAuthenticatedUserRequest(perPage, page).execute();
    }

    /**
     * Lists all migrations a user has started.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Migration response from the API call
     */
    public CompletableFuture<List<Migration>> migrationsListForAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareMigrationsListForAuthenticatedUserRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsListForAuthenticatedUser.
     */
    private ApiCall<List<Migration>, ApiException> prepareMigrationsListForAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Migration>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/migrations")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Migration[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserMigrations401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserMigrations403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Initiates the generation of a user migration archive.
     * @param  body  Required parameter: Example:
     * @return    Returns the UserMigrationsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserMigrationsResponse migrationsStartForAuthenticatedUser(
            final UserMigrationsRequest body) throws ApiException, IOException {
        return prepareMigrationsStartForAuthenticatedUserRequest(body).execute();
    }

    /**
     * Initiates the generation of a user migration archive.
     * @param  body  Required parameter: Example:
     * @return    Returns the UserMigrationsResponse response from the API call
     */
    public CompletableFuture<UserMigrationsResponse> migrationsStartForAuthenticatedUserAsync(
            final UserMigrationsRequest body) {
        try { 
            return prepareMigrationsStartForAuthenticatedUserRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsStartForAuthenticatedUser.
     */
    private ApiCall<UserMigrationsResponse, ApiException> prepareMigrationsStartForAuthenticatedUserRequest(
            final UserMigrationsRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<UserMigrationsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/migrations")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserMigrationsResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserMigrations401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserMigrations403ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UserMigrations422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Fetches a single user migration. The response includes the `state` of the migration, which
     * can be one of the following values: * `pending` - the migration hasn't started yet. *
     * `exporting` - the migration is in progress. * `exported` - the migration finished
     * successfully. * `failed` - the migration failed. Once the migration has been `exported` you
     * can [download the migration
     * archive](https://docs.github.com/rest/reference/migrations#download-a-user-migration-archive).
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @param  exclude  Optional parameter: Example:
     * @return    Returns the UserMigrationsResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserMigrationsResponse migrationsGetStatusForAuthenticatedUser(
            final int migrationId,
            final List<String> exclude) throws ApiException, IOException {
        return prepareMigrationsGetStatusForAuthenticatedUserRequest(migrationId,
                exclude).execute();
    }

    /**
     * Fetches a single user migration. The response includes the `state` of the migration, which
     * can be one of the following values: * `pending` - the migration hasn't started yet. *
     * `exporting` - the migration is in progress. * `exported` - the migration finished
     * successfully. * `failed` - the migration failed. Once the migration has been `exported` you
     * can [download the migration
     * archive](https://docs.github.com/rest/reference/migrations#download-a-user-migration-archive).
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @param  exclude  Optional parameter: Example:
     * @return    Returns the UserMigrationsResponse response from the API call
     */
    public CompletableFuture<UserMigrationsResponse> migrationsGetStatusForAuthenticatedUserAsync(
            final int migrationId,
            final List<String> exclude) {
        try { 
            return prepareMigrationsGetStatusForAuthenticatedUserRequest(migrationId,
            exclude).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsGetStatusForAuthenticatedUser.
     */
    private ApiCall<UserMigrationsResponse, ApiException> prepareMigrationsGetStatusForAuthenticatedUserRequest(
            final int migrationId,
            final List<String> exclude) throws IOException {
        return new ApiCall.Builder<UserMigrationsResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/migrations/{migration_id}")
                        .queryParam(param -> param.key("exclude")
                                .value(exclude).isRequired(false))
                        .templateParam(param -> param.key("migration_id").value(migrationId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserMigrationsResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserMigrations401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserMigrations403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserMigrations404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Fetches the URL to download the migration archive as a `tar.gz` file. Depending on the
     * resources your repository uses, the migration archive can contain JSON files with data for
     * these objects: * attachments * bases * commit\_comments * issue\_comments * issue\_events *
     * issues * milestones * organizations * projects * protected\_branches * pull\_request\_reviews
     * * pull\_requests * releases * repositories * review\_comments * schema * users The archive
     * will also contain an `attachments` directory that includes all attachment files uploaded to
     * GitHub.com and a `repositories` directory that contains the repository's Git data.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void migrationsGetArchiveForAuthenticatedUser(
            final int migrationId) throws ApiException, IOException {
        prepareMigrationsGetArchiveForAuthenticatedUserRequest(migrationId).execute();
    }

    /**
     * Fetches the URL to download the migration archive as a `tar.gz` file. Depending on the
     * resources your repository uses, the migration archive can contain JSON files with data for
     * these objects: * attachments * bases * commit\_comments * issue\_comments * issue\_events *
     * issues * milestones * organizations * projects * protected\_branches * pull\_request\_reviews
     * * pull\_requests * releases * repositories * review\_comments * schema * users The archive
     * will also contain an `attachments` directory that includes all attachment files uploaded to
     * GitHub.com and a `repositories` directory that contains the repository's Git data.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> migrationsGetArchiveForAuthenticatedUserAsync(
            final int migrationId) {
        try { 
            return prepareMigrationsGetArchiveForAuthenticatedUserRequest(migrationId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsGetArchiveForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareMigrationsGetArchiveForAuthenticatedUserRequest(
            final int migrationId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/migrations/{migration_id}/archive")
                        .templateParam(param -> param.key("migration_id").value(migrationId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserMigrationsArchive401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserMigrationsArchive403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes a previous migration archive. Downloadable migration archives are automatically
     * deleted after seven days. Migration metadata, which is returned in the [List user
     * migrations](https://docs.github.com/rest/reference/migrations#list-user-migrations) and [Get
     * a user migration
     * status](https://docs.github.com/rest/reference/migrations#get-a-user-migration-status)
     * endpoints, will continue to be available even after an archive is deleted.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void migrationsDeleteArchiveForAuthenticatedUser(
            final int migrationId) throws ApiException, IOException {
        prepareMigrationsDeleteArchiveForAuthenticatedUserRequest(migrationId).execute();
    }

    /**
     * Deletes a previous migration archive. Downloadable migration archives are automatically
     * deleted after seven days. Migration metadata, which is returned in the [List user
     * migrations](https://docs.github.com/rest/reference/migrations#list-user-migrations) and [Get
     * a user migration
     * status](https://docs.github.com/rest/reference/migrations#get-a-user-migration-status)
     * endpoints, will continue to be available even after an archive is deleted.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> migrationsDeleteArchiveForAuthenticatedUserAsync(
            final int migrationId) {
        try { 
            return prepareMigrationsDeleteArchiveForAuthenticatedUserRequest(migrationId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsDeleteArchiveForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareMigrationsDeleteArchiveForAuthenticatedUserRequest(
            final int migrationId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/migrations/{migration_id}/archive")
                        .templateParam(param -> param.key("migration_id").value(migrationId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserMigrationsArchive401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserMigrationsArchive403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserMigrationsArchive404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Unlocks a repository. You can lock repositories when you [start a user
     * migration](https://docs.github.com/rest/reference/migrations#start-a-user-migration). Once
     * the migration is complete you can unlock each repository to begin using it again or [delete
     * the repository](https://docs.github.com/rest/reference/repos#delete-a-repository) if you no
     * longer need the source data. Returns a status of `404 Not Found` if the repository is not
     * locked.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @param  repoName  Required parameter: repo_name parameter
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void migrationsUnlockRepoForAuthenticatedUser(
            final int migrationId,
            final String repoName) throws ApiException, IOException {
        prepareMigrationsUnlockRepoForAuthenticatedUserRequest(migrationId, repoName).execute();
    }

    /**
     * Unlocks a repository. You can lock repositories when you [start a user
     * migration](https://docs.github.com/rest/reference/migrations#start-a-user-migration). Once
     * the migration is complete you can unlock each repository to begin using it again or [delete
     * the repository](https://docs.github.com/rest/reference/repos#delete-a-repository) if you no
     * longer need the source data. Returns a status of `404 Not Found` if the repository is not
     * locked.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @param  repoName  Required parameter: repo_name parameter
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> migrationsUnlockRepoForAuthenticatedUserAsync(
            final int migrationId,
            final String repoName) {
        try { 
            return prepareMigrationsUnlockRepoForAuthenticatedUserRequest(migrationId,
            repoName).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsUnlockRepoForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareMigrationsUnlockRepoForAuthenticatedUserRequest(
            final int migrationId,
            final String repoName) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/migrations/{migration_id}/repos/{repo_name}/lock")
                        .templateParam(param -> param.key("migration_id").value(migrationId).isRequired(false)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("repo_name").value(repoName)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserMigrationsReposLock401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserMigrationsReposLock403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserMigrationsReposLock404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all the repositories for this user migration.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MinimalRepository response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<MinimalRepository> migrationsListReposForAuthenticatedUser(
            final int migrationId,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareMigrationsListReposForAuthenticatedUserRequest(migrationId, perPage,
                page).execute();
    }

    /**
     * Lists all the repositories for this user migration.
     * @param  migrationId  Required parameter: The unique identifier of the migration.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of MinimalRepository response from the API call
     */
    public CompletableFuture<List<MinimalRepository>> migrationsListReposForAuthenticatedUserAsync(
            final int migrationId,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareMigrationsListReposForAuthenticatedUserRequest(migrationId, perPage,
            page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for migrationsListReposForAuthenticatedUser.
     */
    private ApiCall<List<MinimalRepository>, ApiException> prepareMigrationsListReposForAuthenticatedUserRequest(
            final int migrationId,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<MinimalRepository>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/migrations/{migration_id}/repositories")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("migration_id").value(migrationId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        MinimalRepository[].class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserMigrationsRepositories404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}