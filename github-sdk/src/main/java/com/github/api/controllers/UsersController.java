/*
 * GitHubAPILib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

package com.github.api.controllers;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.github.api.ApiHelper;
import com.github.api.Server;
import com.github.api.exceptions.ApiException;
import com.github.api.exceptions.User401ErrorException;
import com.github.api.exceptions.User403ErrorException;
import com.github.api.exceptions.User404ErrorException;
import com.github.api.exceptions.User422ErrorException;
import com.github.api.exceptions.UserBlocks401ErrorException;
import com.github.api.exceptions.UserBlocks403ErrorException;
import com.github.api.exceptions.UserBlocks404ErrorException;
import com.github.api.exceptions.UserBlocks422ErrorException;
import com.github.api.exceptions.UserEmailVisibility401ErrorException;
import com.github.api.exceptions.UserEmailVisibility403ErrorException;
import com.github.api.exceptions.UserEmailVisibility404ErrorException;
import com.github.api.exceptions.UserEmailVisibility422ErrorException;
import com.github.api.exceptions.UserEmails401ErrorException;
import com.github.api.exceptions.UserEmails403ErrorException;
import com.github.api.exceptions.UserEmails404ErrorException;
import com.github.api.exceptions.UserEmails422ErrorException;
import com.github.api.exceptions.UserFollowers401ErrorException;
import com.github.api.exceptions.UserFollowers403ErrorException;
import com.github.api.exceptions.UserFollowing401ErrorException;
import com.github.api.exceptions.UserFollowing403ErrorException;
import com.github.api.exceptions.UserFollowing404ErrorException;
import com.github.api.exceptions.UserGpgKeys401ErrorException;
import com.github.api.exceptions.UserGpgKeys403ErrorException;
import com.github.api.exceptions.UserGpgKeys404ErrorException;
import com.github.api.exceptions.UserGpgKeys422ErrorException;
import com.github.api.exceptions.UserKeys401ErrorException;
import com.github.api.exceptions.UserKeys403ErrorException;
import com.github.api.exceptions.UserKeys404ErrorException;
import com.github.api.exceptions.UserKeys422ErrorException;
import com.github.api.exceptions.UserPublicEmails401ErrorException;
import com.github.api.exceptions.UserPublicEmails403ErrorException;
import com.github.api.exceptions.UserPublicEmails404ErrorException;
import com.github.api.exceptions.UserSshSigningKeys401ErrorException;
import com.github.api.exceptions.UserSshSigningKeys403ErrorException;
import com.github.api.exceptions.UserSshSigningKeys404ErrorException;
import com.github.api.exceptions.UserSshSigningKeys422ErrorException;
import com.github.api.exceptions.Users404ErrorException;
import com.github.api.exceptions.UsersHovercard404ErrorException;
import com.github.api.exceptions.UsersHovercard422ErrorException;
import com.github.api.http.request.HttpMethod;
import com.github.api.models.ContentType3Enum;
import com.github.api.models.Email;
import com.github.api.models.GPGKey;
import com.github.api.models.Key;
import com.github.api.models.KeySimple;
import com.github.api.models.SSHSigningKey;
import com.github.api.models.SimpleUser;
import com.github.api.models.SubjectType1Enum;
import com.github.api.models.UserEmailVisibilityRequest;
import com.github.api.models.UserGpgKeysRequest;
import com.github.api.models.UserGpgKeysResponse;
import com.github.api.models.UserKeysRequest;
import com.github.api.models.UserKeysResponse;
import com.github.api.models.UserRequest;
import com.github.api.models.UserResponse;
import com.github.api.models.UserSshSigningKeysRequest;
import com.github.api.models.UserSshSigningKeysResponse;
import com.github.api.models.UsersHovercardResponse;
import com.github.api.models.containers.UsersAddEmailForAuthenticatedUserBody;
import com.github.api.models.containers.UsersGetAuthenticatedResponse;
import com.github.api.models.containers.UsersGetByUsernameResponse;
import io.apimatic.core.ApiCall;
import io.apimatic.core.ErrorCase;
import io.apimatic.core.GlobalConfiguration;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;

/**
 * This class lists all the endpoints of the groups.
 */
public final class UsersController extends BaseController {

    /**
     * Initializes the controller.
     * @param globalConfig    Configurations added in client.
     */
    public UsersController(GlobalConfiguration globalConfig) {
        super(globalConfig);
    }

    /**
     * If the authenticated user is authenticated through basic authentication or OAuth with the
     * `user` scope, then the response lists public and private profile information. If the
     * authenticated user is authenticated through OAuth without the `user` scope, then the response
     * lists only public profile information.
     * @return    Returns the UsersGetAuthenticatedResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UsersGetAuthenticatedResponse usersGetAuthenticated() throws ApiException, IOException {
        return prepareUsersGetAuthenticatedRequest().execute();
    }

    /**
     * If the authenticated user is authenticated through basic authentication or OAuth with the
     * `user` scope, then the response lists public and private profile information. If the
     * authenticated user is authenticated through OAuth without the `user` scope, then the response
     * lists only public profile information.
     * @return    Returns the UsersGetAuthenticatedResponse response from the API call
     */
    public CompletableFuture<UsersGetAuthenticatedResponse> usersGetAuthenticatedAsync() {
        try { 
            return prepareUsersGetAuthenticatedRequest().executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersGetAuthenticated.
     */
    private ApiCall<UsersGetAuthenticatedResponse, ApiException> prepareUsersGetAuthenticatedRequest() throws IOException {
        return new ApiCall.Builder<UsersGetAuthenticatedResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user")
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UsersGetAuthenticatedResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new User401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new User403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * **Note:** If your email is set to private and you send an `email` parameter as part of this
     * request to update your profile, your privacy settings are still enforced: the email address
     * will not be displayed on your public profile or via the API.
     * @param  body  Optional parameter: Example:
     * @return    Returns the UserResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserResponse usersUpdateAuthenticated(
            final UserRequest body) throws ApiException, IOException {
        return prepareUsersUpdateAuthenticatedRequest(body).execute();
    }

    /**
     * **Note:** If your email is set to private and you send an `email` parameter as part of this
     * request to update your profile, your privacy settings are still enforced: the email address
     * will not be displayed on your public profile or via the API.
     * @param  body  Optional parameter: Example:
     * @return    Returns the UserResponse response from the API call
     */
    public CompletableFuture<UserResponse> usersUpdateAuthenticatedAsync(
            final UserRequest body) {
        try { 
            return prepareUsersUpdateAuthenticatedRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersUpdateAuthenticated.
     */
    private ApiCall<UserResponse, ApiException> prepareUsersUpdateAuthenticatedRequest(
            final UserRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<UserResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new User401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new User403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new User404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new User422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * List the users you've blocked on your personal account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SimpleUser response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<SimpleUser> usersListBlockedByAuthenticatedUser(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareUsersListBlockedByAuthenticatedUserRequest(perPage, page).execute();
    }

    /**
     * List the users you've blocked on your personal account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SimpleUser response from the API call
     */
    public CompletableFuture<List<SimpleUser>> usersListBlockedByAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareUsersListBlockedByAuthenticatedUserRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersListBlockedByAuthenticatedUser.
     */
    private ApiCall<List<SimpleUser>, ApiException> prepareUsersListBlockedByAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<SimpleUser>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/blocks")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        SimpleUser[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserBlocks401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserBlocks403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserBlocks404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Check if a user is blocked by the authenticated user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void usersCheckBlocked(
            final String username) throws ApiException, IOException {
        prepareUsersCheckBlockedRequest(username).execute();
    }

    /**
     * Check if a user is blocked by the authenticated user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> usersCheckBlockedAsync(
            final String username) {
        try { 
            return prepareUsersCheckBlockedRequest(username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersCheckBlocked.
     */
    private ApiCall<Void, ApiException> prepareUsersCheckBlockedRequest(
            final String username) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/blocks/{username}")
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserBlocks401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserBlocks403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("If the user is not blocked",
                                (reason, context) -> new UserBlocks404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Block a user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void usersBlock(
            final String username) throws ApiException, IOException {
        prepareUsersBlockRequest(username).execute();
    }

    /**
     * Block a user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> usersBlockAsync(
            final String username) {
        try { 
            return prepareUsersBlockRequest(username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersBlock.
     */
    private ApiCall<Void, ApiException> prepareUsersBlockRequest(
            final String username) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/blocks/{username}")
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserBlocks401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserBlocks403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserBlocks404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UserBlocks422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Unblock a user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void usersUnblock(
            final String username) throws ApiException, IOException {
        prepareUsersUnblockRequest(username).execute();
    }

    /**
     * Unblock a user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> usersUnblockAsync(
            final String username) {
        try { 
            return prepareUsersUnblockRequest(username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersUnblock.
     */
    private ApiCall<Void, ApiException> prepareUsersUnblockRequest(
            final String username) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/blocks/{username}")
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserBlocks401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserBlocks403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserBlocks404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Sets the visibility for your primary email addresses.
     * @param  body  Required parameter: Example:
     * @return    Returns the List of Email response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Email> usersSetPrimaryEmailVisibilityForAuthenticatedUser(
            final UserEmailVisibilityRequest body) throws ApiException, IOException {
        return prepareUsersSetPrimaryEmailVisibilityForAuthenticatedUserRequest(body).execute();
    }

    /**
     * Sets the visibility for your primary email addresses.
     * @param  body  Required parameter: Example:
     * @return    Returns the List of Email response from the API call
     */
    public CompletableFuture<List<Email>> usersSetPrimaryEmailVisibilityForAuthenticatedUserAsync(
            final UserEmailVisibilityRequest body) {
        try { 
            return prepareUsersSetPrimaryEmailVisibilityForAuthenticatedUserRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersSetPrimaryEmailVisibilityForAuthenticatedUser.
     */
    private ApiCall<List<Email>, ApiException> prepareUsersSetPrimaryEmailVisibilityForAuthenticatedUserRequest(
            final UserEmailVisibilityRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<List<Email>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/email/visibility")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PATCH))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Email[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserEmailVisibility401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserEmailVisibility403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserEmailVisibility404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UserEmailVisibility422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all of your email addresses, and specifies which one is visible to the public. This
     * endpoint is accessible with the `user:email` scope.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Email response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Email> usersListEmailsForAuthenticatedUser(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareUsersListEmailsForAuthenticatedUserRequest(perPage, page).execute();
    }

    /**
     * Lists all of your email addresses, and specifies which one is visible to the public. This
     * endpoint is accessible with the `user:email` scope.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Email response from the API call
     */
    public CompletableFuture<List<Email>> usersListEmailsForAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareUsersListEmailsForAuthenticatedUserRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersListEmailsForAuthenticatedUser.
     */
    private ApiCall<List<Email>, ApiException> prepareUsersListEmailsForAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Email>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/emails")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Email[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserEmails401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserEmails403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserEmails404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This endpoint is accessible with the `user` scope.
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of Email response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Email> usersAddEmailForAuthenticatedUser(
            final UsersAddEmailForAuthenticatedUserBody body) throws ApiException, IOException {
        return prepareUsersAddEmailForAuthenticatedUserRequest(body).execute();
    }

    /**
     * This endpoint is accessible with the `user` scope.
     * @param  body  Optional parameter: Example:
     * @return    Returns the List of Email response from the API call
     */
    public CompletableFuture<List<Email>> usersAddEmailForAuthenticatedUserAsync(
            final UsersAddEmailForAuthenticatedUserBody body) {
        try { 
            return prepareUsersAddEmailForAuthenticatedUserRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersAddEmailForAuthenticatedUser.
     */
    private ApiCall<List<Email>, ApiException> prepareUsersAddEmailForAuthenticatedUserRequest(
            final UsersAddEmailForAuthenticatedUserBody body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<List<Email>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/emails")
                        .bodyParam(param -> param.value(body).isRequired(false))
                        .bodySerializer(() ->  ApiHelper.serializeTypeCombinator(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Email[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserEmails401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserEmails403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserEmails404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UserEmails422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * This endpoint is accessible with the `user` scope.
     * @param  contentType  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void usersDeleteEmailForAuthenticatedUser(
            final ContentType3Enum contentType) throws ApiException, IOException {
        prepareUsersDeleteEmailForAuthenticatedUserRequest(contentType).execute();
    }

    /**
     * This endpoint is accessible with the `user` scope.
     * @param  contentType  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> usersDeleteEmailForAuthenticatedUserAsync(
            final ContentType3Enum contentType) {
        try { 
            return prepareUsersDeleteEmailForAuthenticatedUserRequest(contentType).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersDeleteEmailForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareUsersDeleteEmailForAuthenticatedUserRequest(
            final ContentType3Enum contentType) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/emails")
                        .headerParam(param -> param.key("Content-Type")
                                .value((contentType != null) ? contentType.value() : null).isRequired(false))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserEmails401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserEmails403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserEmails404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UserEmails422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the people following the authenticated user.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SimpleUser response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<SimpleUser> usersListFollowersForAuthenticatedUser(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareUsersListFollowersForAuthenticatedUserRequest(perPage, page).execute();
    }

    /**
     * Lists the people following the authenticated user.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SimpleUser response from the API call
     */
    public CompletableFuture<List<SimpleUser>> usersListFollowersForAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareUsersListFollowersForAuthenticatedUserRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersListFollowersForAuthenticatedUser.
     */
    private ApiCall<List<SimpleUser>, ApiException> prepareUsersListFollowersForAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<SimpleUser>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/followers")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        SimpleUser[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserFollowers401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserFollowers403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the people who the authenticated user follows.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SimpleUser response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<SimpleUser> usersListFollowedByAuthenticatedUser(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareUsersListFollowedByAuthenticatedUserRequest(perPage, page).execute();
    }

    /**
     * Lists the people who the authenticated user follows.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SimpleUser response from the API call
     */
    public CompletableFuture<List<SimpleUser>> usersListFollowedByAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareUsersListFollowedByAuthenticatedUserRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersListFollowedByAuthenticatedUser.
     */
    private ApiCall<List<SimpleUser>, ApiException> prepareUsersListFollowedByAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<SimpleUser>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/following")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        SimpleUser[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserFollowing401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserFollowing403ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Check if a person is followed by the authenticated user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void usersCheckPersonIsFollowedByAuthenticated(
            final String username) throws ApiException, IOException {
        prepareUsersCheckPersonIsFollowedByAuthenticatedRequest(username).execute();
    }

    /**
     * Check if a person is followed by the authenticated user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> usersCheckPersonIsFollowedByAuthenticatedAsync(
            final String username) {
        try { 
            return prepareUsersCheckPersonIsFollowedByAuthenticatedRequest(username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersCheckPersonIsFollowedByAuthenticated.
     */
    private ApiCall<Void, ApiException> prepareUsersCheckPersonIsFollowedByAuthenticatedRequest(
            final String username) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/following/{username}")
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserFollowing401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserFollowing403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("if the person is not followed by the authenticated user",
                                (reason, context) -> new UserFollowing404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For
     * more information, see "[HTTP
     * verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
     * Following a user requires the user to be logged in and authenticated with basic auth or OAuth
     * with the `user:follow` scope.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void usersFollow(
            final String username) throws ApiException, IOException {
        prepareUsersFollowRequest(username).execute();
    }

    /**
     * Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For
     * more information, see "[HTTP
     * verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."
     * Following a user requires the user to be logged in and authenticated with basic auth or OAuth
     * with the `user:follow` scope.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> usersFollowAsync(
            final String username) {
        try { 
            return prepareUsersFollowRequest(username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersFollow.
     */
    private ApiCall<Void, ApiException> prepareUsersFollowRequest(
            final String username) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/following/{username}")
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.PUT))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserFollowing401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserFollowing403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserFollowing404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Unfollowing a user requires the user to be logged in and authenticated with basic auth or
     * OAuth with the `user:follow` scope.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void usersUnfollow(
            final String username) throws ApiException, IOException {
        prepareUsersUnfollowRequest(username).execute();
    }

    /**
     * Unfollowing a user requires the user to be logged in and authenticated with basic auth or
     * OAuth with the `user:follow` scope.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> usersUnfollowAsync(
            final String username) {
        try { 
            return prepareUsersUnfollowRequest(username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersUnfollow.
     */
    private ApiCall<Void, ApiException> prepareUsersUnfollowRequest(
            final String username) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/following/{username}")
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserFollowing401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserFollowing403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserFollowing404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the current user's GPG keys. Requires that you are authenticated via Basic Auth or via
     * OAuth with at least `read:gpg_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of GPGKey response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<GPGKey> usersListGpgKeysForAuthenticatedUser(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareUsersListGpgKeysForAuthenticatedUserRequest(perPage, page).execute();
    }

    /**
     * Lists the current user's GPG keys. Requires that you are authenticated via Basic Auth or via
     * OAuth with at least `read:gpg_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of GPGKey response from the API call
     */
    public CompletableFuture<List<GPGKey>> usersListGpgKeysForAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareUsersListGpgKeysForAuthenticatedUserRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersListGpgKeysForAuthenticatedUser.
     */
    private ApiCall<List<GPGKey>, ApiException> prepareUsersListGpgKeysForAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<GPGKey>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/gpg_keys")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        GPGKey[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserGpgKeys401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserGpgKeys403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserGpgKeys404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Adds a GPG key to the authenticated user's GitHub account. Requires that you are
     * authenticated via Basic Auth, or OAuth with at least `write:gpg_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  body  Required parameter: Example:
     * @return    Returns the UserGpgKeysResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserGpgKeysResponse usersCreateGpgKeyForAuthenticatedUser(
            final UserGpgKeysRequest body) throws ApiException, IOException {
        return prepareUsersCreateGpgKeyForAuthenticatedUserRequest(body).execute();
    }

    /**
     * Adds a GPG key to the authenticated user's GitHub account. Requires that you are
     * authenticated via Basic Auth, or OAuth with at least `write:gpg_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  body  Required parameter: Example:
     * @return    Returns the UserGpgKeysResponse response from the API call
     */
    public CompletableFuture<UserGpgKeysResponse> usersCreateGpgKeyForAuthenticatedUserAsync(
            final UserGpgKeysRequest body) {
        try { 
            return prepareUsersCreateGpgKeyForAuthenticatedUserRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersCreateGpgKeyForAuthenticatedUser.
     */
    private ApiCall<UserGpgKeysResponse, ApiException> prepareUsersCreateGpgKeyForAuthenticatedUserRequest(
            final UserGpgKeysRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<UserGpgKeysResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/gpg_keys")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserGpgKeysResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserGpgKeys401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserGpgKeys403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserGpgKeys404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UserGpgKeys422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * View extended details for a single GPG key. Requires that you are authenticated via Basic
     * Auth or via OAuth with at least `read:gpg_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  gpgKeyId  Required parameter: The unique identifier of the GPG key.
     * @return    Returns the UserGpgKeysResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserGpgKeysResponse usersGetGpgKeyForAuthenticatedUser(
            final int gpgKeyId) throws ApiException, IOException {
        return prepareUsersGetGpgKeyForAuthenticatedUserRequest(gpgKeyId).execute();
    }

    /**
     * View extended details for a single GPG key. Requires that you are authenticated via Basic
     * Auth or via OAuth with at least `read:gpg_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  gpgKeyId  Required parameter: The unique identifier of the GPG key.
     * @return    Returns the UserGpgKeysResponse response from the API call
     */
    public CompletableFuture<UserGpgKeysResponse> usersGetGpgKeyForAuthenticatedUserAsync(
            final int gpgKeyId) {
        try { 
            return prepareUsersGetGpgKeyForAuthenticatedUserRequest(gpgKeyId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersGetGpgKeyForAuthenticatedUser.
     */
    private ApiCall<UserGpgKeysResponse, ApiException> prepareUsersGetGpgKeyForAuthenticatedUserRequest(
            final int gpgKeyId) throws IOException {
        return new ApiCall.Builder<UserGpgKeysResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/gpg_keys/{gpg_key_id}")
                        .templateParam(param -> param.key("gpg_key_id").value(gpgKeyId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserGpgKeysResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserGpgKeys401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserGpgKeys403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserGpgKeys404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes a GPG key from the authenticated user's GitHub account. Requires that you are
     * authenticated via Basic Auth or via OAuth with at least `admin:gpg_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  gpgKeyId  Required parameter: The unique identifier of the GPG key.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void usersDeleteGpgKeyForAuthenticatedUser(
            final int gpgKeyId) throws ApiException, IOException {
        prepareUsersDeleteGpgKeyForAuthenticatedUserRequest(gpgKeyId).execute();
    }

    /**
     * Removes a GPG key from the authenticated user's GitHub account. Requires that you are
     * authenticated via Basic Auth or via OAuth with at least `admin:gpg_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  gpgKeyId  Required parameter: The unique identifier of the GPG key.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> usersDeleteGpgKeyForAuthenticatedUserAsync(
            final int gpgKeyId) {
        try { 
            return prepareUsersDeleteGpgKeyForAuthenticatedUserRequest(gpgKeyId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersDeleteGpgKeyForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareUsersDeleteGpgKeyForAuthenticatedUserRequest(
            final int gpgKeyId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/gpg_keys/{gpg_key_id}")
                        .templateParam(param -> param.key("gpg_key_id").value(gpgKeyId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserGpgKeys401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserGpgKeys403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserGpgKeys404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UserGpgKeys422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the public SSH keys for the authenticated user's GitHub account. Requires that you are
     * authenticated via Basic Auth or via OAuth with at least `read:public_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Key response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Key> usersListPublicSshKeysForAuthenticatedUser(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareUsersListPublicSshKeysForAuthenticatedUserRequest(perPage, page).execute();
    }

    /**
     * Lists the public SSH keys for the authenticated user's GitHub account. Requires that you are
     * authenticated via Basic Auth or via OAuth with at least `read:public_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Key response from the API call
     */
    public CompletableFuture<List<Key>> usersListPublicSshKeysForAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareUsersListPublicSshKeysForAuthenticatedUserRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersListPublicSshKeysForAuthenticatedUser.
     */
    private ApiCall<List<Key>, ApiException> prepareUsersListPublicSshKeysForAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Key>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/keys")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Key[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserKeys401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserKeys403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserKeys404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Adds a public SSH key to the authenticated user's GitHub account. Requires that you are
     * authenticated via Basic Auth, or OAuth with at least `write:public_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  body  Required parameter: Example:
     * @return    Returns the UserKeysResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserKeysResponse usersCreatePublicSshKeyForAuthenticatedUser(
            final UserKeysRequest body) throws ApiException, IOException {
        return prepareUsersCreatePublicSshKeyForAuthenticatedUserRequest(body).execute();
    }

    /**
     * Adds a public SSH key to the authenticated user's GitHub account. Requires that you are
     * authenticated via Basic Auth, or OAuth with at least `write:public_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  body  Required parameter: Example:
     * @return    Returns the UserKeysResponse response from the API call
     */
    public CompletableFuture<UserKeysResponse> usersCreatePublicSshKeyForAuthenticatedUserAsync(
            final UserKeysRequest body) {
        try { 
            return prepareUsersCreatePublicSshKeyForAuthenticatedUserRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersCreatePublicSshKeyForAuthenticatedUser.
     */
    private ApiCall<UserKeysResponse, ApiException> prepareUsersCreatePublicSshKeyForAuthenticatedUserRequest(
            final UserKeysRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<UserKeysResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/keys")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserKeysResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserKeys401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserKeys403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserKeys404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UserKeys422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * View extended details for a single public SSH key. Requires that you are authenticated via
     * Basic Auth or via OAuth with at least `read:public_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  keyId  Required parameter: The unique identifier of the key.
     * @return    Returns the UserKeysResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserKeysResponse usersGetPublicSshKeyForAuthenticatedUser(
            final int keyId) throws ApiException, IOException {
        return prepareUsersGetPublicSshKeyForAuthenticatedUserRequest(keyId).execute();
    }

    /**
     * View extended details for a single public SSH key. Requires that you are authenticated via
     * Basic Auth or via OAuth with at least `read:public_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  keyId  Required parameter: The unique identifier of the key.
     * @return    Returns the UserKeysResponse response from the API call
     */
    public CompletableFuture<UserKeysResponse> usersGetPublicSshKeyForAuthenticatedUserAsync(
            final int keyId) {
        try { 
            return prepareUsersGetPublicSshKeyForAuthenticatedUserRequest(keyId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersGetPublicSshKeyForAuthenticatedUser.
     */
    private ApiCall<UserKeysResponse, ApiException> prepareUsersGetPublicSshKeyForAuthenticatedUserRequest(
            final int keyId) throws IOException {
        return new ApiCall.Builder<UserKeysResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/keys/{key_id}")
                        .templateParam(param -> param.key("key_id").value(keyId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserKeysResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserKeys401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserKeys403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserKeys404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Removes a public SSH key from the authenticated user's GitHub account. Requires that you are
     * authenticated via Basic Auth or via OAuth with at least `admin:public_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  keyId  Required parameter: The unique identifier of the key.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void usersDeletePublicSshKeyForAuthenticatedUser(
            final int keyId) throws ApiException, IOException {
        prepareUsersDeletePublicSshKeyForAuthenticatedUserRequest(keyId).execute();
    }

    /**
     * Removes a public SSH key from the authenticated user's GitHub account. Requires that you are
     * authenticated via Basic Auth or via OAuth with at least `admin:public_key`
     * [scope](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).
     * @param  keyId  Required parameter: The unique identifier of the key.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> usersDeletePublicSshKeyForAuthenticatedUserAsync(
            final int keyId) {
        try { 
            return prepareUsersDeletePublicSshKeyForAuthenticatedUserRequest(keyId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersDeletePublicSshKeyForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareUsersDeletePublicSshKeyForAuthenticatedUserRequest(
            final int keyId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/keys/{key_id}")
                        .templateParam(param -> param.key("key_id").value(keyId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserKeys401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserKeys403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserKeys404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists your publicly visible email address, which you can set with the [Set primary email
     * visibility for the authenticated
     * user](https://docs.github.com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user)
     * endpoint. This endpoint is accessible with the `user:email` scope.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Email response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<Email> usersListPublicEmailsForAuthenticatedUser(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareUsersListPublicEmailsForAuthenticatedUserRequest(perPage, page).execute();
    }

    /**
     * Lists your publicly visible email address, which you can set with the [Set primary email
     * visibility for the authenticated
     * user](https://docs.github.com/rest/reference/users#set-primary-email-visibility-for-the-authenticated-user)
     * endpoint. This endpoint is accessible with the `user:email` scope.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of Email response from the API call
     */
    public CompletableFuture<List<Email>> usersListPublicEmailsForAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareUsersListPublicEmailsForAuthenticatedUserRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersListPublicEmailsForAuthenticatedUser.
     */
    private ApiCall<List<Email>, ApiException> prepareUsersListPublicEmailsForAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<Email>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/public_emails")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        Email[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserPublicEmails401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserPublicEmails403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserPublicEmails404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the SSH signing keys for the authenticated user's GitHub account. You must authenticate
     * with Basic Authentication, or you must authenticate with OAuth with at least
     * `read:ssh_signing_key` scope. For more information, see "[Understanding scopes for OAuth
     * apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).".
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SSHSigningKey response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<SSHSigningKey> usersListSshSigningKeysForAuthenticatedUser(
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareUsersListSshSigningKeysForAuthenticatedUserRequest(perPage, page).execute();
    }

    /**
     * Lists the SSH signing keys for the authenticated user's GitHub account. You must authenticate
     * with Basic Authentication, or you must authenticate with OAuth with at least
     * `read:ssh_signing_key` scope. For more information, see "[Understanding scopes for OAuth
     * apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).".
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SSHSigningKey response from the API call
     */
    public CompletableFuture<List<SSHSigningKey>> usersListSshSigningKeysForAuthenticatedUserAsync(
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareUsersListSshSigningKeysForAuthenticatedUserRequest(perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersListSshSigningKeysForAuthenticatedUser.
     */
    private ApiCall<List<SSHSigningKey>, ApiException> prepareUsersListSshSigningKeysForAuthenticatedUserRequest(
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<SSHSigningKey>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/ssh_signing_keys")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        SSHSigningKey[].class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserSshSigningKeys401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserSshSigningKeys403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserSshSigningKeys404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Creates an SSH signing key for the authenticated user's GitHub account. You must authenticate
     * with Basic Authentication, or you must authenticate with OAuth with at least
     * `write:ssh_signing_key` scope. For more information, see "[Understanding scopes for OAuth
     * apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).".
     * @param  body  Required parameter: Example:
     * @return    Returns the UserSshSigningKeysResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserSshSigningKeysResponse usersCreateSshSigningKeyForAuthenticatedUser(
            final UserSshSigningKeysRequest body) throws ApiException, IOException {
        return prepareUsersCreateSshSigningKeyForAuthenticatedUserRequest(body).execute();
    }

    /**
     * Creates an SSH signing key for the authenticated user's GitHub account. You must authenticate
     * with Basic Authentication, or you must authenticate with OAuth with at least
     * `write:ssh_signing_key` scope. For more information, see "[Understanding scopes for OAuth
     * apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).".
     * @param  body  Required parameter: Example:
     * @return    Returns the UserSshSigningKeysResponse response from the API call
     */
    public CompletableFuture<UserSshSigningKeysResponse> usersCreateSshSigningKeyForAuthenticatedUserAsync(
            final UserSshSigningKeysRequest body) {
        try { 
            return prepareUsersCreateSshSigningKeyForAuthenticatedUserRequest(body).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersCreateSshSigningKeyForAuthenticatedUser.
     */
    private ApiCall<UserSshSigningKeysResponse, ApiException> prepareUsersCreateSshSigningKeyForAuthenticatedUserRequest(
            final UserSshSigningKeysRequest body) throws JsonProcessingException, IOException {
        return new ApiCall.Builder<UserSshSigningKeysResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/ssh_signing_keys")
                        .bodyParam(param -> param.value(body))
                        .bodySerializer(() ->  ApiHelper.serialize(body))
                        .headerParam(param -> param.key("Content-Type")
                                .value("application/json").isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.POST))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserSshSigningKeysResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserSshSigningKeys401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserSshSigningKeys403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserSshSigningKeys404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UserSshSigningKeys422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Gets extended details for an SSH signing key. You must authenticate with Basic
     * Authentication, or you must authenticate with OAuth with at least `read:ssh_signing_key`
     * scope. For more information, see "[Understanding scopes for OAuth
     * apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).".
     * @param  sshSigningKeyId  Required parameter: The unique identifier of the SSH signing key.
     * @return    Returns the UserSshSigningKeysResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UserSshSigningKeysResponse usersGetSshSigningKeyForAuthenticatedUser(
            final int sshSigningKeyId) throws ApiException, IOException {
        return prepareUsersGetSshSigningKeyForAuthenticatedUserRequest(sshSigningKeyId).execute();
    }

    /**
     * Gets extended details for an SSH signing key. You must authenticate with Basic
     * Authentication, or you must authenticate with OAuth with at least `read:ssh_signing_key`
     * scope. For more information, see "[Understanding scopes for OAuth
     * apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).".
     * @param  sshSigningKeyId  Required parameter: The unique identifier of the SSH signing key.
     * @return    Returns the UserSshSigningKeysResponse response from the API call
     */
    public CompletableFuture<UserSshSigningKeysResponse> usersGetSshSigningKeyForAuthenticatedUserAsync(
            final int sshSigningKeyId) {
        try { 
            return prepareUsersGetSshSigningKeyForAuthenticatedUserRequest(sshSigningKeyId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersGetSshSigningKeyForAuthenticatedUser.
     */
    private ApiCall<UserSshSigningKeysResponse, ApiException> prepareUsersGetSshSigningKeyForAuthenticatedUserRequest(
            final int sshSigningKeyId) throws IOException {
        return new ApiCall.Builder<UserSshSigningKeysResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/ssh_signing_keys/{ssh_signing_key_id}")
                        .templateParam(param -> param.key("ssh_signing_key_id").value(sshSigningKeyId).isRequired(false)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UserSshSigningKeysResponse.class))
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserSshSigningKeys401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserSshSigningKeys403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserSshSigningKeys404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Deletes an SSH signing key from the authenticated user's GitHub account. You must
     * authenticate with Basic Authentication, or you must authenticate with OAuth with at least
     * `admin:ssh_signing_key` scope. For more information, see "[Understanding scopes for OAuth
     * apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).".
     * @param  sshSigningKeyId  Required parameter: The unique identifier of the SSH signing key.
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void usersDeleteSshSigningKeyForAuthenticatedUser(
            final int sshSigningKeyId) throws ApiException, IOException {
        prepareUsersDeleteSshSigningKeyForAuthenticatedUserRequest(sshSigningKeyId).execute();
    }

    /**
     * Deletes an SSH signing key from the authenticated user's GitHub account. You must
     * authenticate with Basic Authentication, or you must authenticate with OAuth with at least
     * `admin:ssh_signing_key` scope. For more information, see "[Understanding scopes for OAuth
     * apps](https://docs.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/).".
     * @param  sshSigningKeyId  Required parameter: The unique identifier of the SSH signing key.
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> usersDeleteSshSigningKeyForAuthenticatedUserAsync(
            final int sshSigningKeyId) {
        try { 
            return prepareUsersDeleteSshSigningKeyForAuthenticatedUserRequest(
            sshSigningKeyId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersDeleteSshSigningKeyForAuthenticatedUser.
     */
    private ApiCall<Void, ApiException> prepareUsersDeleteSshSigningKeyForAuthenticatedUserRequest(
            final int sshSigningKeyId) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/user/ssh_signing_keys/{ssh_signing_key_id}")
                        .templateParam(param -> param.key("ssh_signing_key_id").value(sshSigningKeyId).isRequired(false)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.DELETE))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("401",
                                 ErrorCase.create("Requires authentication",
                                (reason, context) -> new UserSshSigningKeys401ErrorException(reason, context)))
                        .localErrorCase("403",
                                 ErrorCase.create("Forbidden",
                                (reason, context) -> new UserSshSigningKeys403ErrorException(reason, context)))
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UserSshSigningKeys404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists all users, in the order that they signed up on GitHub. This list includes personal user
     * accounts and organization accounts. Note: Pagination is powered exclusively by the `since`
     * parameter. Use the [Link
     * header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get
     * the URL for the next page of users.
     * @param  since  Optional parameter: A user ID. Only return users with an ID greater than this
     *         ID.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the List of SimpleUser response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<SimpleUser> usersList(
            final Integer since,
            final Integer perPage) throws ApiException, IOException {
        return prepareUsersListRequest(since, perPage).execute();
    }

    /**
     * Lists all users, in the order that they signed up on GitHub. This list includes personal user
     * accounts and organization accounts. Note: Pagination is powered exclusively by the `since`
     * parameter. Use the [Link
     * header](https://docs.github.com/rest/overview/resources-in-the-rest-api#link-header) to get
     * the URL for the next page of users.
     * @param  since  Optional parameter: A user ID. Only return users with an ID greater than this
     *         ID.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @return    Returns the List of SimpleUser response from the API call
     */
    public CompletableFuture<List<SimpleUser>> usersListAsync(
            final Integer since,
            final Integer perPage) {
        try { 
            return prepareUsersListRequest(since, perPage).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersList.
     */
    private ApiCall<List<SimpleUser>, ApiException> prepareUsersListRequest(
            final Integer since,
            final Integer perPage) throws IOException {
        return new ApiCall.Builder<List<SimpleUser>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users")
                        .queryParam(param -> param.key("since")
                                .value(since).isRequired(false))
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        SimpleUser[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Provides publicly available information about someone with a GitHub account. GitHub Apps with
     * the `Plan` user permission can use this endpoint to retrieve information about a user's
     * GitHub plan. The GitHub App must be authenticated as a user. See "[Identifying and
     * authorizing users for GitHub
     * Apps](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)"
     * for details about authentication. For an example response, see 'Response with GitHub plan
     * information' below" The `email` key in the following response is the publicly visible email
     * address from your GitHub [profile page](https://github.com/settings/profile). When setting up
     * your profile, you can select a primary email address to be “public” which provides an email
     * entry for this endpoint. If you do not set a public email address for `email`, then it will
     * have a value of `null`. You only see publicly visible email addresses when authenticated with
     * GitHub. For more information, see
     * [Authentication](https://docs.github.com/rest/overview/resources-in-the-rest-api#authentication).
     * The Emails API enables you to list all of your email addresses, and toggle a primary email to
     * be visible publicly. For more information, see "[Emails
     * API](https://docs.github.com/rest/reference/users#emails)".
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the UsersGetByUsernameResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UsersGetByUsernameResponse usersGetByUsername(
            final String username) throws ApiException, IOException {
        return prepareUsersGetByUsernameRequest(username).execute();
    }

    /**
     * Provides publicly available information about someone with a GitHub account. GitHub Apps with
     * the `Plan` user permission can use this endpoint to retrieve information about a user's
     * GitHub plan. The GitHub App must be authenticated as a user. See "[Identifying and
     * authorizing users for GitHub
     * Apps](https://docs.github.com/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/)"
     * for details about authentication. For an example response, see 'Response with GitHub plan
     * information' below" The `email` key in the following response is the publicly visible email
     * address from your GitHub [profile page](https://github.com/settings/profile). When setting up
     * your profile, you can select a primary email address to be “public” which provides an email
     * entry for this endpoint. If you do not set a public email address for `email`, then it will
     * have a value of `null`. You only see publicly visible email addresses when authenticated with
     * GitHub. For more information, see
     * [Authentication](https://docs.github.com/rest/overview/resources-in-the-rest-api#authentication).
     * The Emails API enables you to list all of your email addresses, and toggle a primary email to
     * be visible publicly. For more information, see "[Emails
     * API](https://docs.github.com/rest/reference/users#emails)".
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @return    Returns the UsersGetByUsernameResponse response from the API call
     */
    public CompletableFuture<UsersGetByUsernameResponse> usersGetByUsernameAsync(
            final String username) {
        try { 
            return prepareUsersGetByUsernameRequest(username).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersGetByUsername.
     */
    private ApiCall<UsersGetByUsernameResponse, ApiException> prepareUsersGetByUsernameRequest(
            final String username) throws IOException {
        return new ApiCall.Builder<UsersGetByUsernameResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}")
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UsersGetByUsernameResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new Users404ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the people following the specified user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SimpleUser response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<SimpleUser> usersListFollowersForUser(
            final String username,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareUsersListFollowersForUserRequest(username, perPage, page).execute();
    }

    /**
     * Lists the people following the specified user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SimpleUser response from the API call
     */
    public CompletableFuture<List<SimpleUser>> usersListFollowersForUserAsync(
            final String username,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareUsersListFollowersForUserRequest(username, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersListFollowersForUser.
     */
    private ApiCall<List<SimpleUser>, ApiException> prepareUsersListFollowersForUserRequest(
            final String username,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<SimpleUser>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/followers")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        SimpleUser[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the people who the specified user follows.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SimpleUser response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<SimpleUser> usersListFollowingForUser(
            final String username,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareUsersListFollowingForUserRequest(username, perPage, page).execute();
    }

    /**
     * Lists the people who the specified user follows.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SimpleUser response from the API call
     */
    public CompletableFuture<List<SimpleUser>> usersListFollowingForUserAsync(
            final String username,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareUsersListFollowingForUserRequest(username, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersListFollowingForUser.
     */
    private ApiCall<List<SimpleUser>, ApiException> prepareUsersListFollowingForUserRequest(
            final String username,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<SimpleUser>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/following")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        SimpleUser[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Check if a user follows another user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  targetUser  Required parameter: Example:
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public void usersCheckFollowingForUser(
            final String username,
            final String targetUser) throws ApiException, IOException {
        prepareUsersCheckFollowingForUserRequest(username, targetUser).execute();
    }

    /**
     * Check if a user follows another user.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  targetUser  Required parameter: Example:
     * @return    Returns the void response from the API call
     */
    public CompletableFuture<Void> usersCheckFollowingForUserAsync(
            final String username,
            final String targetUser) {
        try { 
            return prepareUsersCheckFollowingForUserRequest(username, targetUser).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersCheckFollowingForUser.
     */
    private ApiCall<Void, ApiException> prepareUsersCheckFollowingForUserRequest(
            final String username,
            final String targetUser) throws IOException {
        return new ApiCall.Builder<Void, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/following/{target_user}")
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .templateParam(param -> param.key("target_user").value(targetUser)
                                .shouldEncode(true))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("if the user does not follow the target user",
                                (reason, context) -> new ApiException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the GPG keys for a user. This information is accessible by anyone.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of GPGKey response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<GPGKey> usersListGpgKeysForUser(
            final String username,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareUsersListGpgKeysForUserRequest(username, perPage, page).execute();
    }

    /**
     * Lists the GPG keys for a user. This information is accessible by anyone.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of GPGKey response from the API call
     */
    public CompletableFuture<List<GPGKey>> usersListGpgKeysForUserAsync(
            final String username,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareUsersListGpgKeysForUserRequest(username, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersListGpgKeysForUser.
     */
    private ApiCall<List<GPGKey>, ApiException> prepareUsersListGpgKeysForUserRequest(
            final String username,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<GPGKey>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/gpg_keys")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        GPGKey[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Provides hovercard information when authenticated through basic auth or OAuth with the `repo`
     * scope. You can find out more about someone in relation to their pull requests, issues,
     * repositories, and organizations. The `subject_type` and `subject_id` parameters provide
     * context for the person's hovercard, which returns more information than without the
     * parameters. For example, if you wanted to find out more about `octocat` who owns the
     * `Spoon-Knife` repository via cURL, it would look like this: ```shell curl -u username:token
     * https://api.github.com/users/octocat/hovercard?subject_type=repository&subject_id=1300192
     * ```.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  subjectType  Optional parameter: Identifies which additional information you'd like
     *         to receive about the person's hovercard. Can be `organization`, `repository`,
     *         `issue`, `pull_request`. **Required** when using `subject_id`.
     * @param  subjectId  Optional parameter: Uses the ID for the `subject_type` you specified.
     *         **Required** when using `subject_type`.
     * @return    Returns the UsersHovercardResponse response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public UsersHovercardResponse usersGetContextForUser(
            final String username,
            final SubjectType1Enum subjectType,
            final String subjectId) throws ApiException, IOException {
        return prepareUsersGetContextForUserRequest(username, subjectType, subjectId).execute();
    }

    /**
     * Provides hovercard information when authenticated through basic auth or OAuth with the `repo`
     * scope. You can find out more about someone in relation to their pull requests, issues,
     * repositories, and organizations. The `subject_type` and `subject_id` parameters provide
     * context for the person's hovercard, which returns more information than without the
     * parameters. For example, if you wanted to find out more about `octocat` who owns the
     * `Spoon-Knife` repository via cURL, it would look like this: ```shell curl -u username:token
     * https://api.github.com/users/octocat/hovercard?subject_type=repository&subject_id=1300192
     * ```.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  subjectType  Optional parameter: Identifies which additional information you'd like
     *         to receive about the person's hovercard. Can be `organization`, `repository`,
     *         `issue`, `pull_request`. **Required** when using `subject_id`.
     * @param  subjectId  Optional parameter: Uses the ID for the `subject_type` you specified.
     *         **Required** when using `subject_type`.
     * @return    Returns the UsersHovercardResponse response from the API call
     */
    public CompletableFuture<UsersHovercardResponse> usersGetContextForUserAsync(
            final String username,
            final SubjectType1Enum subjectType,
            final String subjectId) {
        try { 
            return prepareUsersGetContextForUserRequest(username, subjectType, subjectId).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersGetContextForUser.
     */
    private ApiCall<UsersHovercardResponse, ApiException> prepareUsersGetContextForUserRequest(
            final String username,
            final SubjectType1Enum subjectType,
            final String subjectId) throws IOException {
        return new ApiCall.Builder<UsersHovercardResponse, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/hovercard")
                        .queryParam(param -> param.key("subject_type")
                                .value((subjectType != null) ? subjectType.value() : null).isRequired(false))
                        .queryParam(param -> param.key("subject_id")
                                .value(subjectId).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserialize(response, UsersHovercardResponse.class))
                        .nullify404(false)
                        .localErrorCase("404",
                                 ErrorCase.create("Resource not found",
                                (reason, context) -> new UsersHovercard404ErrorException(reason, context)))
                        .localErrorCase("422",
                                 ErrorCase.create("Validation failed, or the endpoint has been spammed.",
                                (reason, context) -> new UsersHovercard422ErrorException(reason, context)))
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of KeySimple response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<KeySimple> usersListPublicKeysForUser(
            final String username,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareUsersListPublicKeysForUserRequest(username, perPage, page).execute();
    }

    /**
     * Lists the _verified_ public SSH keys for a user. This is accessible by anyone.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of KeySimple response from the API call
     */
    public CompletableFuture<List<KeySimple>> usersListPublicKeysForUserAsync(
            final String username,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareUsersListPublicKeysForUserRequest(username, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersListPublicKeysForUser.
     */
    private ApiCall<List<KeySimple>, ApiException> prepareUsersListPublicKeysForUserRequest(
            final String username,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<KeySimple>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/keys")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        KeySimple[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }

    /**
     * Lists the SSH signing keys for a user. This operation is accessible by anyone.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SSHSigningKey response from the API call
     * @throws    ApiException    Represents error response from the server.
     * @throws    IOException    Signals that an I/O exception of some sort has occurred.
     */
    public List<SSHSigningKey> usersListSshSigningKeysForUser(
            final String username,
            final Integer perPage,
            final Integer page) throws ApiException, IOException {
        return prepareUsersListSshSigningKeysForUserRequest(username, perPage, page).execute();
    }

    /**
     * Lists the SSH signing keys for a user. This operation is accessible by anyone.
     * @param  username  Required parameter: The handle for the GitHub user account.
     * @param  perPage  Optional parameter: The number of results per page (max 100).
     * @param  page  Optional parameter: Page number of the results to fetch.
     * @return    Returns the List of SSHSigningKey response from the API call
     */
    public CompletableFuture<List<SSHSigningKey>> usersListSshSigningKeysForUserAsync(
            final String username,
            final Integer perPage,
            final Integer page) {
        try { 
            return prepareUsersListSshSigningKeysForUserRequest(username, perPage, page).executeAsync(); 
        } catch (Exception e) {  
            throw new CompletionException(e); 
        }
    }

    /**
     * Builds the ApiCall object for usersListSshSigningKeysForUser.
     */
    private ApiCall<List<SSHSigningKey>, ApiException> prepareUsersListSshSigningKeysForUserRequest(
            final String username,
            final Integer perPage,
            final Integer page) throws IOException {
        return new ApiCall.Builder<List<SSHSigningKey>, ApiException>()
                .globalConfig(getGlobalConfiguration())
                .requestBuilder(requestBuilder -> requestBuilder
                        .server(Server.ENUM_DEFAULT.value())
                        .path("/users/{username}/ssh_signing_keys")
                        .queryParam(param -> param.key("per_page")
                                .value((perPage != null) ? perPage : 30).isRequired(false))
                        .queryParam(param -> param.key("page")
                                .value((page != null) ? page : 1).isRequired(false))
                        .templateParam(param -> param.key("username").value(username)
                                .shouldEncode(true))
                        .headerParam(param -> param.key("accept").value("application/json"))
                        .authenticationKey(BaseController.AUTHENTICATION_KEY)
                        .httpMethod(HttpMethod.GET))
                .responseHandler(responseHandler -> responseHandler
                        .deserializer(
                                response -> ApiHelper.deserializeArray(response,
                                        SSHSigningKey[].class))
                        .nullify404(false)
                        .globalErrorCase(GLOBAL_ERROR_CASES))
                .build();
    }
}